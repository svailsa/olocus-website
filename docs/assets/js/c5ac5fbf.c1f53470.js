"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5118],{7145:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/security/hsm-integration","title":"HSM Integration","description":"The HSM extension provides enterprise-grade Hardware Security Module integration for cryptographic operations with FIPS 140-2/3 compliance and high-assurance key management.","source":"@site/docs/extensions/security/hsm-integration.md","sourceDirName":"extensions/security","slug":"/extensions/security/hsm-integration","permalink":"/docs/extensions/security/hsm-integration","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/security/hsm-integration.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":3,"frontMatter":{"id":"hsm-integration","title":"HSM Integration","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Device Integrity","permalink":"/docs/extensions/security/device-integrity"},"next":{"title":"Keystore Management","permalink":"/docs/extensions/security/keystore"}}');var s=t(4848),o=t(8453);const a={id:"hsm-integration",title:"HSM Integration",sidebar_position:3},r="HSM Integration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"PKCS#11 Integration",id:"pkcs11-integration",level:2},{value:"PKCS#11 Implementation",id:"pkcs11-implementation",level:3},{value:"Session Pool Management",id:"session-pool-management",level:3},{value:"Cloud HSM Integration",id:"cloud-hsm-integration",level:2},{value:"AWS CloudHSM",id:"aws-cloudhsm",level:3},{value:"Azure Key Vault",id:"azure-key-vault",level:3},{value:"Key Management &amp; Rotation",id:"key-management--rotation",level:2},{value:"Automated Key Rotation",id:"automated-key-rotation",level:3},{value:"Key Versioning &amp; History",id:"key-versioning--history",level:3},{value:"Health Monitoring &amp; Compliance",id:"health-monitoring--compliance",level:2},{value:"HSM Health Monitoring",id:"hsm-health-monitoring",level:3},{value:"Compliance Reporting",id:"compliance-reporting",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Enterprise Key Management",id:"enterprise-key-management",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function _(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"hsm-integration",children:"HSM Integration"})}),"\n",(0,s.jsx)(n.p,{children:"The HSM extension provides enterprise-grade Hardware Security Module integration for cryptographic operations with FIPS 140-2/3 compliance and high-assurance key management."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The HSM extension supports multiple HSM types and provides unified APIs for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PKCS#11"}),": On-premise HSMs (Thales Luna, Entrust nShield, Utimaco)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cloud HSMs"}),": AWS CloudHSM, Azure Key Vault, Google Cloud HSM"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Session Management"}),": Connection pooling and load balancing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Management"}),": Generation, rotation, archival with versioning"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compliance"}),": FIPS 140-2 Level 2/3, Common Criteria"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring"}),": Health checks, performance metrics, audit logging"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::*;\n\n// Configure HSM backend\nlet hsm_config = HSMConfig {\n    backend: HSMBackend::PKCS11 {\n        library_path: "/usr/lib/libCryptoki2_64.so".to_string(),\n        slot_id: 0,\n        pin: "your_hsm_pin".to_string(),\n        token_label: Some("OlocusToken".to_string()),\n    },\n    session_pool: SessionPoolConfig {\n        min_sessions: 2,\n        max_sessions: 10,\n        idle_timeout: Duration::from_mins(30),\n    },\n    key_rotation: KeyRotationConfig {\n        enabled: true,\n        rotation_interval: Duration::from_days(90),\n        retention_versions: 3,\n    },\n};\n\nlet hsm = HSMManager::new(hsm_config).await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"pkcs11-integration",children:"PKCS#11 Integration"}),"\n",(0,s.jsx)(n.p,{children:"PKCS#11 provides standardized access to cryptographic tokens and HSMs:"}),"\n",(0,s.jsx)(n.h3,{id:"pkcs11-implementation",children:"PKCS#11 Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_hsm::pkcs11::*;\nuse pkcs11::{Ctx, Session, Mechanism, ObjectClass, KeyType};\n\npub struct PKCS11HSM {\n    context: Ctx,\n    session_pool: Arc<Mutex<SessionPool>>,\n    config: PKCS11Config,\n    slot_id: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct PKCS11Config {\n    pub library_path: String,\n    pub slot_id: u64,\n    pub pin: String,\n    pub token_label: Option<String>,\n    pub auto_login: bool,\n    pub read_only: bool,\n}\n\nimpl HSMBackend for PKCS11HSM {\n    async fn initialize(&mut self) -> Result<()> {\n        // Initialize PKCS#11 library\n        self.context = Ctx::new_and_initialize(&self.config.library_path)\n            .map_err(|e| HSMError::InitializationFailed(e.to_string()))?;\n            \n        // Get slot information\n        let slots = self.context.get_slots_with_initialized_token()\n            .map_err(|e| HSMError::SlotError(e.to_string()))?;\n            \n        if !slots.contains(&self.slot_id) {\n            return Err(HSMError::SlotNotFound(self.slot_id));\n        }\n        \n        // Verify token is present\n        let token_info = self.context.get_token_info(self.slot_id)\n            .map_err(|e| HSMError::TokenError(e.to_string()))?;\n            \n        if let Some(ref expected_label) = self.config.token_label {\n            if token_info.label.trim() != expected_label {\n                return Err(HSMError::TokenLabelMismatch {\n                    expected: expected_label.clone(),\n                    found: token_info.label.clone(),\n                });\n            }\n        }\n        \n        // Initialize session pool\n        self.initialize_session_pool().await?;\n        \n        Ok(())\n    }\n    \n    async fn generate_key_pair(&self, key_spec: &KeySpec) -> Result<HSMKeyHandle> {\n        let session = self.acquire_session().await?;\n        \n        let key_handle = match key_spec.algorithm {\n            KeyAlgorithm::Ed25519 => {\n                self.generate_ed25519_key_pair(&session, key_spec).await?\n            },\n            KeyAlgorithm::ECDSA(curve) => {\n                self.generate_ecdsa_key_pair(&session, key_spec, curve).await?\n            },\n            KeyAlgorithm::RSA(key_size) => {\n                self.generate_rsa_key_pair(&session, key_spec, key_size).await?\n            }\n        };\n        \n        self.release_session(session).await?;\n        Ok(key_handle)\n    }\n    \n    async fn sign(&self, key_handle: &HSMKeyHandle, data: &[u8]) -> Result<Vec<u8>> {\n        let session = self.acquire_session().await?;\n        \n        // Get private key object\n        let private_key = self.get_private_key_object(&session, &key_handle.private_key_id).await?;\n        \n        // Choose mechanism based on key algorithm\n        let mechanism = match key_handle.algorithm {\n            KeyAlgorithm::Ed25519 => Mechanism::EdDSA,\n            KeyAlgorithm::ECDSA(_) => Mechanism::ECDSA,\n            KeyAlgorithm::RSA(_) => Mechanism::RsaPkcs,\n        };\n        \n        // Initialize signing operation\n        session.sign_init(&mechanism, &private_key)\n            .map_err(|e| HSMError::SigningFailed(e.to_string()))?;\n            \n        // Perform signing\n        let signature = session.sign(data)\n            .map_err(|e| HSMError::SigningFailed(e.to_string()))?;\n            \n        self.release_session(session).await?;\n        \n        // Log signing operation\n        self.log_cryptographic_operation(CryptoOperation {\n            operation_type: OperationType::Sign,\n            key_id: key_handle.key_id.clone(),\n            algorithm: key_handle.algorithm.clone(),\n            timestamp: SystemTime::now(),\n            success: true,\n        }).await?;\n        \n        Ok(signature)\n    }\n    \n    async fn verify(&self, key_handle: &HSMKeyHandle, data: &[u8], signature: &[u8]) -> Result<bool> {\n        let session = self.acquire_session().await?;\n        \n        // Get public key object\n        let public_key = self.get_public_key_object(&session, &key_handle.public_key_id).await?;\n        \n        let mechanism = match key_handle.algorithm {\n            KeyAlgorithm::Ed25519 => Mechanism::EdDSA,\n            KeyAlgorithm::ECDSA(_) => Mechanism::ECDSA,\n            KeyAlgorithm::RSA(_) => Mechanism::RsaPkcs,\n        };\n        \n        // Initialize verification\n        session.verify_init(&mechanism, &public_key)\n            .map_err(|e| HSMError::VerificationFailed(e.to_string()))?;\n            \n        // Perform verification\n        let is_valid = session.verify(data, signature).is_ok();\n        \n        self.release_session(session).await?;\n        \n        Ok(is_valid)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"session-pool-management",children:"Session Pool Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use tokio::sync::Semaphore;\n\npub struct SessionPool {\n    sessions: VecDeque<HSMSession>,\n    config: SessionPoolConfig,\n    semaphore: Arc<Semaphore>,\n    metrics: SessionPoolMetrics,\n}\n\n#[derive(Debug, Clone)]\npub struct SessionPoolConfig {\n    pub min_sessions: usize,\n    pub max_sessions: usize,\n    pub idle_timeout: Duration,\n    pub health_check_interval: Duration,\n    pub retry_attempts: u32,\n}\n\n#[derive(Debug)]\npub struct HSMSession {\n    pub session: Session,\n    pub created_at: SystemTime,\n    pub last_used: SystemTime,\n    pub operation_count: u64,\n    pub is_healthy: bool,\n}\n\nimpl SessionPool {\n    pub async fn new(context: &Ctx, slot_id: u64, config: SessionPoolConfig) -> Result<Self> {\n        let mut pool = Self {\n            sessions: VecDeque::new(),\n            config: config.clone(),\n            semaphore: Arc::new(Semaphore::new(config.max_sessions)),\n            metrics: SessionPoolMetrics::new(),\n        };\n        \n        // Create minimum number of sessions\n        for _ in 0..config.min_sessions {\n            let session = pool.create_session(context, slot_id).await?;\n            pool.sessions.push_back(session);\n        }\n        \n        Ok(pool)\n    }\n    \n    pub async fn acquire_session(&mut self) -> Result<HSMSession> {\n        // Wait for available slot\n        let _permit = self.semaphore.acquire().await\n            .map_err(|_| HSMError::SessionPoolExhausted)?;\n            \n        // Try to get existing session\n        if let Some(mut session) = self.sessions.pop_front() {\n            // Check if session is still healthy\n            if self.is_session_healthy(&session).await? {\n                session.last_used = SystemTime::now();\n                session.operation_count += 1;\n                self.metrics.sessions_acquired += 1;\n                return Ok(session);\n            } else {\n                // Session is unhealthy, create new one\n                self.metrics.sessions_recycled += 1;\n            }\n        }\n        \n        // Create new session if needed\n        if self.sessions.len() + 1 <= self.config.max_sessions {\n            let session = self.create_session(&self.context, self.slot_id).await?;\n            self.metrics.sessions_created += 1;\n            Ok(session)\n        } else {\n            Err(HSMError::SessionPoolExhausted)\n        }\n    }\n    \n    pub async fn release_session(&mut self, session: HSMSession) {\n        // Check if we should keep this session\n        let should_keep = self.sessions.len() < self.config.min_sessions ||\n                         (session.is_healthy && \n                          SystemTime::now().duration_since(session.created_at).unwrap_or_default() < \n                          Duration::from_hours(1));\n                          \n        if should_keep {\n            self.sessions.push_back(session);\n        } else {\n            // Close the session\n            let _ = session.session.close();\n            self.metrics.sessions_destroyed += 1;\n        }\n        \n        self.metrics.sessions_released += 1;\n    }\n    \n    async fn create_session(&self, context: &Ctx, slot_id: u64) -> Result<HSMSession> {\n        let flags = pkcs11::types::CKF_SERIAL_SESSION | pkcs11::types::CKF_RW_SESSION;\n        \n        let session = context.open_session(slot_id, flags, None, None)\n            .map_err(|e| HSMError::SessionCreationFailed(e.to_string()))?;\n            \n        // Login if required\n        if !self.config.read_only {\n            session.login(pkcs11::types::CKU_USER, Some(&self.config.pin))\n                .map_err(|e| HSMError::LoginFailed(e.to_string()))?;\n        }\n        \n        Ok(HSMSession {\n            session,\n            created_at: SystemTime::now(),\n            last_used: SystemTime::now(),\n            operation_count: 0,\n            is_healthy: true,\n        })\n    }\n    \n    async fn is_session_healthy(&self, session: &HSMSession) -> Result<bool> {\n        // Check session age\n        let age = SystemTime::now().duration_since(session.created_at).unwrap_or_default();\n        if age > Duration::from_hours(8) {\n            return Ok(false);\n        }\n        \n        // Check if session is still responsive\n        match session.session.get_session_info() {\n            Ok(_) => Ok(true),\n            Err(_) => Ok(false),\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cloud-hsm-integration",children:"Cloud HSM Integration"}),"\n",(0,s.jsx)(n.h3,{id:"aws-cloudhsm",children:"AWS CloudHSM"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::aws::*;\nuse rusoto_cloudhsmv2::{CloudHsmV2, CloudHsmV2Client};\n\npub struct AWSCloudHSM {\n    client: CloudHsmV2Client,\n    cluster_id: String,\n    config: AWSCloudHSMConfig,\n    connection_pool: ConnectionPool,\n}\n\n#[derive(Debug, Clone)]\npub struct AWSCloudHSMConfig {\n    pub region: String,\n    pub cluster_id: String,\n    pub crypto_user: String,\n    pub crypto_password: String,\n    pub connection_timeout: Duration,\n    pub max_connections: u32,\n}\n\nimpl HSMBackend for AWSCloudHSM {\n    async fn initialize(&mut self) -> Result<()> {\n        // Verify cluster is active\n        let cluster_info = self.client.describe_clusters(DescribeClustersRequest {\n            filters: None,\n            max_results: None,\n            next_token: None,\n        }).await.map_err(|e| HSMError::CloudHSMError(e.to_string()))?;\n        \n        let cluster = cluster_info.clusters\n            .and_then(|clusters| clusters.into_iter()\n                .find(|c| c.cluster_id.as_ref() == Some(&self.cluster_id)))\n            .ok_or_else(|| HSMError::ClusterNotFound(self.cluster_id.clone()))?;\n            \n        if cluster.state != Some("ACTIVE".to_string()) {\n            return Err(HSMError::ClusterNotActive {\n                cluster_id: self.cluster_id.clone(),\n                state: cluster.state.unwrap_or_else(|| "UNKNOWN".to_string()),\n            });\n        }\n        \n        // Initialize connection pool\n        self.connection_pool = self.create_connection_pool().await?;\n        \n        Ok(())\n    }\n    \n    async fn generate_key_pair(&self, key_spec: &KeySpec) -> Result<HSMKeyHandle> {\n        let connection = self.connection_pool.acquire().await?;\n        \n        // Use CloudHSM\'s key generation commands\n        let key_handle = match key_spec.algorithm {\n            KeyAlgorithm::RSA(key_size) => {\n                self.generate_rsa_key_aws(&connection, key_spec, key_size).await?\n            },\n            KeyAlgorithm::ECDSA(curve) => {\n                self.generate_ec_key_aws(&connection, key_spec, curve).await?\n            },\n            _ => {\n                return Err(HSMError::UnsupportedAlgorithm(key_spec.algorithm.clone()));\n            }\n        };\n        \n        self.connection_pool.release(connection).await;\n        Ok(key_handle)\n    }\n    \n    async fn sign(&self, key_handle: &HSMKeyHandle, data: &[u8]) -> Result<Vec<u8>> {\n        let connection = self.connection_pool.acquire().await?;\n        \n        // Execute signing command on CloudHSM\n        let sign_command = format!(\n            "sign -m {} -k {}",\n            hex::encode(data),\n            key_handle.private_key_id\n        );\n        \n        let result = connection.execute_command(&sign_command).await?;\n        let signature = self.parse_signature_response(&result)?;\n        \n        self.connection_pool.release(connection).await;\n        \n        // Log operation\n        self.log_cryptographic_operation(CryptoOperation {\n            operation_type: OperationType::Sign,\n            key_id: key_handle.key_id.clone(),\n            algorithm: key_handle.algorithm.clone(),\n            timestamp: SystemTime::now(),\n            success: true,\n        }).await?;\n        \n        Ok(signature)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"azure-key-vault",children:"Azure Key Vault"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::azure::*;\nuse azure_security_keyvault::KeyvaultClient;\n\npub struct AzureKeyVault {\n    client: KeyvaultClient,\n    vault_url: String,\n    config: AzureKeyVaultConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct AzureKeyVaultConfig {\n    pub vault_url: String,\n    pub tenant_id: String,\n    pub client_id: String,\n    pub client_secret: String,\n    pub hsm_enabled: bool,  // Use managed HSM or software keys\n}\n\nimpl HSMBackend for AzureKeyVault {\n    async fn initialize(&mut self) -> Result<()> {\n        // Authenticate with Azure\n        let credential = ClientSecretCredential::new(\n            &self.config.tenant_id,\n            &self.config.client_id,\n            &self.config.client_secret,\n            TokenCredentialOptions::default()\n        );\n        \n        self.client = KeyvaultClient::new(&self.vault_url, Arc::new(credential))\n            .map_err(|e| HSMError::AuthenticationFailed(e.to_string()))?;\n            \n        // Test connection\n        let _ = self.client.get_keys().into_stream().next().await\n            .ok_or(HSMError::ConnectionFailed("Unable to list keys".to_string()))??;\n            \n        Ok(())\n    }\n    \n    async fn generate_key_pair(&self, key_spec: &KeySpec) -> Result<HSMKeyHandle> {\n        let key_type = match key_spec.algorithm {\n            KeyAlgorithm::RSA(size) => KeyType::Rsa { key_size: size as u32 },\n            KeyAlgorithm::ECDSA(curve) => KeyType::Ec { curve: self.map_curve(curve)? },\n            _ => return Err(HSMError::UnsupportedAlgorithm(key_spec.algorithm.clone())),\n        };\n        \n        let key_name = format!("olocus-{}", key_spec.key_id);\n        \n        let create_request = CreateKeyOptions::new(key_name.clone(), key_type)\n            .hsm(self.config.hsm_enabled)  // Use HSM if available\n            .key_operations(vec![\n                KeyOperation::Sign,\n                KeyOperation::Verify,\n            ])\n            .attributes(\n                KeyAttributes::new()\n                    .enabled(true)\n                    .expires_on(key_spec.expiry_date)\n            );\n            \n        let created_key = self.client.create_key(&create_request).await\n            .map_err(|e| HSMError::KeyGenerationFailed(e.to_string()))?;\n            \n        Ok(HSMKeyHandle {\n            key_id: key_spec.key_id.clone(),\n            algorithm: key_spec.algorithm.clone(),\n            private_key_id: created_key.key().id().to_string(),\n            public_key_id: created_key.key().id().to_string(), // Same in Azure KV\n            created_at: SystemTime::now(),\n            expires_at: key_spec.expiry_date,\n            metadata: self.create_key_metadata(&created_key),\n        })\n    }\n    \n    async fn sign(&self, key_handle: &HSMKeyHandle, data: &[u8]) -> Result<Vec<u8>> {\n        let algorithm = match key_handle.algorithm {\n            KeyAlgorithm::RSA(_) => SignatureAlgorithm::RS256,\n            KeyAlgorithm::ECDSA(ECCurve::P256) => SignatureAlgorithm::ES256,\n            KeyAlgorithm::ECDSA(ECCurve::P384) => SignatureAlgorithm::ES384,\n            _ => return Err(HSMError::UnsupportedAlgorithm(key_handle.algorithm.clone())),\n        };\n        \n        // Hash the data (Azure KV expects pre-hashed data for some algorithms)\n        let digest = match algorithm {\n            SignatureAlgorithm::RS256 | SignatureAlgorithm::ES256 => {\n                sha256::digest(data).as_bytes().to_vec()\n            },\n            SignatureAlgorithm::ES384 => {\n                sha384::digest(data).as_bytes().to_vec()\n            },\n            _ => data.to_vec(),\n        };\n        \n        let sign_request = SignRequest::new(algorithm, digest);\n        \n        let signature_result = self.client.sign(&key_handle.private_key_id, &sign_request).await\n            .map_err(|e| HSMError::SigningFailed(e.to_string()))?;\n            \n        Ok(signature_result.signature().to_vec())\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"key-management--rotation",children:"Key Management & Rotation"}),"\n",(0,s.jsx)(n.h3,{id:"automated-key-rotation",children:"Automated Key Rotation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::rotation::*;\n\npub struct KeyRotationManager {\n    hsm: Arc<dyn HSMBackend>,\n    rotation_config: KeyRotationConfig,\n    key_registry: KeyRegistry,\n    scheduler: TaskScheduler,\n}\n\n#[derive(Debug, Clone)]\npub struct KeyRotationConfig {\n    pub enabled: bool,\n    pub rotation_interval: Duration,\n    pub retention_versions: u32,\n    pub advance_warning: Duration,      // Notify before rotation\n    pub overlap_period: Duration,       // Keep old key active during transition\n    pub emergency_rotation: bool,       // Allow emergency rotation\n}\n\nimpl KeyRotationManager {\n    pub async fn schedule_rotation(&mut self, key_id: &str) -> Result<()> {\n        let key_info = self.key_registry.get_key_info(key_id)\n            .ok_or_else(|| HSMError::KeyNotFound(key_id.to_string()))?;\n            \n        let next_rotation = key_info.created_at + self.rotation_config.rotation_interval;\n        \n        // Schedule advance warning\n        let warning_time = next_rotation - self.rotation_config.advance_warning;\n        self.scheduler.schedule_task(warning_time, ScheduledTask::RotationWarning {\n            key_id: key_id.to_string(),\n            rotation_time: next_rotation,\n        }).await?;\n        \n        // Schedule actual rotation\n        self.scheduler.schedule_task(next_rotation, ScheduledTask::KeyRotation {\n            key_id: key_id.to_string(),\n        }).await?;\n        \n        Ok(())\n    }\n    \n    pub async fn rotate_key(&mut self, key_id: &str) -> Result<KeyRotationResult> {\n        let current_key = self.key_registry.get_key_info(key_id)\n            .ok_or_else(|| HSMError::KeyNotFound(key_id.to_string()))?;\n            \n        // Generate new key with same algorithm\n        let new_key_spec = KeySpec {\n            key_id: format!("{}-v{}", key_id, current_key.version + 1),\n            algorithm: current_key.algorithm.clone(),\n            key_usage: current_key.key_usage.clone(),\n            expiry_date: SystemTime::now() + self.rotation_config.rotation_interval,\n        };\n        \n        let new_key_handle = self.hsm.generate_key_pair(&new_key_spec).await?;\n        \n        // Register new key\n        self.key_registry.register_key(KeyInfo {\n            key_id: new_key_spec.key_id.clone(),\n            algorithm: new_key_spec.algorithm,\n            key_handle: new_key_handle.clone(),\n            version: current_key.version + 1,\n            created_at: SystemTime::now(),\n            status: KeyStatus::Active,\n            predecessor: Some(key_id.to_string()),\n        }).await?;\n        \n        // Mark old key as superseded but keep it active during overlap\n        self.key_registry.update_key_status(key_id, KeyStatus::Superseded).await?;\n        \n        // Schedule old key deactivation after overlap period\n        let deactivation_time = SystemTime::now() + self.rotation_config.overlap_period;\n        self.scheduler.schedule_task(deactivation_time, ScheduledTask::DeactivateKey {\n            key_id: key_id.to_string(),\n        }).await?;\n        \n        // Schedule cleanup of old versions\n        self.schedule_version_cleanup(&new_key_spec.key_id).await?;\n        \n        Ok(KeyRotationResult {\n            old_key_id: key_id.to_string(),\n            new_key_id: new_key_spec.key_id,\n            new_key_handle,\n            rotation_time: SystemTime::now(),\n            overlap_until: deactivation_time,\n        })\n    }\n    \n    pub async fn emergency_rotate_key(&mut self, key_id: &str, reason: &str) -> Result<KeyRotationResult> {\n        if !self.rotation_config.emergency_rotation {\n            return Err(HSMError::EmergencyRotationDisabled);\n        }\n        \n        // Log emergency rotation\n        self.log_security_event(SecurityEvent {\n            event_type: SecurityEventType::EmergencyKeyRotation,\n            key_id: key_id.to_string(),\n            reason: reason.to_string(),\n            timestamp: SystemTime::now(),\n            severity: SecuritySeverity::High,\n        }).await?;\n        \n        // Perform immediate rotation with no overlap period\n        let mut emergency_config = self.rotation_config.clone();\n        emergency_config.overlap_period = Duration::ZERO;\n        \n        let result = self.rotate_key(key_id).await?;\n        \n        // Immediately revoke old key\n        self.key_registry.update_key_status(key_id, KeyStatus::Revoked).await?;\n        \n        Ok(result)\n    }\n    \n    async fn schedule_version_cleanup(&mut self, base_key_id: &str) -> Result<()> {\n        // Find all versions of this key\n        let all_versions = self.key_registry.get_key_versions(base_key_id).await?;\n        \n        if all_versions.len() > self.rotation_config.retention_versions as usize {\n            // Sort by version number\n            let mut sorted_versions = all_versions;\n            sorted_versions.sort_by_key(|k| k.version);\n            \n            // Schedule cleanup of oldest versions beyond retention limit\n            let to_cleanup = sorted_versions.len() - self.rotation_config.retention_versions as usize;\n            for key_info in sorted_versions.into_iter().take(to_cleanup) {\n                let cleanup_time = SystemTime::now() + Duration::from_hours(24); // Grace period\n                \n                self.scheduler.schedule_task(cleanup_time, ScheduledTask::CleanupKey {\n                    key_id: key_info.key_id,\n                }).await?;\n            }\n        }\n        \n        Ok(())\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-versioning--history",children:"Key Versioning & History"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct KeyRegistry {\n    storage: Arc<dyn KeyStorage>,\n    version_cache: LruCache<String, Vec<KeyInfo>>,\n}\n\n#[derive(Debug, Clone)]\npub struct KeyInfo {\n    pub key_id: String,\n    pub algorithm: KeyAlgorithm,\n    pub key_handle: HSMKeyHandle,\n    pub version: u32,\n    pub created_at: SystemTime,\n    pub expires_at: SystemTime,\n    pub status: KeyStatus,\n    pub predecessor: Option<String>,      // Previous version\n    pub successor: Option<String>,        // Next version\n    pub usage_count: u64,\n    pub last_used: Option<SystemTime>,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum KeyStatus {\n    Active,        // Currently in use\n    Superseded,    // Replaced but still valid for verification\n    Revoked,       // Compromised or invalid\n    Archived,      // Old but kept for compliance\n    Destroyed,     // Securely destroyed\n}\n\nimpl KeyRegistry {\n    pub async fn get_active_key(&self, base_key_id: &str) -> Option<KeyInfo> {\n        let versions = self.get_key_versions(base_key_id).await.ok()?;\n        \n        versions.into_iter()\n            .filter(|k| k.status == KeyStatus::Active)\n            .max_by_key(|k| k.version)\n    }\n    \n    pub async fn get_key_for_verification(&self, base_key_id: &str, signature_time: SystemTime) -> Option<KeyInfo> {\n        let versions = self.get_key_versions(base_key_id).await.ok()?;\n        \n        // Find the key that was active at the time of signing\n        versions.into_iter()\n            .filter(|k| {\n                k.created_at <= signature_time &&\n                (k.status == KeyStatus::Active || k.status == KeyStatus::Superseded) &&\n                signature_time < k.expires_at\n            })\n            .max_by_key(|k| k.version)\n    }\n    \n    pub async fn record_key_usage(&mut self, key_id: &str) -> Result<()> {\n        let mut key_info = self.storage.get_key_info(key_id).await?\n            .ok_or_else(|| HSMError::KeyNotFound(key_id.to_string()))?;\n            \n        key_info.usage_count += 1;\n        key_info.last_used = Some(SystemTime::now());\n        \n        self.storage.update_key_info(&key_info).await?;\n        \n        // Invalidate cache\n        self.version_cache.remove(&self.extract_base_key_id(key_id));\n        \n        Ok(())\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"health-monitoring--compliance",children:"Health Monitoring & Compliance"}),"\n",(0,s.jsx)(n.h3,{id:"hsm-health-monitoring",children:"HSM Health Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::monitoring::*;\n\npub struct HSMHealthMonitor {\n    hsm: Arc<dyn HSMBackend>,\n    metrics: HSMMetrics,\n    health_checks: Vec<HealthCheck>,\n    alert_manager: AlertManager,\n}\n\n#[derive(Debug, Clone)]\npub struct HSMMetrics {\n    pub operations_per_second: f64,\n    pub average_latency: Duration,\n    pub error_rate: f64,\n    pub session_utilization: f64,\n    pub key_generation_rate: f64,\n    pub signing_operations: u64,\n    pub verification_operations: u64,\n    pub failed_operations: u64,\n    pub uptime: Duration,\n    pub last_health_check: SystemTime,\n}\n\nimpl HSMHealthMonitor {\n    pub async fn perform_health_check(&mut self) -> HealthCheckResult {\n        let mut results = Vec::new();\n        let start_time = SystemTime::now();\n        \n        // Basic connectivity check\n        let connectivity = self.check_connectivity().await;\n        results.push(connectivity);\n        \n        // Performance check\n        let performance = self.check_performance().await;\n        results.push(performance);\n        \n        // Capacity check\n        let capacity = self.check_capacity().await;\n        results.push(capacity);\n        \n        // Security check\n        let security = self.check_security().await;\n        results.push(security);\n        \n        // FIPS compliance check\n        let compliance = self.check_fips_compliance().await;\n        results.push(compliance);\n        \n        let overall_status = if results.iter().all(|r| r.status == CheckStatus::Healthy) {\n            HealthStatus::Healthy\n        } else if results.iter().any(|r| r.status == CheckStatus::Critical) {\n            HealthStatus::Critical\n        } else {\n            HealthStatus::Degraded\n        };\n        \n        let duration = SystemTime::now().duration_since(start_time).unwrap_or_default();\n        \n        HealthCheckResult {\n            overall_status,\n            individual_checks: results,\n            check_duration: duration,\n            timestamp: SystemTime::now(),\n        }\n    }\n    \n    async fn check_connectivity(&self) -> HealthCheckItem {\n        match self.hsm.get_info().await {\n            Ok(info) => HealthCheckItem {\n                name: "connectivity".to_string(),\n                status: CheckStatus::Healthy,\n                message: format!("HSM {} is reachable", info.label),\n                metric_value: Some(1.0),\n            },\n            Err(e) => HealthCheckItem {\n                name: "connectivity".to_string(),\n                status: CheckStatus::Critical,\n                message: format!("HSM unreachable: {}", e),\n                metric_value: Some(0.0),\n            }\n        }\n    }\n    \n    async fn check_performance(&self) -> HealthCheckItem {\n        // Perform a test signing operation to measure latency\n        let test_key = self.get_test_key().await;\n        let test_data = b"health check test data";\n        \n        let start = SystemTime::now();\n        let result = self.hsm.sign(&test_key, test_data).await;\n        let latency = SystemTime::now().duration_since(start).unwrap_or_default();\n        \n        let status = match result {\n            Ok(_) => {\n                if latency < Duration::from_millis(100) {\n                    CheckStatus::Healthy\n                } else if latency < Duration::from_millis(500) {\n                    CheckStatus::Warning\n                } else {\n                    CheckStatus::Critical\n                }\n            },\n            Err(_) => CheckStatus::Critical,\n        };\n        \n        HealthCheckItem {\n            name: "performance".to_string(),\n            status,\n            message: format!("Signing latency: {:?}", latency),\n            metric_value: Some(latency.as_millis() as f64),\n        }\n    }\n    \n    async fn check_fips_compliance(&self) -> HealthCheckItem {\n        // Check FIPS mode status\n        match self.hsm.get_fips_status().await {\n            Ok(fips_info) => {\n                if fips_info.fips_mode_enabled {\n                    HealthCheckItem {\n                        name: "fips_compliance".to_string(),\n                        status: CheckStatus::Healthy,\n                        message: format!("FIPS {} mode active", fips_info.level),\n                        metric_value: Some(1.0),\n                    }\n                } else {\n                    HealthCheckItem {\n                        name: "fips_compliance".to_string(),\n                        status: CheckStatus::Warning,\n                        message: "FIPS mode not enabled".to_string(),\n                        metric_value: Some(0.0),\n                    }\n                }\n            },\n            Err(e) => HealthCheckItem {\n                name: "fips_compliance".to_string(),\n                status: CheckStatus::Critical,\n                message: format!("Cannot determine FIPS status: {}", e),\n                metric_value: Some(0.0),\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"compliance-reporting",children:"Compliance Reporting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::compliance::*;\n\npub struct ComplianceManager {\n    hsm: Arc<dyn HSMBackend>,\n    audit_log: AuditLog,\n    compliance_framework: ComplianceFramework,\n}\n\n#[derive(Debug, Clone)]\npub enum ComplianceFramework {\n    FIPS140_2(FIPS140Level),\n    CommonCriteria(CCLevel),\n    PCI_DSS,\n    SOC2,\n    FISMA,\n}\n\n#[derive(Debug, Clone)]\npub enum FIPS140Level {\n    Level1,  // Software cryptographic module\n    Level2,  // Tamper-evident hardware\n    Level3,  // Tamper-resistant hardware\n    Level4,  // Complete protection envelope\n}\n\nimpl ComplianceManager {\n    pub async fn generate_compliance_report(&self) -> Result<ComplianceReport> {\n        let report_period_start = SystemTime::now() - Duration::from_days(30);\n        let report_period_end = SystemTime::now();\n        \n        // Collect audit events\n        let audit_events = self.audit_log.get_events_in_range(\n            report_period_start,\n            report_period_end\n        ).await?;\n        \n        // Analyze compliance metrics\n        let compliance_metrics = self.analyze_compliance_metrics(&audit_events)?;\n        \n        // Check for violations\n        let violations = self.detect_compliance_violations(&audit_events)?;\n        \n        // Generate recommendations\n        let recommendations = self.generate_compliance_recommendations(&violations)?;\n        \n        Ok(ComplianceReport {\n            framework: self.compliance_framework.clone(),\n            report_period: (report_period_start, report_period_end),\n            metrics: compliance_metrics,\n            violations: violations,\n            recommendations: recommendations,\n            hsm_info: self.hsm.get_info().await?,\n            generated_at: SystemTime::now(),\n        })\n    }\n    \n    fn analyze_compliance_metrics(&self, events: &[AuditEvent]) -> Result<ComplianceMetrics> {\n        let mut metrics = ComplianceMetrics::default();\n        \n        // Count different types of operations\n        for event in events {\n            match &event.event_type {\n                AuditEventType::KeyGeneration => metrics.key_generations += 1,\n                AuditEventType::CryptographicOperation(op) => {\n                    match op.operation_type {\n                        OperationType::Sign => metrics.signing_operations += 1,\n                        OperationType::Verify => metrics.verification_operations += 1,\n                        OperationType::Encrypt => metrics.encryption_operations += 1,\n                        OperationType::Decrypt => metrics.decryption_operations += 1,\n                    }\n                },\n                AuditEventType::KeyAccess => metrics.key_access_events += 1,\n                AuditEventType::SecurityViolation => metrics.security_violations += 1,\n                _ => {}\n            }\n            \n            // Track failed operations\n            if !event.success {\n                metrics.failed_operations += 1;\n            }\n        }\n        \n        // Calculate compliance scores\n        metrics.availability_score = self.calculate_availability_score(events)?;\n        metrics.integrity_score = self.calculate_integrity_score(events)?;\n        metrics.confidentiality_score = self.calculate_confidentiality_score(events)?;\n        \n        Ok(metrics)\n    }\n    \n    fn detect_compliance_violations(&self, events: &[AuditEvent]) -> Result<Vec<ComplianceViolation>> {\n        let mut violations = Vec::new();\n        \n        match &self.compliance_framework {\n            ComplianceFramework::FIPS140_2(level) => {\n                violations.extend(self.check_fips_140_violations(events, level)?);\n            },\n            ComplianceFramework::CommonCriteria(level) => {\n                violations.extend(self.check_cc_violations(events, level)?);\n            },\n            ComplianceFramework::PCI_DSS => {\n                violations.extend(self.check_pci_violations(events)?);\n            },\n            _ => {}\n        }\n        \n        Ok(violations)\n    }\n    \n    fn check_fips_140_violations(&self, events: &[AuditEvent], level: &FIPS140Level) -> Result<Vec<ComplianceViolation>> {\n        let mut violations = Vec::new();\n        \n        // Check for unapproved algorithms\n        for event in events {\n            if let AuditEventType::CryptographicOperation(op) = &event.event_type {\n                if !self.is_fips_approved_algorithm(&op.algorithm) {\n                    violations.push(ComplianceViolation {\n                        violation_type: ViolationType::UnapprovedAlgorithm,\n                        description: format!("Use of non-FIPS approved algorithm: {:?}", op.algorithm),\n                        severity: ViolationSeverity::High,\n                        timestamp: event.timestamp,\n                        remediation: "Replace with FIPS-approved algorithm".to_string(),\n                    });\n                }\n            }\n        }\n        \n        // Check for tamper detection (Level 2+)\n        if matches!(level, FIPS140Level::Level2 | FIPS140Level::Level3 | FIPS140Level::Level4) {\n            let tamper_events: Vec<_> = events.iter()\n                .filter(|e| matches!(e.event_type, AuditEventType::TamperDetection))\n                .collect();\n                \n            if tamper_events.is_empty() {\n                violations.push(ComplianceViolation {\n                    violation_type: ViolationType::MissingTamperDetection,\n                    description: "No tamper detection events logged".to_string(),\n                    severity: ViolationSeverity::Medium,\n                    timestamp: SystemTime::now(),\n                    remediation: "Verify tamper detection is functioning".to_string(),\n                });\n            }\n        }\n        \n        Ok(violations)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"enterprise-key-management",children:"Enterprise Key Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_hsm::enterprise::*;\n\npub struct EnterpriseKeyManager {\n    hsm_pool: HSMPool,\n    key_policies: PolicyManager,\n    compliance_manager: ComplianceManager,\n    backup_manager: BackupManager,\n}\n\nimpl EnterpriseKeyManager {\n    pub async fn generate_application_key(\n        &mut self,\n        app_id: &str,\n        key_policy: &KeyPolicy\n    ) -> Result<ApplicationKeyInfo> {\n        \n        // Validate policy compliance\n        self.key_policies.validate_policy(key_policy)?;\n        \n        // Select appropriate HSM based on policy requirements\n        let hsm = self.hsm_pool.select_hsm_for_policy(key_policy).await?;\n        \n        // Generate key according to policy\n        let key_spec = KeySpec {\n            key_id: format!("app-{}-{}", app_id, Uuid::new_v4()),\n            algorithm: key_policy.required_algorithm.clone(),\n            key_usage: key_policy.allowed_operations.clone(),\n            expiry_date: SystemTime::now() + key_policy.rotation_interval,\n        };\n        \n        let key_handle = hsm.generate_key_pair(&key_spec).await?;\n        \n        // Register key with enterprise registry\n        let app_key = ApplicationKeyInfo {\n            app_id: app_id.to_string(),\n            key_info: KeyInfo {\n                key_id: key_spec.key_id.clone(),\n                algorithm: key_spec.algorithm,\n                key_handle: key_handle.clone(),\n                version: 1,\n                created_at: SystemTime::now(),\n                status: KeyStatus::Active,\n                predecessor: None,\n                successor: None,\n                usage_count: 0,\n                last_used: None,\n                expires_at: key_spec.expiry_date,\n            },\n            policy: key_policy.clone(),\n            compliance_tags: self.generate_compliance_tags(&key_policy),\n        };\n        \n        self.register_application_key(&app_key).await?;\n        \n        // Schedule automatic rotation\n        self.schedule_key_rotation(&app_key.key_info.key_id, key_policy.rotation_interval).await?;\n        \n        // Create backup if required by policy\n        if key_policy.backup_required {\n            self.backup_manager.create_key_backup(&key_handle).await?;\n        }\n        \n        Ok(app_key)\n    }\n    \n    pub async fn sign_with_policy_enforcement(\n        &mut self,\n        app_id: &str,\n        data: &[u8],\n        context: &OperationContext\n    ) -> Result<SignatureResult> {\n        \n        // Get application key\n        let app_key = self.get_active_application_key(app_id).await?\n            .ok_or_else(|| HSMError::ApplicationKeyNotFound(app_id.to_string()))?;\n            \n        // Check policy compliance for this operation\n        self.key_policies.check_operation_allowed(&app_key.policy, context)?;\n        \n        // Check compliance requirements\n        self.compliance_manager.verify_operation_compliance(context).await?;\n        \n        // Perform the signing operation\n        let hsm = self.hsm_pool.get_hsm_for_key(&app_key.key_info.key_handle).await?;\n        let signature = hsm.sign(&app_key.key_info.key_handle, data).await?;\n        \n        // Record usage for compliance\n        self.record_key_usage(&app_key.key_info.key_id, context).await?;\n        \n        // Update usage statistics\n        self.update_key_usage_stats(&app_key.key_info.key_id).await?;\n        \n        Ok(SignatureResult {\n            signature,\n            key_id: app_key.key_info.key_id,\n            algorithm: app_key.key_info.algorithm,\n            timestamp: SystemTime::now(),\n            compliance_metadata: self.create_compliance_metadata(context),\n        })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/security/trust-networks",children:"Trust Networks"})," - HSM-backed trust relationships"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/security/keystore",children:"Keystore"})," - Mobile key management integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/security/post-quantum",children:"Post-Quantum Cryptography"})," - PQC algorithms in HSMs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/security/device-integrity",children:"Device Integrity"})," - Device attestation with HSMs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/architecture/formal-verification",children:"Formal Verification"})," - HSM protocol verification"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);