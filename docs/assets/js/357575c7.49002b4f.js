"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5509],{2531:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"integration/android","title":"Android Integration","description":"Integrate Olocus Protocol into Android applications using Kotlin or Java through JNI (Java Native Interface). This guide covers Android Keystore, Play Integrity API, and Location Services integration.","source":"@site/docs/integration/android.md","sourceDirName":"integration","slug":"/integration/android","permalink":"/docs/integration/android","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/integration/android.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":2,"frontMatter":{"id":"android","title":"Android Integration","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"iOS Integration","permalink":"/docs/integration/ios"},"next":{"title":"Web Integration","permalink":"/docs/integration/web"}}');var i=t(4848),r=t(8453);const o={id:"android",title:"Android Integration",sidebar_position:2},l="Android Integration",s={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation",id:"installation",level:2},{value:"Option 1: Pre-built AAR",id:"option-1-pre-built-aar",level:3},{value:"Option 2: Build from Source",id:"option-2-build-from-source",level:3},{value:"Kotlin Integration",id:"kotlin-integration",level:2},{value:"JNI Wrapper Class",id:"jni-wrapper-class",level:3},{value:"High-Level Kotlin Wrapper",id:"high-level-kotlin-wrapper",level:3},{value:"Android Keystore Integration",id:"android-keystore-integration",level:3},{value:"Play Integrity API Integration",id:"play-integrity-api-integration",level:3},{value:"Location Services Integration",id:"location-services-integration",level:3},{value:"Java Integration",id:"java-integration",level:2},{value:"Basic Java Wrapper",id:"basic-java-wrapper",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Background Processing",id:"background-processing",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Security",id:"security",level:3},{value:"Performance",id:"performance",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Tips",id:"debug-tips",level:3}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"android-integration",children:"Android Integration"})}),"\n",(0,i.jsx)(e.p,{children:"Integrate Olocus Protocol into Android applications using Kotlin or Java through JNI (Java Native Interface). This guide covers Android Keystore, Play Integrity API, and Location Services integration."}),"\n",(0,i.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Android Studio Arctic Fox or later"}),"\n",(0,i.jsx)(e.li,{children:"Android SDK API level 21+ (Android 5.0)"}),"\n",(0,i.jsx)(e.li,{children:"NDK r23c or later"}),"\n",(0,i.jsx)(e.li,{children:"Rust toolchain for building the native library"}),"\n",(0,i.jsx)(e.li,{children:"Kotlin 1.7+ or Java 8+"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(e.h3,{id:"option-1-pre-built-aar",children:"Option 1: Pre-built AAR"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Download the pre-built ",(0,i.jsx)(e.code,{children:"olocus-android.aar"})," from releases"]}),"\n",(0,i.jsxs)(e.li,{children:["Add to your ",(0,i.jsx)(e.code,{children:"app/libs/"})," directory"]}),"\n",(0,i.jsxs)(e.li,{children:["Add to your ",(0,i.jsx)(e.code,{children:"app/build.gradle"}),":"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-gradle",children:"android {\n    compileSdk 33\n    \n    defaultConfig {\n        minSdk 21\n        targetSdk 33\n    }\n    \n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n    implementation files('libs/olocus-android.aar')\n    implementation 'com.google.android.play:integrity:1.2.0'\n    implementation 'androidx.security:security-crypto:1.1.0-alpha06'\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"option-2-build-from-source",children:"Option 2: Build from Source"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Install Android targets for Rust:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'# Install targets\nrustup target add aarch64-linux-android\nrustup target add armv7-linux-androideabi\nrustup target add x86_64-linux-android\nrustup target add i686-linux-android\n\n# Set up NDK environment\nexport ANDROID_NDK_HOME="$ANDROID_HOME/ndk/25.1.8937393"\nexport PATH="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH"\n\n# Set up cargo config\nmkdir -p ~/.cargo\ncat > ~/.cargo/config.toml << EOF\n[target.aarch64-linux-android]\nar = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"\nlinker = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang"\n\n[target.armv7-linux-androideabi]\nar = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"\nlinker = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi21-clang"\n\n[target.x86_64-linux-android]\nar = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"\nlinker = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android21-clang"\n\n[target.i686-linux-android]\nar = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"\nlinker = "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android21-clang"\nEOF\n'})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:"Build for all Android architectures:"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"cd olocus-protocol\n\n# Build for each architecture\ncargo build -p olocus-ffi --release --target aarch64-linux-android\ncargo build -p olocus-ffi --release --target armv7-linux-androideabi\ncargo build -p olocus-ffi --release --target x86_64-linux-android\ncargo build -p olocus-ffi --release --target i686-linux-android\n\n# Copy libraries to Android project\nmkdir -p android/app/src/main/jniLibs/{arm64-v8a,armeabi-v7a,x86_64,x86}\ncp target/aarch64-linux-android/release/libolocus_ffi.so android/app/src/main/jniLibs/arm64-v8a/\ncp target/armv7-linux-androideabi/release/libolocus_ffi.so android/app/src/main/jniLibs/armeabi-v7a/\ncp target/x86_64-linux-android/release/libolocus_ffi.so android/app/src/main/jniLibs/x86_64/\ncp target/i686-linux-android/release/libolocus_ffi.so android/app/src/main/jniLibs/x86/\n"})}),"\n",(0,i.jsx)(e.h2,{id:"kotlin-integration",children:"Kotlin Integration"}),"\n",(0,i.jsx)(e.h3,{id:"jni-wrapper-class",children:"JNI Wrapper Class"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// OlocusFFI.kt\npackage com.yourapp.olocus\n\nimport java.nio.ByteBuffer\n\nclass OlocusFFI {\n    companion object {\n        init {\n            System.loadLibrary("olocus_ffi")\n        }\n        \n        // Library lifecycle\n        @JvmStatic external fun init(): Int\n        @JvmStatic external fun initWithConfig(config: Long): Int\n        @JvmStatic external fun shutdown(): Int\n        @JvmStatic external fun isInitialized(): Boolean\n        \n        // Configuration\n        @JvmStatic external fun configCreate(): Long\n        @JvmStatic external fun configDestroy(config: Long)\n        @JvmStatic external fun configSetAndroidKeystore(config: Long, enabled: Boolean)\n        @JvmStatic external fun configSetNetworkEnabled(config: Long, enabled: Boolean)\n        \n        // Key management\n        @JvmStatic external fun keypairGenerate(): Long\n        @JvmStatic external fun keypairFromBytes(privateKey: ByteArray): Long\n        @JvmStatic external fun keypairDestroy(keypair: Long)\n        @JvmStatic external fun keypairGetPublicKey(keypair: Long, publicKey: ByteArray)\n        @JvmStatic external fun keypairGetPrivateKey(keypair: Long, privateKey: ByteArray)\n        \n        // Block operations\n        @JvmStatic external fun blockCreateGenesis(\n            timestamp: Long,\n            payload: ByteArray,\n            payloadType: Int,\n            signingKey: ByteArray\n        ): Long\n        \n        @JvmStatic external fun blockCreate(\n            index: Long,\n            timestamp: Long,\n            previousHash: ByteArray,\n            payload: ByteArray,\n            payloadType: Int,\n            signingKey: ByteArray\n        ): Long\n        \n        @JvmStatic external fun blockDestroy(block: Long)\n        @JvmStatic external fun blockVerify(block: Long): Int\n        @JvmStatic external fun blockGetIndex(block: Long): Long\n        @JvmStatic external fun blockGetTimestamp(block: Long): Long\n        @JvmStatic external fun blockGetPayloadType(block: Long): Int\n        @JvmStatic external fun blockGetHash(block: Long, hash: ByteArray)\n        \n        // Chain operations\n        @JvmStatic external fun chainCreate(): Long\n        @JvmStatic external fun chainCreateWithLimit(limit: Long): Long\n        @JvmStatic external fun chainDestroy(chain: Long)\n        @JvmStatic external fun chainAddBlock(chain: Long, block: Long): Int\n        @JvmStatic external fun chainGetLength(chain: Long): Long\n        @JvmStatic external fun chainIsEmpty(chain: Long): Boolean\n        @JvmStatic external fun chainGetBlock(chain: Long, index: Long): Long\n        @JvmStatic external fun chainGetLastBlock(chain: Long): Long\n        @JvmStatic external fun chainVerify(chain: Long): Int\n        \n        // Wire format\n        @JvmStatic external fun wireFormatBinary(): ByteArray\n        @JvmStatic external fun wireFormatJson(): ByteArray\n        @JvmStatic external fun wireFormatMsgpack(): ByteArray\n        @JvmStatic external fun wireFormatNew(encoding: Int, compression: Int): ByteArray\n        @JvmStatic external fun blockToWireFormat(block: Long, format: ByteArray): ByteArray\n        @JvmStatic external fun blockFromWireFormat(data: ByteArray, format: ByteArray): Long\n        @JvmStatic external fun wireFormatContentType(format: ByteArray): String\n        @JvmStatic external fun wireFormatFromContentType(contentType: String): ByteArray?\n        \n        // Cryptographic operations\n        @JvmStatic external fun sign(keypair: Long, message: ByteArray, signature: ByteArray)\n        @JvmStatic external fun verify(\n            publicKey: ByteArray,\n            message: ByteArray,\n            signature: ByteArray\n        ): Int\n        @JvmStatic external fun hashSha256(data: ByteArray, hash: ByteArray)\n        @JvmStatic external fun randomBytes(buffer: ByteArray)\n        @JvmStatic external fun hkdfDerive(\n            inputKey: ByteArray,\n            salt: ByteArray,\n            info: ByteArray,\n            output: ByteArray\n        )\n        \n        // Error handling\n        @JvmStatic external fun getLastErrorCode(): Int\n        @JvmStatic external fun getLastErrorMessage(): String?\n        @JvmStatic external fun clearError()\n        \n        // Memory management\n        @JvmStatic external fun freeString(ptr: String)\n    }\n}\n\n// Wire format constants\nobject WireFormat {\n    const val ENCODING_BINARY = 0\n    const val ENCODING_JSON = 1\n    const val ENCODING_MESSAGEPACK = 2\n    const val ENCODING_PROTOBUF = 3\n    const val ENCODING_SSZ = 4\n    \n    const val COMPRESSION_NONE = 0\n    const val COMPRESSION_ZSTD = 1\n    const val COMPRESSION_LZ4 = 2\n    const val COMPRESSION_GZIP = 3\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"high-level-kotlin-wrapper",children:"High-Level Kotlin Wrapper"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// OlocusManager.kt\npackage com.yourapp.olocus\n\nimport android.content.Context\nimport android.util.Log\nimport kotlinx.coroutines.*\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.locks.ReentrantReadWriteLock\nimport kotlin.concurrent.read\nimport kotlin.concurrent.write\n\nclass OlocusManager private constructor(private val context: Context) {\n    companion object {\n        private const val TAG = "OlocusManager"\n        \n        @Volatile\n        private var INSTANCE: OlocusManager? = null\n        \n        fun getInstance(context: Context): OlocusManager {\n            return INSTANCE ?: synchronized(this) {\n                INSTANCE ?: OlocusManager(context.applicationContext).also { INSTANCE = it }\n            }\n        }\n    }\n    \n    private var isInitialized = false\n    private val chainLock = ReentrantReadWriteLock()\n    private var chain: Long? = null\n    private val keyManager = AndroidKeyManager(context)\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    \n    init {\n        initialize()\n    }\n    \n    private fun initialize() {\n        if (isInitialized) return\n        \n        val config = OlocusFFI.configCreate()\n        try {\n            OlocusFFI.configSetAndroidKeystore(config, true)\n            OlocusFFI.configSetNetworkEnabled(config, true)\n            \n            val result = OlocusFFI.initWithConfig(config)\n            if (result != 0) {\n                val error = OlocusFFI.getLastErrorMessage() ?: "Unknown error"\n                throw OlocusException("Failed to initialize Olocus: $error", result)\n            }\n            \n            chain = OlocusFFI.chainCreate()\n            isInitialized = true\n            \n            Log.i(TAG, "Olocus initialized successfully")\n        } finally {\n            OlocusFFI.configDestroy(config)\n        }\n    }\n    \n    fun createGenesisBlock(\n        payload: ByteArray,\n        payloadType: Int\n    ): Result<Block> = runCatching {\n        val signingKey = keyManager.getOrCreateSigningKey()\n        val timestamp = System.currentTimeMillis()\n        \n        val blockPtr = OlocusFFI.blockCreateGenesis(\n            timestamp,\n            payload,\n            payloadType,\n            signingKey\n        )\n        \n        if (blockPtr == 0L) {\n            val error = OlocusFFI.getLastErrorMessage() ?: "Block creation failed"\n            throw OlocusException(error, OlocusFFI.getLastErrorCode())\n        }\n        \n        Block(blockPtr)\n    }\n    \n    fun createBlock(\n        payload: ByteArray,\n        payloadType: Int\n    ): Result<Block> = runCatching {\n        chainLock.read {\n            val chainPtr = chain ?: throw OlocusException("Chain not initialized", -1)\n            \n            val length = OlocusFFI.chainGetLength(chainPtr)\n            val lastBlock = OlocusFFI.chainGetLastBlock(chainPtr)\n            \n            val previousHash = ByteArray(32)\n            OlocusFFI.blockGetHash(lastBlock, previousHash)\n            \n            val signingKey = keyManager.getOrCreateSigningKey()\n            val timestamp = System.currentTimeMillis()\n            \n            val blockPtr = OlocusFFI.blockCreate(\n                length,\n                timestamp,\n                previousHash,\n                payload,\n                payloadType,\n                signingKey\n            )\n            \n            if (blockPtr == 0L) {\n                val error = OlocusFFI.getLastErrorMessage() ?: "Block creation failed"\n                throw OlocusException(error, OlocusFFI.getLastErrorCode())\n            }\n            \n            Block(blockPtr)\n        }\n    }\n    \n    fun addBlock(block: Block): Result<Unit> = runCatching {\n        chainLock.write {\n            val chainPtr = chain ?: throw OlocusException("Chain not initialized", -1)\n            \n            val result = OlocusFFI.chainAddBlock(chainPtr, block.ptr)\n            if (result != 0) {\n                val error = OlocusFFI.getLastErrorMessage() ?: "Failed to add block"\n                throw OlocusException(error, result)\n            }\n        }\n    }\n    \n    suspend fun addBlockAsync(block: Block): Result<Unit> = withContext(Dispatchers.IO) {\n        addBlock(block)\n    }\n    \n    fun verifyChain(): Result<Boolean> = runCatching {\n        chainLock.read {\n            val chainPtr = chain ?: throw OlocusException("Chain not initialized", -1)\n            \n            val result = OlocusFFI.chainVerify(chainPtr)\n            result == 0\n        }\n    }\n    \n    fun getChainLength(): Long {\n        return chainLock.read {\n            val chainPtr = chain ?: 0L\n            OlocusFFI.chainGetLength(chainPtr)\n        }\n    }\n    \n    fun exportChain(format: WireFormatType = WireFormatType.JSON): Result<ByteArray> = runCatching {\n        chainLock.read {\n            val chainPtr = chain ?: throw OlocusException("Chain not initialized", -1)\n            \n            val wireFormat = when (format) {\n                WireFormatType.BINARY -> OlocusFFI.wireFormatBinary()\n                WireFormatType.JSON -> OlocusFFI.wireFormatJson()\n                WireFormatType.MESSAGEPACK -> OlocusFFI.wireFormatMsgpack()\n                WireFormatType.JSON_COMPRESSED -> OlocusFFI.wireFormatNew(\n                    WireFormat.ENCODING_JSON,\n                    WireFormat.COMPRESSION_ZSTD\n                )\n            }\n            \n            // For chain export, we need to serialize each block\n            val length = OlocusFFI.chainGetLength(chainPtr)\n            val blocks = mutableListOf<ByteArray>()\n            \n            for (i in 0 until length) {\n                val blockPtr = OlocusFFI.chainGetBlock(chainPtr, i)\n                val blockData = OlocusFFI.blockToWireFormat(blockPtr, wireFormat)\n                blocks.add(blockData)\n            }\n            \n            // Combine blocks into chain format\n            serializeChain(blocks)\n        }\n    }\n    \n    private fun serializeChain(blocks: List<ByteArray>): ByteArray {\n        // Simple concatenation with length prefixes\n        val totalSize = blocks.sumOf { it.size + 4 } + 4 // 4 bytes for count + 4 bytes per length\n        val buffer = ByteArray(totalSize)\n        var offset = 0\n        \n        // Write block count\n        writeInt(buffer, offset, blocks.size)\n        offset += 4\n        \n        // Write each block with length prefix\n        for (block in blocks) {\n            writeInt(buffer, offset, block.size)\n            offset += 4\n            block.copyInto(buffer, offset)\n            offset += block.size\n        }\n        \n        return buffer\n    }\n    \n    private fun writeInt(buffer: ByteArray, offset: Int, value: Int) {\n        buffer[offset] = (value shr 24).toByte()\n        buffer[offset + 1] = (value shr 16).toByte()\n        buffer[offset + 2] = (value shr 8).toByte()\n        buffer[offset + 3] = value.toByte()\n    }\n    \n    fun cleanup() {\n        scope.cancel()\n        chainLock.write {\n            chain?.let {\n                OlocusFFI.chainDestroy(it)\n                chain = null\n            }\n        }\n        if (isInitialized) {\n            OlocusFFI.shutdown()\n            isInitialized = false\n        }\n    }\n}\n\n// Data classes\ndata class Block(val ptr: Long) {\n    fun getIndex(): Long = OlocusFFI.blockGetIndex(ptr)\n    fun getTimestamp(): Long = OlocusFFI.blockGetTimestamp(ptr)\n    fun getPayloadType(): Int = OlocusFFI.blockGetPayloadType(ptr)\n    \n    fun getHash(): ByteArray {\n        val hash = ByteArray(32)\n        OlocusFFI.blockGetHash(ptr, hash)\n        return hash\n    }\n    \n    fun verify(): Boolean = OlocusFFI.blockVerify(ptr) == 0\n    \n    fun toWireFormat(format: WireFormatType = WireFormatType.JSON): ByteArray {\n        val wireFormat = when (format) {\n            WireFormatType.BINARY -> OlocusFFI.wireFormatBinary()\n            WireFormatType.JSON -> OlocusFFI.wireFormatJson()\n            WireFormatType.MESSAGEPACK -> OlocusFFI.wireFormatMsgpack()\n            WireFormatType.JSON_COMPRESSED -> OlocusFFI.wireFormatNew(\n                WireFormat.ENCODING_JSON,\n                WireFormat.COMPRESSION_ZSTD\n            )\n        }\n        return OlocusFFI.blockToWireFormat(ptr, wireFormat)\n    }\n    \n    protected fun finalize() {\n        OlocusFFI.blockDestroy(ptr)\n    }\n}\n\nenum class WireFormatType {\n    BINARY, JSON, MESSAGEPACK, JSON_COMPRESSED\n}\n\nclass OlocusException(message: String, val errorCode: Int) : Exception(message)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"android-keystore-integration",children:"Android Keystore Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// AndroidKeyManager.kt\npackage com.yourapp.olocus\n\nimport android.content.Context\nimport android.security.keystore.KeyGenParameterSpec\nimport android.security.keystore.KeyProperties\nimport androidx.security.crypto.EncryptedSharedPreferences\nimport androidx.security.crypto.MasterKeys\nimport java.security.KeyStore\nimport java.security.SecureRandom\nimport javax.crypto.Cipher\nimport javax.crypto.KeyGenerator\nimport javax.crypto.SecretKey\nimport javax.crypto.spec.GCMParameterSpec\nimport javax.crypto.spec.SecretKeySpec\n\nclass AndroidKeyManager(private val context: Context) {\n    companion object {\n        private const val ANDROID_KEYSTORE = "AndroidKeyStore"\n        private const val OLOCUS_KEY_ALIAS = "olocus_signing_key"\n        private const val ENCRYPTED_PREFS_NAME = "olocus_secure_prefs"\n        private const val SIGNING_KEY_PREF = "encrypted_signing_key"\n        private const val TRANSFORMATION = "AES/GCM/NoPadding"\n        private const val IV_LENGTH = 12\n        private const val TAG_LENGTH = 16\n    }\n    \n    private val keyStore = KeyStore.getInstance(ANDROID_KEYSTORE).apply { load(null) }\n    private val masterKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)\n    \n    private val encryptedPrefs = EncryptedSharedPreferences.create(\n        ENCRYPTED_PREFS_NAME,\n        masterKeyAlias,\n        context,\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n    )\n    \n    fun getOrCreateSigningKey(): ByteArray {\n        // First try to load existing key\n        loadSigningKey()?.let { return it }\n        \n        // Generate new key if none exists\n        return generateAndStoreSigningKey()\n    }\n    \n    private fun loadSigningKey(): ByteArray? {\n        val encryptedKey = encryptedPrefs.getString(SIGNING_KEY_PREF, null) ?: return null\n        \n        return try {\n            val encryptedData = android.util.Base64.decode(encryptedKey, android.util.Base64.DEFAULT)\n            decryptSigningKey(encryptedData)\n        } catch (e: Exception) {\n            Log.w("AndroidKeyManager", "Failed to load existing key, generating new one", e)\n            null\n        }\n    }\n    \n    private fun generateAndStoreSigningKey(): ByteArray {\n        // Generate Ed25519-compatible key (32 random bytes)\n        val signingKey = ByteArray(32)\n        SecureRandom().nextBytes(signingKey)\n        \n        try {\n            // Encrypt and store the key\n            val encryptedKey = encryptSigningKey(signingKey)\n            val encodedKey = android.util.Base64.encodeToString(encryptedKey, android.util.Base64.DEFAULT)\n            \n            encryptedPrefs.edit()\n                .putString(SIGNING_KEY_PREF, encodedKey)\n                .apply()\n            \n            return signingKey\n        } catch (e: Exception) {\n            throw KeyManagerException("Failed to store signing key", e)\n        }\n    }\n    \n    private fun encryptSigningKey(key: ByteArray): ByteArray {\n        // Generate or get the encryption key from Android Keystore\n        val secretKey = getOrCreateEncryptionKey()\n        \n        val cipher = Cipher.getInstance(TRANSFORMATION)\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey)\n        \n        val iv = cipher.iv\n        val encryptedKey = cipher.doFinal(key)\n        \n        // Combine IV and encrypted data\n        return iv + encryptedKey\n    }\n    \n    private fun decryptSigningKey(encryptedData: ByteArray): ByteArray {\n        if (encryptedData.size < IV_LENGTH + TAG_LENGTH) {\n            throw KeyManagerException("Encrypted data too short")\n        }\n        \n        val secretKey = getOrCreateEncryptionKey()\n        val iv = encryptedData.sliceArray(0 until IV_LENGTH)\n        val cipherText = encryptedData.sliceArray(IV_LENGTH until encryptedData.size)\n        \n        val cipher = Cipher.getInstance(TRANSFORMATION)\n        val spec = GCMParameterSpec(TAG_LENGTH * 8, iv)\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)\n        \n        return cipher.doFinal(cipherText)\n    }\n    \n    private fun getOrCreateEncryptionKey(): SecretKey {\n        return if (keyStore.containsAlias(OLOCUS_KEY_ALIAS)) {\n            keyStore.getKey(OLOCUS_KEY_ALIAS, null) as SecretKey\n        } else {\n            createEncryptionKey()\n        }\n    }\n    \n    private fun createEncryptionKey(): SecretKey {\n        val keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEYSTORE)\n        \n        val keyGenParameterSpec = KeyGenParameterSpec.Builder(\n            OLOCUS_KEY_ALIAS,\n            KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT\n        )\n            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n            .setUserAuthenticationRequired(false) // Set to true if you want biometric auth\n            .setRandomizedEncryptionRequired(true)\n            .build()\n        \n        keyGenerator.init(keyGenParameterSpec)\n        return keyGenerator.generateKey()\n    }\n    \n    fun signWithBiometrics(\n        data: ByteArray,\n        onSuccess: (ByteArray) -> Unit,\n        onError: (Exception) -> Unit\n    ) {\n        // For biometric signing, you would:\n        // 1. Set setUserAuthenticationRequired(true) when creating the key\n        // 2. Use BiometricPrompt to authenticate\n        // 3. Perform the signing operation within the authentication callback\n        \n        try {\n            val signingKey = getOrCreateSigningKey()\n            val signature = signData(data, signingKey)\n            onSuccess(signature)\n        } catch (e: Exception) {\n            onError(e)\n        }\n    }\n    \n    private fun signData(data: ByteArray, signingKey: ByteArray): ByteArray {\n        val keypair = OlocusFFI.keypairFromBytes(signingKey)\n        try {\n            val signature = ByteArray(64)\n            OlocusFFI.sign(keypair, data, signature)\n            return signature\n        } finally {\n            OlocusFFI.keypairDestroy(keypair)\n        }\n    }\n    \n    fun deleteSigningKey() {\n        try {\n            if (keyStore.containsAlias(OLOCUS_KEY_ALIAS)) {\n                keyStore.deleteEntry(OLOCUS_KEY_ALIAS)\n            }\n            encryptedPrefs.edit().remove(SIGNING_KEY_PREF).apply()\n        } catch (e: Exception) {\n            throw KeyManagerException("Failed to delete signing key", e)\n        }\n    }\n}\n\nclass KeyManagerException(message: String, cause: Throwable? = null) : Exception(message, cause)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"play-integrity-api-integration",children:"Play Integrity API Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// PlayIntegrityManager.kt\npackage com.yourapp.olocus\n\nimport android.content.Context\nimport com.google.android.play.core.integrity.IntegrityManager\nimport com.google.android.play.core.integrity.IntegrityManagerFactory\nimport com.google.android.play.core.integrity.model.IntegrityErrorCode\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport java.security.MessageDigest\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.resumeWithException\n\nclass PlayIntegrityManager(private val context: Context) {\n    private val integrityManager: IntegrityManager = IntegrityManagerFactory.create(context)\n    \n    suspend fun generateIntegrityBlock(nonce: String? = null): Result<Block> = runCatching {\n        // Generate nonce if not provided\n        val requestNonce = nonce ?: generateNonce()\n        \n        // Request integrity token\n        val integrityToken = requestIntegrityToken(requestNonce)\n        \n        // Create payload with integrity data\n        val payload = IntegrityPayload(\n            token = integrityToken,\n            nonce = requestNonce,\n            packageName = context.packageName,\n            timestamp = System.currentTimeMillis()\n        )\n        \n        // Create Olocus block\n        createIntegrityBlock(payload)\n    }\n    \n    private suspend fun requestIntegrityToken(nonce: String): String {\n        return suspendCancellableCoroutine { continuation ->\n            integrityManager\n                .requestIntegrityToken(\n                    com.google.android.play.core.integrity.IntegrityTokenRequest.builder()\n                        .setNonce(nonce)\n                        .build()\n                )\n                .addOnSuccessListener { response ->\n                    continuation.resume(response.token())\n                }\n                .addOnFailureListener { exception ->\n                    continuation.resumeWithException(\n                        IntegrityException("Integrity request failed", exception)\n                    )\n                }\n        }\n    }\n    \n    private fun generateNonce(): String {\n        val randomBytes = ByteArray(32)\n        OlocusFFI.randomBytes(randomBytes)\n        return android.util.Base64.encodeToString(randomBytes, android.util.Base64.URL_SAFE or android.util.Base64.NO_WRAP)\n    }\n    \n    private fun createIntegrityBlock(payload: IntegrityPayload): Block {\n        val olocusManager = OlocusManager.getInstance(context)\n        val payloadJson = kotlinx.serialization.json.Json.encodeToString(\n            IntegrityPayload.serializer(),\n            payload\n        )\n        \n        return olocusManager.createGenesisBlock(\n            payloadJson.toByteArray(),\n            0x0401 // Play Integrity payload type\n        ).getOrThrow()\n    }\n    \n    fun verifyIntegrityToken(token: String): Result<IntegrityVerificationResult> = runCatching {\n        // Parse the JWT token (simplified)\n        val parts = token.split(".")\n        if (parts.size != 3) {\n            throw IntegrityException("Invalid token format")\n        }\n        \n        val header = parseJwtPart(parts[0])\n        val payload = parseJwtPart(parts[1])\n        val signature = parts[2]\n        \n        // In a real implementation, you would:\n        // 1. Verify the JWT signature using Google\'s public keys\n        // 2. Check the token\'s validity period\n        // 3. Verify the nonce matches\n        // 4. Check app integrity verdict\n        \n        IntegrityVerificationResult(\n            isValid = true, // Placeholder\n            appIntegrity = payload["appIntegrity"] as? Map<String, Any>,\n            deviceIntegrity = payload["deviceIntegrity"] as? Map<String, Any>,\n            accountDetails = payload["accountDetails"] as? Map<String, Any>\n        )\n    }\n    \n    private fun parseJwtPart(part: String): Map<String, Any> {\n        val decoded = android.util.Base64.decode(part, android.util.Base64.URL_SAFE)\n        val json = String(decoded)\n        return kotlinx.serialization.json.Json.parseToJsonElement(json).jsonObject.toMap()\n    }\n}\n\n@kotlinx.serialization.Serializable\ndata class IntegrityPayload(\n    val token: String,\n    val nonce: String,\n    val packageName: String,\n    val timestamp: Long\n)\n\ndata class IntegrityVerificationResult(\n    val isValid: Boolean,\n    val appIntegrity: Map<String, Any>?,\n    val deviceIntegrity: Map<String, Any>?,\n    val accountDetails: Map<String, Any>?\n)\n\nclass IntegrityException(message: String, cause: Throwable? = null) : Exception(message, cause)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"location-services-integration",children:"Location Services Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// LocationChainManager.kt\npackage com.yourapp.olocus\n\nimport android.Manifest\nimport android.content.Context\nimport android.content.pm.PackageManager\nimport android.location.Location\nimport android.os.Looper\nimport androidx.core.content.ContextCompat\nimport com.google.android.gms.location.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.asSharedFlow\n\nclass LocationChainManager(private val context: Context) {\n    companion object {\n        private const val LOCATION_UPDATE_INTERVAL = 30_000L // 30 seconds\n        private const val LOCATION_FASTEST_INTERVAL = 10_000L // 10 seconds\n        private const val MIN_DISPLACEMENT = 10f // 10 meters\n    }\n    \n    private val fusedLocationClient: FusedLocationProviderClient =\n        LocationServices.getFusedLocationProviderClient(context)\n    \n    private val olocusManager = OlocusManager.getInstance(context)\n    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    \n    private val _locationBlocks = MutableSharedFlow<Block>()\n    val locationBlocks: SharedFlow<Block> = _locationBlocks.asSharedFlow()\n    \n    private val _locationErrors = MutableSharedFlow<LocationException>()\n    val locationErrors: SharedFlow<LocationException> = _locationErrors.asSharedFlow()\n    \n    private var locationCallback: LocationCallback? = null\n    private var isTracking = false\n    \n    fun startLocationTracking(): Result<Unit> = runCatching {\n        if (!hasLocationPermissions()) {\n            throw LocationException("Location permissions not granted")\n        }\n        \n        if (isTracking) {\n            return@runCatching\n        }\n        \n        val locationRequest = LocationRequest.Builder(\n            Priority.PRIORITY_HIGH_ACCURACY,\n            LOCATION_UPDATE_INTERVAL\n        )\n            .setMinUpdateIntervalMillis(LOCATION_FASTEST_INTERVAL)\n            .setMinUpdateDistanceMeters(MIN_DISPLACEMENT)\n            .build()\n        \n        locationCallback = object : LocationCallback() {\n            override fun onLocationResult(locationResult: LocationResult) {\n                locationResult.locations.forEach { location ->\n                    scope.launch {\n                        processLocation(location)\n                    }\n                }\n            }\n            \n            override fun onLocationAvailability(locationAvailability: LocationAvailability) {\n                if (!locationAvailability.isLocationAvailable) {\n                    scope.launch {\n                        _locationErrors.emit(\n                            LocationException("Location not available")\n                        )\n                    }\n                }\n            }\n        }\n        \n        fusedLocationClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback!!,\n            Looper.getMainLooper()\n        )\n        \n        isTracking = true\n    }\n    \n    fun stopLocationTracking() {\n        if (!isTracking) return\n        \n        locationCallback?.let {\n            fusedLocationClient.removeLocationUpdates(it)\n        }\n        locationCallback = null\n        isTracking = false\n    }\n    \n    private suspend fun processLocation(location: Location) {\n        try {\n            val locationBlock = createLocationBlock(location)\n            olocusManager.addBlockAsync(locationBlock).getOrThrow()\n            _locationBlocks.emit(locationBlock)\n        } catch (e: Exception) {\n            _locationErrors.emit(LocationException("Failed to process location", e))\n        }\n    }\n    \n    private fun createLocationBlock(location: Location): Block {\n        val payload = LocationPayload(\n            latitude = location.latitude,\n            longitude = location.longitude,\n            altitude = location.altitude,\n            accuracy = location.accuracy,\n            bearing = location.bearing,\n            speed = location.speed,\n            timestamp = location.time,\n            provider = location.provider ?: "unknown",\n            isMock = location.isFromMockProvider\n        )\n        \n        val payloadJson = kotlinx.serialization.json.Json.encodeToString(\n            LocationPayload.serializer(),\n            payload\n        )\n        \n        return if (olocusManager.getChainLength() == 0L) {\n            olocusManager.createGenesisBlock(\n                payloadJson.toByteArray(),\n                0x0200 // Location payload type\n            ).getOrThrow()\n        } else {\n            olocusManager.createBlock(\n                payloadJson.toByteArray(),\n                0x0200\n            ).getOrThrow()\n        }\n    }\n    \n    fun getLocationHistory(): Result<List<LocationPayload>> = runCatching {\n        val chainLength = olocusManager.getChainLength()\n        val locations = mutableListOf<LocationPayload>()\n        \n        // This is a simplified version - in practice you\'d use the query extension\n        // to efficiently filter location blocks\n        \n        for (i in 0 until chainLength) {\n            // Get block and parse if it\'s a location block\n            // Implementation depends on how you store chain access\n        }\n        \n        locations\n    }\n    \n    fun getCurrentLocation(): Result<Location> = runCatching {\n        if (!hasLocationPermissions()) {\n            throw LocationException("Location permissions not granted")\n        }\n        \n        // This would need to be made suspend and use coroutines\n        // Simplified synchronous version for demo\n        throw NotImplementedError("Use getCurrentLocationAsync() instead")\n    }\n    \n    suspend fun getCurrentLocationAsync(): Result<Location> = suspendCancellableCoroutine { continuation ->\n        if (!hasLocationPermissions()) {\n            continuation.resume(Result.failure(LocationException("Location permissions not granted")))\n            return@suspendCancellableCoroutine\n        }\n        \n        fusedLocationClient.getCurrentLocation(\n            Priority.PRIORITY_HIGH_ACCURACY,\n            null\n        ).addOnSuccessListener { location ->\n            if (location != null) {\n                continuation.resume(Result.success(location))\n            } else {\n                continuation.resume(Result.failure(LocationException("Location is null")))\n            }\n        }.addOnFailureListener { exception ->\n            continuation.resume(Result.failure(LocationException("Failed to get location", exception)))\n        }\n    }\n    \n    private fun hasLocationPermissions(): Boolean {\n        return ContextCompat.checkSelfPermission(\n            context,\n            Manifest.permission.ACCESS_FINE_LOCATION\n        ) == PackageManager.PERMISSION_GRANTED ||\n                ContextCompat.checkSelfPermission(\n                    context,\n                    Manifest.permission.ACCESS_COARSE_LOCATION\n                ) == PackageManager.PERMISSION_GRANTED\n    }\n    \n    fun cleanup() {\n        stopLocationTracking()\n        scope.cancel()\n    }\n}\n\n@kotlinx.serialization.Serializable\ndata class LocationPayload(\n    val latitude: Double,\n    val longitude: Double,\n    val altitude: Double,\n    val accuracy: Float,\n    val bearing: Float,\n    val speed: Float,\n    val timestamp: Long,\n    val provider: String,\n    val isMock: Boolean\n)\n\nclass LocationException(message: String, cause: Throwable? = null) : Exception(message, cause)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"java-integration",children:"Java Integration"}),"\n",(0,i.jsx)(e.h3,{id:"basic-java-wrapper",children:"Basic Java Wrapper"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// OlocusManagerJava.java\npackage com.yourapp.olocus;\n\nimport android.content.Context;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class OlocusManagerJava {\n    private static OlocusManagerJava instance;\n    private final ExecutorService executor;\n    private final Context context;\n    private boolean isInitialized = false;\n    private long chainPtr = 0;\n    private AndroidKeyManagerJava keyManager;\n    \n    private OlocusManagerJava(Context context) {\n        this.context = context.getApplicationContext();\n        this.executor = Executors.newSingleThreadExecutor();\n        this.keyManager = new AndroidKeyManagerJava(context);\n        initialize();\n    }\n    \n    public static synchronized OlocusManagerJava getInstance(Context context) {\n        if (instance == null) {\n            instance = new OlocusManagerJava(context);\n        }\n        return instance;\n    }\n    \n    private void initialize() {\n        long config = OlocusFFI.configCreate();\n        try {\n            OlocusFFI.configSetAndroidKeystore(config, true);\n            int result = OlocusFFI.initWithConfig(config);\n            if (result != 0) {\n                throw new OlocusException("Failed to initialize Olocus: " + \n                    OlocusFFI.getLastErrorMessage(), result);\n            }\n            \n            chainPtr = OlocusFFI.chainCreate();\n            isInitialized = true;\n        } finally {\n            OlocusFFI.configDestroy(config);\n        }\n    }\n    \n    public CompletableFuture<BlockJava> createGenesisBlockAsync(\n            byte[] payload, int payloadType) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                byte[] signingKey = keyManager.getOrCreateSigningKey();\n                long timestamp = System.currentTimeMillis();\n                \n                long blockPtr = OlocusFFI.blockCreateGenesis(\n                    timestamp, payload, payloadType, signingKey);\n                    \n                if (blockPtr == 0) {\n                    throw new OlocusException(\n                        OlocusFFI.getLastErrorMessage(),\n                        OlocusFFI.getLastErrorCode());\n                }\n                \n                return new BlockJava(blockPtr);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }, executor);\n    }\n    \n    public CompletableFuture<Void> addBlockAsync(BlockJava block) {\n        return CompletableFuture.runAsync(() -> {\n            synchronized (this) {\n                int result = OlocusFFI.chainAddBlock(chainPtr, block.getPtr());\n                if (result != 0) {\n                    throw new RuntimeException(new OlocusException(\n                        OlocusFFI.getLastErrorMessage(), result));\n                }\n            }\n        }, executor);\n    }\n    \n    public synchronized long getChainLength() {\n        return OlocusFFI.chainGetLength(chainPtr);\n    }\n    \n    public byte[] exportChain() {\n        byte[] wireFormat = OlocusFFI.wireFormatJson();\n        // Implementation for chain export\n        return new byte[0]; // Placeholder\n    }\n    \n    public void cleanup() {\n        executor.shutdown();\n        synchronized (this) {\n            if (chainPtr != 0) {\n                OlocusFFI.chainDestroy(chainPtr);\n                chainPtr = 0;\n            }\n        }\n        if (isInitialized) {\n            OlocusFFI.shutdown();\n            isInitialized = false;\n        }\n    }\n}\n\n// BlockJava.java\npackage com.yourapp.olocus;\n\npublic class BlockJava {\n    private final long ptr;\n    \n    public BlockJava(long ptr) {\n        this.ptr = ptr;\n    }\n    \n    public long getPtr() {\n        return ptr;\n    }\n    \n    public long getIndex() {\n        return OlocusFFI.blockGetIndex(ptr);\n    }\n    \n    public long getTimestamp() {\n        return OlocusFFI.blockGetTimestamp(ptr);\n    }\n    \n    public int getPayloadType() {\n        return OlocusFFI.blockGetPayloadType(ptr);\n    }\n    \n    public byte[] getHash() {\n        byte[] hash = new byte[32];\n        OlocusFFI.blockGetHash(ptr, hash);\n        return hash;\n    }\n    \n    public boolean verify() {\n        return OlocusFFI.blockVerify(ptr) == 0;\n    }\n    \n    @Override\n    protected void finalize() {\n        OlocusFFI.blockDestroy(ptr);\n    }\n}\n\n// OlocusException.java\npackage com.yourapp.olocus;\n\npublic class OlocusException extends Exception {\n    private final int errorCode;\n    \n    public OlocusException(String message, int errorCode) {\n        super(message);\n        this.errorCode = errorCode;\n    }\n    \n    public int getErrorCode() {\n        return errorCode;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"background-processing",children:"Background Processing"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'class PerformanceOptimizedManager(context: Context) {\n    private val backgroundDispatcher = Dispatchers.IO.limitedParallelism(2)\n    private val computationDispatcher = Dispatchers.Default\n    \n    // Batch process multiple blocks\n    suspend fun addBlocksBatch(blocks: List<Block>): Result<Unit> = withContext(backgroundDispatcher) {\n        runCatching {\n            for (block in blocks) {\n                val result = OlocusFFI.chainAddBlock(chainPtr, block.ptr)\n                if (result != 0) {\n                    throw OlocusException(OlocusFFI.getLastErrorMessage() ?: "Unknown error", result)\n                }\n            }\n        }\n    }\n    \n    // Parallel verification\n    suspend fun verifyBlocksParallel(blocks: List<Block>): List<Boolean> = withContext(computationDispatcher) {\n        blocks.map { block ->\n            async {\n                OlocusFFI.blockVerify(block.ptr) == 0\n            }\n        }.awaitAll()\n    }\n    \n    // Memory-efficient chain export\n    suspend fun exportChainStreaming(): Flow<ByteArray> = flow {\n        val length = OlocusFFI.chainGetLength(chainPtr)\n        val wireFormat = OlocusFFI.wireFormatNew(WireFormat.ENCODING_JSON, WireFormat.COMPRESSION_ZSTD)\n        \n        for (i in 0 until length) {\n            val blockPtr = OlocusFFI.chainGetBlock(chainPtr, i)\n            val blockData = OlocusFFI.blockToWireFormat(blockPtr, wireFormat)\n            emit(blockData)\n        }\n    }.flowOn(backgroundDispatcher)\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"testing",children:"Testing"}),"\n",(0,i.jsx)(e.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// OlocusManagerTest.kt\nimport androidx.test.platform.app.InstrumentationRegistry\nimport androidx.test.ext.junit.runners.AndroidJUnit4\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.junit.Assert.*\nimport org.junit.Before\nimport org.junit.After\n\n@RunWith(AndroidJUnit4::class)\nclass OlocusManagerTest {\n    private lateinit var context: Context\n    private lateinit var olocusManager: OlocusManager\n    \n    @Before\n    fun setup() {\n        context = InstrumentationRegistry.getInstrumentation().targetContext\n        olocusManager = OlocusManager.getInstance(context)\n    }\n    \n    @After\n    fun tearDown() {\n        olocusManager.cleanup()\n    }\n    \n    @Test\n    fun testInitialization() {\n        assertTrue("Olocus should be initialized", olocusManager.isInitialized)\n    }\n    \n    @Test\n    fun testGenesisBlockCreation() {\n        val payload = "Test payload".toByteArray()\n        val result = olocusManager.createGenesisBlock(payload, 0)\n        \n        assertTrue("Genesis block creation should succeed", result.isSuccess)\n        val block = result.getOrThrow()\n        assertEquals("Genesis block index should be 0", 0L, block.getIndex())\n        assertTrue("Genesis block should be valid", block.verify())\n    }\n    \n    @Test\n    fun testChainBuilding() {\n        // Create genesis block\n        val genesisPayload = "Genesis".toByteArray()\n        val genesisResult = olocusManager.createGenesisBlock(genesisPayload, 0)\n        assertTrue(genesisResult.isSuccess)\n        val genesis = genesisResult.getOrThrow()\n        \n        // Add to chain\n        val addResult = olocusManager.addBlock(genesis)\n        assertTrue(addResult.isSuccess)\n        assertEquals(1L, olocusManager.getChainLength())\n        \n        // Create second block\n        val secondPayload = "Second block".toByteArray()\n        val secondResult = olocusManager.createBlock(secondPayload, 0)\n        assertTrue(secondResult.isSuccess)\n        val second = secondResult.getOrThrow()\n        \n        // Add second block\n        val addSecondResult = olocusManager.addBlock(second)\n        assertTrue(addSecondResult.isSuccess)\n        assertEquals(2L, olocusManager.getChainLength())\n    }\n    \n    @Test\n    fun testWireFormatSerialization() {\n        val payload = "Test payload".toByteArray()\n        val block = olocusManager.createGenesisBlock(payload, 0).getOrThrow()\n        \n        // Test different formats\n        val jsonData = block.toWireFormat(WireFormatType.JSON)\n        val binaryData = block.toWireFormat(WireFormatType.BINARY)\n        val msgpackData = block.toWireFormat(WireFormatType.MESSAGEPACK)\n        \n        assertTrue("JSON data should not be empty", jsonData.isNotEmpty())\n        assertTrue("Binary data should not be empty", binaryData.isNotEmpty())\n        assertTrue("MessagePack data should not be empty", msgpackData.isNotEmpty())\n        \n        // JSON should be larger than binary for small payloads\n        assertTrue("JSON should be larger than binary", jsonData.size > binaryData.size)\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-kotlin",children:'// LocationIntegrationTest.kt\n@RunWith(AndroidJUnit4::class)\nclass LocationIntegrationTest {\n    private lateinit var locationManager: LocationChainManager\n    private lateinit var context: Context\n    \n    @Before\n    fun setup() {\n        context = InstrumentationRegistry.getInstrumentation().targetContext\n        locationManager = LocationChainManager(context)\n    }\n    \n    @After\n    fun tearDown() {\n        locationManager.cleanup()\n    }\n    \n    @Test\n    fun testLocationBlockCreation() {\n        // This test would require location permissions and mock location provider\n        // Simplified for demonstration\n        \n        val mockLocation = createMockLocation()\n        // Test location block creation logic\n    }\n    \n    private fun createMockLocation(): Location {\n        return Location("test").apply {\n            latitude = 37.7749\n            longitude = -122.4194\n            altitude = 100.0\n            accuracy = 5.0f\n            time = System.currentTimeMillis()\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"security",children:"Security"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Always use Android Keystore"})," for key management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Validate all JNI inputs"})," before passing to native code"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use Play Integrity API"})," for app integrity verification"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement certificate pinning"})," for network communications"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Clear sensitive data"})," from memory after use"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use background threads"})," for heavy operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement proper caching"})," for frequently accessed data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use efficient serialization"})," formats (MessagePack vs JSON)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitor memory usage"})," and implement proper cleanup"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Batch operations"})," when possible"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Always check JNI return codes"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Provide user-friendly error messages"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement retry mechanisms"})," for transient failures"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Log errors"})," for debugging but avoid sensitive data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Handle network failures"})," gracefully"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"UnsatisfiedLinkError"}),": Ensure native library is in correct ABI directory"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Keystore access errors"}),": Check Android version compatibility and permissions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Location permission denied"}),": Request runtime permissions properly"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Play Integrity unavailable"}),": Verify Google Play Services version"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory leaks"}),": Use try-with-resources and proper cleanup"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"debug-tips",children:"Debug Tips"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Enable native debugging"})," in Android Studio"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use adb logcat"})," to view native logs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Test on different devices"})," and Android versions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use memory profilers"})," to identify leaks"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Validate inputs"})," before JNI calls"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>l});var a=t(6540);const i={},r=a.createContext(i);function o(n){const e=a.useContext(r);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),a.createElement(r.Provider,{value:e},n.children)}}}]);