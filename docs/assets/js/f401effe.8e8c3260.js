"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[7238],{6351:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"extensions/location/tracking","title":"GPS Tracking & Coordinates","description":"The Location extension provides robust GPS tracking capabilities with fixed-point coordinate systems for cross-platform determinism and accuracy handling.","source":"@site/docs/extensions/location/tracking.md","sourceDirName":"extensions/location","slug":"/extensions/location/tracking","permalink":"/docs/extensions/location/tracking","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/location/tracking.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":1,"frontMatter":{"id":"tracking","title":"GPS Tracking & Coordinates","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Creating Custom Extensions","permalink":"/docs/extensions/creating-extensions"},"next":{"title":"Visit Detection","permalink":"/docs/extensions/location/visit-detection"}}');var a=i(4848),o=i(8453);const r={id:"tracking",title:"GPS Tracking & Coordinates",sidebar_position:1},c="GPS Tracking & Coordinates",s={},l=[{value:"Overview",id:"overview",level:2},{value:"Fixed-Point Coordinate System",id:"fixed-point-coordinate-system",level:2},{value:"Coordinate Conversion",id:"coordinate-conversion",level:3},{value:"Distance Calculations",id:"distance-calculations",level:3},{value:"Accuracy Handling",id:"accuracy-handling",level:2},{value:"GPS Accuracy Models",id:"gps-accuracy-models",level:3},{value:"Real-World Accuracy Scenarios",id:"real-world-accuracy-scenarios",level:3},{value:"Data Structures",id:"data-structures",level:2},{value:"LocationPayload",id:"locationpayload",level:3},{value:"Coordinate System Details",id:"coordinate-system-details",level:3},{value:"Tracking Configuration",id:"tracking-configuration",level:2},{value:"Tracking Parameters",id:"tracking-parameters",level:3},{value:"Kalman Filtering",id:"kalman-filtering",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Basic Location Tracking",id:"basic-location-tracking",level:3},{value:"Real-Time Tracking",id:"real-time-tracking",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Processing Performance",id:"processing-performance",level:3},{value:"Optimization Tips",id:"optimization-tips",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Testing &amp; Validation",id:"testing--validation",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"gps-tracking--coordinates",children:"GPS Tracking & Coordinates"})}),"\n",(0,a.jsx)(e.p,{children:"The Location extension provides robust GPS tracking capabilities with fixed-point coordinate systems for cross-platform determinism and accuracy handling."}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(e.p,{children:["The tracking system uses the Universal Measurement Foundation from ",(0,a.jsx)(e.code,{children:"olocus-core"})," to represent location data with comprehensive uncertainty and provenance tracking."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:'use olocus_location::*;\nuse olocus_core::measure::*;\n\n// Create a GPS measurement with uncertainty\nlet location = LocationPayload::new(\n    Measurement::new(\n        Value::Point2D { \n            x: Coordinate::latitude_to_fixed(37.7749),  // San Francisco\n            y: Coordinate::longitude_to_fixed(-122.4194),\n        },\n        Uncertainty::Circular { radius: 5.0 }, // 5m accuracy\n        Provenance::new(Source::Sensor {\n            device_id: "gps-001".to_string(),\n            sensor_type: "GPS".to_string(),\n        }),\n    ),\n    LocationInfo {\n        altitude: Some(100.0), // meters\n        accuracy: Some(5.0),\n        heading: Some(45.0),\n        speed: Some(2.5),\n        timestamp: SystemTime::now(),\n    }\n);\n'})}),"\n",(0,a.jsx)(e.h2,{id:"fixed-point-coordinate-system",children:"Fixed-Point Coordinate System"}),"\n",(0,a.jsx)(e.p,{children:"All coordinates use fixed-point arithmetic for deterministic cross-platform behavior:"}),"\n",(0,a.jsx)(e.h3,{id:"coordinate-conversion",children:"Coordinate Conversion"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"use olocus_core::measure::Coordinate;\n\n// Convert decimal degrees to fixed-point\nlet lat_fixed = Coordinate::latitude_to_fixed(37.7749);  // \u2192 377749000\nlet lon_fixed = Coordinate::longitude_to_fixed(-122.4194); // \u2192 -1224194000\n\n// Convert back to decimal degrees\nlet lat_decimal = Coordinate::fixed_to_latitude(377749000);  // \u2192 37.7749\nlet lon_decimal = Coordinate::fixed_to_longitude(-1224194000); // \u2192 -122.4194\n\n// Precision: ~1cm at the equator\nassert_eq!(lat_fixed, 377749000);\n"})}),"\n",(0,a.jsx)(e.h3,{id:"distance-calculations",children:"Distance Calculations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"// Haversine distance between two points (returns meters)\nlet distance = Coordinate::haversine_distance(\n    377749000,  // SF latitude (fixed-point)\n    -1224194000, // SF longitude (fixed-point)\n    407128000,   // NYC latitude (fixed-point)\n    -740059000   // NYC longitude (fixed-point)\n);\n// Result: ~4100000 meters (4100km)\n\n// Bearing calculation\nlet bearing = Coordinate::bearing(\n    lat1_fixed, lon1_fixed,\n    lat2_fixed, lon2_fixed\n);\n// Result: degrees from north (0-360)\n"})}),"\n",(0,a.jsx)(e.h2,{id:"accuracy-handling",children:"Accuracy Handling"}),"\n",(0,a.jsx)(e.p,{children:"The system provides multiple accuracy representation methods:"}),"\n",(0,a.jsx)(e.h3,{id:"gps-accuracy-models",children:"GPS Accuracy Models"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"// Horizontal accuracy only\nlet basic_accuracy = Uncertainty::Circular { radius: 10.0 };\n\n// Elliptical accuracy (different precision in x/y)\nlet elliptical = Uncertainty::Elliptical {\n    semi_major: 15.0,\n    semi_minor: 8.0,\n    angle: 45.0, // degrees\n};\n\n// Confidence-based accuracy\nlet confidence = Uncertainty::Confidence {\n    value: 5.0,\n    confidence: 0.95, // 95% confidence within 5m\n};\n\n// No accuracy information\nlet unknown = Uncertainty::Unknown;\n"})}),"\n",(0,a.jsx)(e.h3,{id:"real-world-accuracy-scenarios",children:"Real-World Accuracy Scenarios"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:'use olocus_location::accuracy::*;\n\n// Indoor GPS (poor accuracy)\nlet indoor_location = LocationMeasurement::new(\n    point_2d,\n    Uncertainty::Circular { radius: 50.0 },\n    Provenance::new(Source::Sensor {\n        device_id: "phone-gps".to_string(),\n        sensor_type: "GPS-Indoor".to_string(),\n    })\n);\n\n// High-precision survey GPS\nlet survey_location = LocationMeasurement::new(\n    point_2d,\n    Uncertainty::Circular { radius: 0.1 },\n    Provenance::new(Source::Sensor {\n        device_id: "survey-001".to_string(),\n        sensor_type: "RTK-GPS".to_string(),\n    })\n);\n\n// Cellular tower triangulation\nlet cellular_location = LocationMeasurement::new(\n    point_2d,\n    Uncertainty::Circular { radius: 500.0 },\n    Provenance::new(Source::Sensor {\n        device_id: "cellular-tower".to_string(),\n        sensor_type: "Cellular".to_string(),\n    })\n);\n'})}),"\n",(0,a.jsx)(e.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,a.jsx)(e.h3,{id:"locationpayload",children:"LocationPayload"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"#[derive(Debug, Clone)]\npub struct LocationPayload {\n    pub measurement: Measurement,\n    pub info: LocationInfo,\n}\n\n#[derive(Debug, Clone)]\npub struct LocationInfo {\n    pub altitude: Option<f64>,        // meters above sea level\n    pub accuracy: Option<f64>,        // horizontal accuracy (meters)\n    pub vertical_accuracy: Option<f64>, // altitude accuracy (meters)\n    pub heading: Option<f64>,         // degrees from north (0-360)\n    pub speed: Option<f64>,          // meters per second\n    pub timestamp: SystemTime,\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"coordinate-system-details",children:"Coordinate System Details"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"// Internal representation\npub struct Coordinate {\n    pub latitude: i64,   // degrees \xd7 10^7 (-90\xb0 to 90\xb0)\n    pub longitude: i64,  // degrees \xd7 10^7 (-180\xb0 to 180\xb0)\n}\n\n// Bounds checking\nimpl Coordinate {\n    pub const MIN_LATITUDE: i64 = -900_000_000;   // -90\xb0\n    pub const MAX_LATITUDE: i64 = 900_000_000;    // 90\xb0\n    pub const MIN_LONGITUDE: i64 = -1_800_000_000; // -180\xb0\n    pub const MAX_LONGITUDE: i64 = 1_800_000_000;  // 180\xb0\n    \n    pub fn is_valid(&self) -> bool {\n        self.latitude >= Self::MIN_LATITUDE && \n        self.latitude <= Self::MAX_LATITUDE &&\n        self.longitude >= Self::MIN_LONGITUDE && \n        self.longitude <= Self::MAX_LONGITUDE\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"tracking-configuration",children:"Tracking Configuration"}),"\n",(0,a.jsx)(e.h3,{id:"tracking-parameters",children:"Tracking Parameters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"use olocus_location::tracking::*;\n\nlet config = TrackingConfig {\n    min_distance: 10.0,        // minimum movement (meters)\n    min_time_interval: 30,     // minimum time between points (seconds)\n    max_accuracy: 100.0,       // ignore points worse than 100m\n    filter_stationary: true,   // filter out stationary points\n    use_kalman_filter: true,   // smooth tracking data\n};\n\nlet tracker = LocationTracker::new(config);\n"})}),"\n",(0,a.jsx)(e.h3,{id:"kalman-filtering",children:"Kalman Filtering"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"// Enable smoothing for noisy GPS data\nlet smoothed_location = tracker.add_measurement(raw_location)?;\n\n// The tracker maintains internal state:\n// - Position estimates\n// - Velocity estimates  \n// - Acceleration estimates\n// - Uncertainty covariance matrices\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,a.jsx)(e.h3,{id:"basic-location-tracking",children:"Basic Location Tracking"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:'use olocus_core::*;\nuse olocus_location::*;\n\n// Create location payload\nlet location_data = LocationPayload::new(\n    Measurement::new(\n        Value::Point2D {\n            x: Coordinate::latitude_to_fixed(37.7749),\n            y: Coordinate::longitude_to_fixed(-122.4194),\n        },\n        Uncertainty::Circular { radius: 10.0 },\n        Provenance::new(Source::Sensor {\n            device_id: "gps-tracker-001".to_string(),\n            sensor_type: "GPS".to_string(),\n        })\n    ),\n    LocationInfo {\n        altitude: Some(150.0),\n        accuracy: Some(10.0),\n        heading: Some(90.0),  // heading east\n        speed: Some(1.5),     // walking speed\n        timestamp: SystemTime::now(),\n    }\n);\n\n// Create block with location data\nlet mut block = Block::new(\n    location_data,\n    CryptoSuite::Ed25519,\n    &previous_hash\n)?;\n\n// Sign and create chain\nlet chain = block.sign(&private_key)?;\n'})}),"\n",(0,a.jsx)(e.h3,{id:"real-time-tracking",children:"Real-Time Tracking"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"use std::time::Duration;\nuse tokio::time::interval;\n\nasync fn start_tracking() -> Result<()> {\n    let mut tracker = LocationTracker::new(TrackingConfig::default());\n    let mut interval = interval(Duration::from_secs(30));\n    \n    loop {\n        interval.tick().await;\n        \n        // Get GPS reading\n        if let Ok(gps_reading) = get_gps_location().await {\n            // Process through tracker (Kalman filtering)\n            let filtered_location = tracker.add_measurement(gps_reading)?;\n            \n            // Create block if significant movement\n            if tracker.should_record(&filtered_location) {\n                let block = create_location_block(filtered_location)?;\n                store_block(block).await?;\n            }\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Fixed-point coordinates: 16 bytes per point (2 \xd7 i64)"}),"\n",(0,a.jsx)(e.li,{children:"Measurement overhead: ~200 bytes per location"}),"\n",(0,a.jsx)(e.li,{children:"Kalman filter state: ~500 bytes per tracker"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"processing-performance",children:"Processing Performance"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Coordinate conversion: <1\u03bcs"}),"\n",(0,a.jsx)(e.li,{children:"Haversine distance: ~10\u03bcs"}),"\n",(0,a.jsx)(e.li,{children:"Kalman filter update: ~50\u03bcs"}),"\n",(0,a.jsx)(e.li,{children:"Block creation: <1ms"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"optimization-tips",children:"Optimization Tips"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"// Pre-compute fixed-point coordinates for static locations\nconst OFFICE_LAT: i64 = 377749000;  // Pre-computed\nconst OFFICE_LON: i64 = -1224194000;\n\n// Batch distance calculations\nlet distances: Vec<f64> = locations\n    .iter()\n    .map(|loc| Coordinate::haversine_distance(\n        reference_lat, reference_lon,\n        loc.latitude, loc.longitude\n    ))\n    .collect();\n\n// Use appropriate accuracy thresholds\nlet config = TrackingConfig {\n    max_accuracy: 50.0,  // Ignore very inaccurate readings\n    min_distance: 5.0,   // Reduce noise in stationary scenarios\n    ..Default::default()\n};\n"})}),"\n",(0,a.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"use olocus_location::error::LocationError;\n\nmatch location_result {\n    Ok(location) => {\n        // Process valid location\n    },\n    Err(LocationError::InvalidCoordinates(lat, lon)) => {\n        // Handle out-of-bounds coordinates\n    },\n    Err(LocationError::InsufficientAccuracy(accuracy)) => {\n        // Handle low-accuracy readings\n    },\n    Err(LocationError::StaleMeasurement(age)) => {\n        // Handle old GPS data\n    },\n    Err(LocationError::KalmanFilterError(msg)) => {\n        // Handle filter convergence issues\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing--validation",children:"Testing & Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_coordinate_precision() {\n        let lat = 37.7749123456789;\n        let fixed = Coordinate::latitude_to_fixed(lat);\n        let restored = Coordinate::fixed_to_latitude(fixed);\n        \n        // Should preserve ~1cm precision\n        assert!((lat - restored).abs() < 0.00000001);\n    }\n    \n    #[test]\n    fn test_haversine_accuracy() {\n        // Known distance between SF and NYC: ~4,139 km\n        let distance = Coordinate::haversine_distance(\n            377749000, -1224194000,  // SF\n            407128000, -740059000    // NYC\n        );\n        \n        assert!((distance - 4_139_000.0).abs() < 1000.0); // Within 1km\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/extensions/location/visit-detection",children:"Visit Detection"})," - Detecting stays and visits"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/extensions/location/clustering",children:"Clustering"})," - Location clustering algorithms"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/extensions/location/privacy-obfuscation",children:"Privacy & Obfuscation"})," - Location privacy techniques"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.a,{href:"/docs/concepts/measurements",children:"Universal Measurement Foundation"})," - Core measurement types"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>c});var t=i(6540);const a={},o=t.createContext(a);function r(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);