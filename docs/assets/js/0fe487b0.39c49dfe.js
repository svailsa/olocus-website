"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[7675],{8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>a});var t=o(6540);const i={},r=t.createContext(i);function s(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},9811:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"integration/ffi","title":"FFI Reference","description":"Complete Foreign Function Interface (FFI) reference for integrating Olocus Protocol with any programming language that supports C bindings. This covers the C interface, memory management, cross-language patterns, and platform-specific considerations.","source":"@site/docs/integration/ffi.md","sourceDirName":"integration","slug":"/integration/ffi","permalink":"/docs/integration/ffi","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/integration/ffi.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":4,"frontMatter":{"id":"ffi","title":"FFI Reference","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Web Integration","permalink":"/docs/integration/web"},"next":{"title":"WebAssembly Guide","permalink":"/docs/integration/wasm"}}');var i=o(4848),r=o(8453);const s={id:"ffi",title:"FFI Reference",sidebar_position:4},a="FFI Reference",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Core API Reference",id:"core-api-reference",level:2},{value:"Initialization and Configuration",id:"initialization-and-configuration",level:3},{value:"Key Management",id:"key-management",level:3},{value:"Block Operations",id:"block-operations",level:3},{value:"Chain Operations",id:"chain-operations",level:3},{value:"Wire Format Operations",id:"wire-format-operations",level:3},{value:"Cryptographic Operations",id:"cryptographic-operations",level:3},{value:"Async Operations",id:"async-operations",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Version and Feature Information",id:"version-and-feature-information",level:3},{value:"Language-Specific Bindings",id:"language-specific-bindings",level:2},{value:"Python (ctypes)",id:"python-ctypes",level:3},{value:"Go (CGO)",id:"go-cgo",level:3},{value:"Platform-Specific Considerations",id:"platform-specific-considerations",level:2},{value:"iOS Specific",id:"ios-specific",level:3},{value:"Android Specific",id:"android-specific",level:3},{value:"WebAssembly Specific",id:"webassembly-specific",level:3},{value:"Threading and Safety",id:"threading-and-safety",level:2},{value:"Thread Safety Rules",id:"thread-safety-rules",level:3},{value:"Synchronization Example (C)",id:"synchronization-example-c",level:3},{value:"Memory Management Best Practices",id:"memory-management-best-practices",level:2},{value:"RAII Pattern (C++)",id:"raii-pattern-c",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Error Codes Reference",id:"error-codes-reference",level:3},{value:"Comprehensive Error Handling (C)",id:"comprehensive-error-handling-c",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Batch Operations",id:"batch-operations",level:3},{value:"Memory Pool Allocation",id:"memory-pool-allocation",level:3},{value:"Testing and Debugging",id:"testing-and-debugging",level:2},{value:"Unit Test Framework Integration",id:"unit-test-framework-integration",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Security",id:"security",level:3},{value:"Performance",id:"performance",level:3},{value:"Memory Management",id:"memory-management-1",level:3},{value:"Error Handling",id:"error-handling-1",level:3},{value:"Cross-Platform",id:"cross-platform",level:3}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"ffi-reference",children:"FFI Reference"})}),"\n",(0,i.jsx)(e.p,{children:"Complete Foreign Function Interface (FFI) reference for integrating Olocus Protocol with any programming language that supports C bindings. This covers the C interface, memory management, cross-language patterns, and platform-specific considerations."}),"\n",(0,i.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"The Olocus FFI provides a C-compatible API that enables integration with:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mobile platforms"}),": iOS (Swift/Objective-C), Android (Kotlin/Java)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Web platforms"}),": WebAssembly (JavaScript/TypeScript)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Desktop applications"}),": .NET, Python, Go, Node.js"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"System languages"}),": C, C++, Rust"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"core-api-reference",children:"Core API Reference"}),"\n",(0,i.jsx)(e.h3,{id:"initialization-and-configuration",children:"Initialization and Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Library lifecycle\nint olocus_init(void);\nint olocus_init_with_config(const FFIConfig* config);\nvoid olocus_shutdown(void);\nbool olocus_is_initialized(void);\n\n// Configuration management\nFFIConfig* olocus_config_create(void);\nvoid olocus_config_destroy(FFIConfig* config);\n\n// Platform-specific configuration\nvoid olocus_config_set_platform_ios(FFIConfig* config, bool enabled);\nvoid olocus_config_set_platform_android(FFIConfig* config, bool enabled);\nvoid olocus_config_set_platform_web(FFIConfig* config, bool enabled);\nvoid olocus_config_set_keychain_enabled(FFIConfig* config, bool enabled);\nvoid olocus_config_set_keystore_enabled(FFIConfig* config, bool enabled);\nvoid olocus_config_set_network_enabled(FFIConfig* config, bool enabled);\n\n// Thread configuration\nvoid olocus_config_set_max_threads(FFIConfig* config, uint32_t max_threads);\nvoid olocus_config_set_worker_threads(FFIConfig* config, uint32_t worker_threads);\n\n// Security configuration\nvoid olocus_config_set_secure_memory(FFIConfig* config, bool enabled);\nvoid olocus_config_set_constant_time(FFIConfig* config, bool enabled);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"key-management",children:"Key Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Key pair operations\nFFIKeyPair* olocus_keypair_generate(void);\nFFIKeyPair* olocus_keypair_from_bytes(const uint8_t* private_key);\nFFIKeyPair* olocus_keypair_from_seed(const uint8_t* seed, size_t seed_len);\nvoid olocus_keypair_destroy(FFIKeyPair* keypair);\n\n// Key extraction\nvoid olocus_keypair_get_public_key(const FFIKeyPair* keypair, uint8_t* public_key);\nvoid olocus_keypair_get_private_key(const FFIKeyPair* keypair, uint8_t* private_key);\nsize_t olocus_keypair_get_public_key_len(void);  // Returns 32\nsize_t olocus_keypair_get_private_key_len(void); // Returns 32\n\n// Key validation\nint olocus_keypair_validate(const FFIKeyPair* keypair);\nbool olocus_keypair_is_valid_public_key(const uint8_t* public_key);\nbool olocus_keypair_is_valid_private_key(const uint8_t* private_key);\n\n// Key derivation\nFFIKeyPair* olocus_keypair_derive_child(\n    const FFIKeyPair* parent,\n    uint32_t index,\n    bool hardened\n);\nFFIKeyPair* olocus_keypair_derive_path(\n    const FFIKeyPair* master,\n    const char* derivation_path\n);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"block-operations",children:"Block Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Block creation\nFFIBlock* olocus_block_create_genesis(\n    int64_t timestamp,\n    const uint8_t* payload,\n    size_t payload_len,\n    uint32_t payload_type,\n    const uint8_t* signing_key\n);\n\nFFIBlock* olocus_block_create(\n    uint64_t index,\n    int64_t timestamp,\n    const uint8_t* previous_hash,\n    const uint8_t* payload,\n    size_t payload_len,\n    uint32_t payload_type,\n    const uint8_t* signing_key\n);\n\n// Block destruction\nvoid olocus_block_destroy(FFIBlock* block);\n\n// Block properties\nuint64_t olocus_block_get_index(const FFIBlock* block);\nint64_t olocus_block_get_timestamp(const FFIBlock* block);\nuint32_t olocus_block_get_payload_type(const FFIBlock* block);\nsize_t olocus_block_get_payload_len(const FFIBlock* block);\nvoid olocus_block_get_hash(const FFIBlock* block, uint8_t* hash);\nvoid olocus_block_get_previous_hash(const FFIBlock* block, uint8_t* hash);\nvoid olocus_block_get_payload(const FFIBlock* block, uint8_t* payload);\nvoid olocus_block_get_signature(const FFIBlock* block, uint8_t* signature);\nvoid olocus_block_get_public_key(const FFIBlock* block, uint8_t* public_key);\n\n// Block validation\nint olocus_block_verify(const FFIBlock* block);\nint olocus_block_verify_signature(const FFIBlock* block);\nint olocus_block_verify_hash(const FFIBlock* block);\nint olocus_block_verify_timestamp(const FFIBlock* block, int64_t max_future_offset);\n\n// Block comparison\nbool olocus_block_equals(const FFIBlock* a, const FFIBlock* b);\nint olocus_block_compare_timestamp(const FFIBlock* a, const FFIBlock* b);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"chain-operations",children:"Chain Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Chain creation and destruction\nFFIChain* olocus_chain_create(void);\nFFIChain* olocus_chain_create_with_limit(size_t max_length);\nvoid olocus_chain_destroy(FFIChain* chain);\n\n// Chain manipulation\nint olocus_chain_add_block(FFIChain* chain, const FFIBlock* block);\nint olocus_chain_insert_block(FFIChain* chain, size_t index, const FFIBlock* block);\nint olocus_chain_remove_block(FFIChain* chain, size_t index);\nvoid olocus_chain_clear(FFIChain* chain);\n\n// Chain queries\nsize_t olocus_chain_get_length(const FFIChain* chain);\nbool olocus_chain_is_empty(const FFIChain* chain);\nconst FFIBlock* olocus_chain_get_block(const FFIChain* chain, size_t index);\nconst FFIBlock* olocus_chain_get_genesis_block(const FFIChain* chain);\nconst FFIBlock* olocus_chain_get_last_block(const FFIChain* chain);\nconst FFIBlock* olocus_chain_find_by_hash(const FFIChain* chain, const uint8_t* hash);\n\n// Chain validation\nint olocus_chain_verify(const FFIChain* chain);\nint olocus_chain_verify_continuity(const FFIChain* chain);\nint olocus_chain_verify_timestamps(const FFIChain* chain);\nint olocus_chain_verify_signatures(const FFIChain* chain);\n\n// Chain properties\nvoid olocus_chain_get_tip_hash(const FFIChain* chain, uint8_t* hash);\nint64_t olocus_chain_get_earliest_timestamp(const FFIChain* chain);\nint64_t olocus_chain_get_latest_timestamp(const FFIChain* chain);\n\n// Chain iteration\ntypedef bool (*FFIBlockVisitor)(const FFIBlock* block, size_t index, void* user_data);\nvoid olocus_chain_iterate(const FFIChain* chain, FFIBlockVisitor visitor, void* user_data);\nvoid olocus_chain_iterate_range(\n    const FFIChain* chain,\n    size_t start_index,\n    size_t end_index,\n    FFIBlockVisitor visitor,\n    void* user_data\n);\n\n// Batch operations\nint olocus_chain_add_blocks(\n    FFIChain* chain,\n    const FFIBlock* const* blocks,\n    size_t block_count\n);\nint olocus_chain_get_range(\n    const FFIChain* chain,\n    size_t start_index,\n    size_t count,\n    FFIBlock** blocks\n);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"wire-format-operations",children:"Wire Format Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Wire format types\ntypedef struct {\n    uint8_t encoding;  // FFIEncodingFormat\n    uint8_t compression; // FFICompressionMethod\n    uint8_t version;\n    uint8_t reserved;\n} FFIWireFormat;\n\n// Encoding formats\ntypedef enum {\n    FFIEncodingFormat_Binary = 0,\n    FFIEncodingFormat_Json = 1,\n    FFIEncodingFormat_MessagePack = 2,\n    FFIEncodingFormat_Protobuf = 3,\n    FFIEncodingFormat_Ssz = 4\n} FFIEncodingFormat;\n\n// Compression methods\ntypedef enum {\n    FFICompressionMethod_None = 0,\n    FFICompressionMethod_Zstd = 1,\n    FFICompressionMethod_Lz4 = 2,\n    FFICompressionMethod_Gzip = 3\n} FFICompressionMethod;\n\n// Wire format creation\nFFIWireFormat olocus_wire_format_binary(void);\nFFIWireFormat olocus_wire_format_json(void);\nFFIWireFormat olocus_wire_format_msgpack(void);\nFFIWireFormat olocus_wire_format_protobuf(void);\nFFIWireFormat olocus_wire_format_ssz(void);\nFFIWireFormat olocus_wire_format_new(FFIEncodingFormat encoding, FFICompressionMethod compression);\n\n// Content type handling\nchar* olocus_wire_format_content_type(FFIWireFormat format);\nint olocus_wire_format_from_content_type(const char* content_type, FFIWireFormat* format);\n\n// Block serialization\nFFIByteBuffer olocus_block_to_wire_format(const FFIBlock* block, FFIWireFormat format);\nFFIBlock* olocus_block_from_wire_format(\n    const uint8_t* data,\n    size_t data_len,\n    FFIWireFormat format\n);\n\n// Chain serialization\nFFIByteBuffer olocus_chain_to_wire_format(const FFIChain* chain, FFIWireFormat format);\nFFIChain* olocus_chain_from_wire_format(\n    const uint8_t* data,\n    size_t data_len,\n    FFIWireFormat format\n);\n\n// Legacy JSON methods (convenience)\nchar* olocus_block_to_json(const FFIBlock* block);\nFFIBlock* olocus_block_from_json(const char* json);\nchar* olocus_chain_to_json(const FFIChain* chain);\nFFIChain* olocus_chain_from_json(const char* json);\n\n// Binary methods (convenience)\nFFIByteBuffer olocus_block_to_bytes(const FFIBlock* block);\nFFIBlock* olocus_block_from_bytes(const uint8_t* data, size_t data_len);\nFFIByteBuffer olocus_chain_to_bytes(const FFIChain* chain);\nFFIChain* olocus_chain_from_bytes(const uint8_t* data, size_t data_len);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"cryptographic-operations",children:"Cryptographic Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Digital signatures\nvoid olocus_sign(\n    const FFIKeyPair* keypair,\n    const uint8_t* message,\n    size_t message_len,\n    uint8_t* signature\n);\n\nint olocus_verify(\n    const uint8_t* public_key,\n    const uint8_t* message,\n    size_t message_len,\n    const uint8_t* signature\n);\n\nsize_t olocus_signature_len(void); // Returns 64\n\n// Batch signature operations\nvoid olocus_sign_batch(\n    const FFIKeyPair* keypair,\n    const uint8_t* const* messages,\n    const size_t* message_lens,\n    size_t message_count,\n    uint8_t* signatures\n);\n\nint olocus_verify_batch(\n    const uint8_t* public_key,\n    const uint8_t* const* messages,\n    const size_t* message_lens,\n    const uint8_t* const* signatures,\n    size_t count,\n    bool* results\n);\n\n// Hashing\nvoid olocus_hash_sha256(const uint8_t* data, size_t data_len, uint8_t* hash);\nvoid olocus_hash_sha512(const uint8_t* data, size_t data_len, uint8_t* hash);\nvoid olocus_hash_blake3(const uint8_t* data, size_t data_len, uint8_t* hash);\n\n// Incremental hashing\nFFIHasher* olocus_hasher_create(void);\nFFIHasher* olocus_hasher_create_sha512(void);\nFFIHasher* olocus_hasher_create_blake3(void);\nvoid olocus_hasher_update(FFIHasher* hasher, const uint8_t* data, size_t data_len);\nvoid olocus_hasher_finalize(FFIHasher* hasher, uint8_t* hash);\nvoid olocus_hasher_reset(FFIHasher* hasher);\nvoid olocus_hasher_destroy(FFIHasher* hasher);\n\n// Random number generation\nvoid olocus_random_bytes(uint8_t* buffer, size_t len);\nuint32_t olocus_random_u32(void);\nuint64_t olocus_random_u64(void);\n\n// Key derivation\nvoid olocus_hkdf_derive(\n    const uint8_t* input_key,\n    size_t input_key_len,\n    const uint8_t* salt,\n    size_t salt_len,\n    const uint8_t* info,\n    size_t info_len,\n    uint8_t* output,\n    size_t output_len\n);\n\nvoid olocus_pbkdf2_derive(\n    const uint8_t* password,\n    size_t password_len,\n    const uint8_t* salt,\n    size_t salt_len,\n    uint32_t iterations,\n    uint8_t* output,\n    size_t output_len\n);\n\n// Constant-time operations\nint olocus_constant_time_eq(const uint8_t* a, const uint8_t* b, size_t len);\nvoid olocus_constant_time_select(\n    const uint8_t* a,\n    const uint8_t* b,\n    uint8_t choice,\n    uint8_t* result,\n    size_t len\n);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"async-operations",children:"Async Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Async handle\ntypedef struct FFIAsyncHandle FFIAsyncHandle;\n\n// Async states\ntypedef enum {\n    FFIAsyncState_Pending = 0,\n    FFIAsyncState_Running = 1,\n    FFIAsyncState_Completed = 2,\n    FFIAsyncState_Cancelled = 3,\n    FFIAsyncState_Failed = 4\n} FFIAsyncState;\n\n// Async callback\ntypedef void (*FFIAsyncCallback)(\n    void* user_data,\n    int result,\n    const void* data,\n    size_t data_len\n);\n\n// Async handle management\nFFIAsyncHandle* olocus_async_create(FFIAsyncCallback callback, void* user_data);\nvoid olocus_async_destroy(FFIAsyncHandle* handle);\n\n// Async operations\nvoid olocus_async_create_block(\n    FFIAsyncHandle* handle,\n    uint64_t index,\n    int64_t timestamp,\n    const uint8_t* previous_hash,\n    const uint8_t* payload,\n    size_t payload_len,\n    uint32_t payload_type,\n    const uint8_t* signing_key\n);\n\nvoid olocus_async_verify_block(FFIAsyncHandle* handle, const FFIBlock* block);\nvoid olocus_async_verify_chain(FFIAsyncHandle* handle, const FFIChain* chain);\nvoid olocus_async_sign(FFIAsyncHandle* handle, const FFIKeyPair* keypair, const uint8_t* data, size_t len);\n\n// Async status\nFFIAsyncState olocus_async_get_state(const FFIAsyncHandle* handle);\nbool olocus_async_is_complete(const FFIAsyncHandle* handle);\nbool olocus_async_is_running(const FFIAsyncHandle* handle);\nfloat olocus_async_get_progress(const FFIAsyncHandle* handle);\n\n// Async control\nvoid olocus_async_cancel(FFIAsyncHandle* handle);\nint olocus_async_wait(FFIAsyncHandle* handle);\nint olocus_async_wait_timeout(FFIAsyncHandle* handle, uint32_t timeout_ms);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Basic allocation\nvoid* olocus_alloc(size_t size);\nvoid* olocus_alloc_aligned(size_t size, size_t alignment);\nvoid* olocus_realloc(void* ptr, size_t old_size, size_t new_size);\nvoid olocus_free(void* ptr, size_t size);\nvoid olocus_free_aligned(void* ptr, size_t size, size_t alignment);\n\n// Secure memory operations\nvoid* olocus_secure_alloc(size_t size);\nvoid olocus_secure_free(void* ptr, size_t size);\nvoid olocus_secure_zero(void* ptr, size_t size);\nint olocus_mlock(void* ptr, size_t size);\nint olocus_munlock(void* ptr, size_t size);\n\n// String memory management\nvoid olocus_free_string(char* str);\nchar* olocus_string_clone(const char* str);\n\n// Byte buffer management\ntypedef struct {\n    uint8_t* data;\n    size_t len;\n    size_t capacity;\n} FFIByteBuffer;\n\nFFIByteBuffer olocus_byte_buffer_create(size_t capacity);\nFFIByteBuffer olocus_byte_buffer_from_data(const uint8_t* data, size_t len);\nvoid olocus_byte_buffer_resize(FFIByteBuffer* buffer, size_t new_size);\nvoid olocus_byte_buffer_append(FFIByteBuffer* buffer, const uint8_t* data, size_t len);\nvoid olocus_byte_buffer_free(FFIByteBuffer* buffer);\n\n// Reference counting (for shared objects)\nvoid olocus_block_retain(FFIBlock* block);\nvoid olocus_block_release(FFIBlock* block);\nuint32_t olocus_block_get_ref_count(const FFIBlock* block);\n\nvoid olocus_chain_retain(FFIChain* chain);\nvoid olocus_chain_release(FFIChain* chain);\nuint32_t olocus_chain_get_ref_count(const FFIChain* chain);\n\n// Memory statistics\ntypedef struct {\n    size_t total_allocated;\n    size_t peak_allocated;\n    size_t current_allocated;\n    size_t allocation_count;\n    size_t free_count;\n} FFIMemoryStats;\n\nvoid olocus_memory_get_stats(FFIMemoryStats* stats);\nvoid olocus_memory_reset_stats(void);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Error management\nint olocus_get_last_error_code(void);\nchar* olocus_get_last_error_message(void);\nchar* olocus_get_last_error_details(void);\nvoid olocus_clear_error(void);\n\n// Error description (static strings, no need to free)\nconst char* olocus_error_description(int error_code);\nconst char* olocus_error_category(int error_code);\n\n// Error callback\ntypedef void (*FFIErrorCallback)(int error_code, const char* message, void* user_data);\nvoid olocus_set_error_callback(FFIErrorCallback callback, void* user_data);\nvoid olocus_clear_error_callback(void);\n\n// Logging\ntypedef enum {\n    FFILogLevel_Error = 0,\n    FFILogLevel_Warn = 1,\n    FFILogLevel_Info = 2,\n    FFILogLevel_Debug = 3,\n    FFILogLevel_Trace = 4\n} FFILogLevel;\n\ntypedef void (*FFILogCallback)(FFILogLevel level, const char* target, const char* message, void* user_data);\nvoid olocus_set_log_callback(FFILogCallback callback, void* user_data);\nvoid olocus_set_log_level(FFILogLevel level);\nFFILogLevel olocus_get_log_level(void);\nvoid olocus_log(FFILogLevel level, const char* target, const char* message);\n\n// Panic handling\ntypedef void (*FFIPanicCallback)(const char* message, void* user_data);\nvoid olocus_set_panic_callback(FFIPanicCallback callback, void* user_data);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"version-and-feature-information",children:"Version and Feature Information"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Version information\nconst char* olocus_version(void);\nconst char* olocus_version_full(void);\nconst char* olocus_git_hash(void);\nconst char* olocus_build_timestamp(void);\n\ntypedef struct {\n    uint16_t major;\n    uint16_t minor;\n    uint16_t patch;\n    const char* pre_release;\n    const char* build_metadata;\n} FFIVersion;\n\nvoid olocus_version_info(FFIVersion* version);\nint olocus_version_compare(const FFIVersion* a, const FFIVersion* b);\n\n// Feature detection\nbool olocus_has_feature(const char* feature_name);\nchar** olocus_list_features(size_t* count);\nvoid olocus_free_string_array(char** strings, size_t count);\n\n// Platform information\nconst char* olocus_platform_name(void);\nconst char* olocus_architecture(void);\nconst char* olocus_target_triple(void);\n\n// Compilation information\nconst char* olocus_compiler_version(void);\nconst char* olocus_rust_version(void);\nchar** olocus_compile_flags(size_t* count);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"language-specific-bindings",children:"Language-Specific Bindings"}),"\n",(0,i.jsx)(e.h3,{id:"python-ctypes",children:"Python (ctypes)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# olocus_bindings.py\nimport ctypes\nfrom ctypes import POINTER, c_void_p, c_char_p, c_uint8, c_uint32, c_uint64, c_int64, c_size_t, c_int, c_bool, c_float\nimport os\nimport platform\n\n# Library loading\ndef load_olocus_library():\n    system = platform.system()\n    if system == \'Windows\':\n        lib_name = \'olocus_ffi.dll\'\n    elif system == \'Darwin\':\n        lib_name = \'libolocus_ffi.dylib\'\n    else:\n        lib_name = \'libolocus_ffi.so\'\n    \n    # Try different paths\n    for path in [\'.\', \'lib\', \'/usr/local/lib\', \'/usr/lib\']:\n        lib_path = os.path.join(path, lib_name)\n        if os.path.exists(lib_path):\n            return ctypes.CDLL(lib_path)\n    \n    raise FileNotFoundError(f"Could not find {lib_name}")\n\nlib = load_olocus_library()\n\n# Type definitions\nclass FFIByteBuffer(ctypes.Structure):\n    _fields_ = [\n        ("data", POINTER(c_uint8)),\n        ("len", c_size_t),\n        ("capacity", c_size_t)\n    ]\n\nclass FFIWireFormat(ctypes.Structure):\n    _fields_ = [\n        ("encoding", c_uint8),\n        ("compression", c_uint8),\n        ("version", c_uint8),\n        ("reserved", c_uint8)\n    ]\n\nclass FFIVersion(ctypes.Structure):\n    _fields_ = [\n        ("major", c_uint16),\n        ("minor", c_uint16),\n        ("patch", c_uint16),\n        ("pre_release", c_char_p),\n        ("build_metadata", c_char_p)\n    ]\n\n# Opaque pointer types\nFFIConfig = c_void_p\nFFIKeyPair = c_void_p\nFFIBlock = c_void_p\nFFIChain = c_void_p\nFFIHasher = c_void_p\nFFIAsyncHandle = c_void_p\n\n# Function signatures\n# Initialization\nlib.olocus_init.argtypes = []\nlib.olocus_init.restype = c_int\n\nlib.olocus_init_with_config.argtypes = [FFIConfig]\nlib.olocus_init_with_config.restype = c_int\n\nlib.olocus_shutdown.argtypes = []\nlib.olocus_shutdown.restype = None\n\nlib.olocus_is_initialized.argtypes = []\nlib.olocus_is_initialized.restype = c_bool\n\n# Configuration\nlib.olocus_config_create.argtypes = []\nlib.olocus_config_create.restype = FFIConfig\n\nlib.olocus_config_destroy.argtypes = [FFIConfig]\nlib.olocus_config_destroy.restype = None\n\nlib.olocus_config_set_network_enabled.argtypes = [FFIConfig, c_bool]\nlib.olocus_config_set_network_enabled.restype = None\n\n# Key management\nlib.olocus_keypair_generate.argtypes = []\nlib.olocus_keypair_generate.restype = FFIKeyPair\n\nlib.olocus_keypair_from_bytes.argtypes = [POINTER(c_uint8)]\nlib.olocus_keypair_from_bytes.restype = FFIKeyPair\n\nlib.olocus_keypair_destroy.argtypes = [FFIKeyPair]\nlib.olocus_keypair_destroy.restype = None\n\nlib.olocus_keypair_get_public_key.argtypes = [FFIKeyPair, POINTER(c_uint8)]\nlib.olocus_keypair_get_public_key.restype = None\n\nlib.olocus_keypair_get_private_key.argtypes = [FFIKeyPair, POINTER(c_uint8)]\nlib.olocus_keypair_get_private_key.restype = None\n\n# Block operations\nlib.olocus_block_create_genesis.argtypes = [\n    c_int64, POINTER(c_uint8), c_size_t, c_uint32, POINTER(c_uint8)\n]\nlib.olocus_block_create_genesis.restype = FFIBlock\n\nlib.olocus_block_create.argtypes = [\n    c_uint64, c_int64, POINTER(c_uint8), POINTER(c_uint8), c_size_t, c_uint32, POINTER(c_uint8)\n]\nlib.olocus_block_create.restype = FFIBlock\n\nlib.olocus_block_destroy.argtypes = [FFIBlock]\nlib.olocus_block_destroy.restype = None\n\nlib.olocus_block_verify.argtypes = [FFIBlock]\nlib.olocus_block_verify.restype = c_int\n\nlib.olocus_block_get_index.argtypes = [FFIBlock]\nlib.olocus_block_get_index.restype = c_uint64\n\nlib.olocus_block_get_timestamp.argtypes = [FFIBlock]\nlib.olocus_block_get_timestamp.restype = c_int64\n\nlib.olocus_block_get_payload_type.argtypes = [FFIBlock]\nlib.olocus_block_get_payload_type.restype = c_uint32\n\nlib.olocus_block_get_hash.argtypes = [FFIBlock, POINTER(c_uint8)]\nlib.olocus_block_get_hash.restype = None\n\n# Chain operations\nlib.olocus_chain_create.argtypes = []\nlib.olocus_chain_create.restype = FFIChain\n\nlib.olocus_chain_destroy.argtypes = [FFIChain]\nlib.olocus_chain_destroy.restype = None\n\nlib.olocus_chain_add_block.argtypes = [FFIChain, FFIBlock]\nlib.olocus_chain_add_block.restype = c_int\n\nlib.olocus_chain_get_length.argtypes = [FFIChain]\nlib.olocus_chain_get_length.restype = c_size_t\n\nlib.olocus_chain_verify.argtypes = [FFIChain]\nlib.olocus_chain_verify.restype = c_int\n\n# Wire format\nlib.olocus_wire_format_json.argtypes = []\nlib.olocus_wire_format_json.restype = FFIWireFormat\n\nlib.olocus_block_to_wire_format.argtypes = [FFIBlock, FFIWireFormat]\nlib.olocus_block_to_wire_format.restype = FFIByteBuffer\n\nlib.olocus_block_from_wire_format.argtypes = [POINTER(c_uint8), c_size_t, FFIWireFormat]\nlib.olocus_block_from_wire_format.restype = FFIBlock\n\n# Memory management\nlib.olocus_byte_buffer_free.argtypes = [POINTER(FFIByteBuffer)]\nlib.olocus_byte_buffer_free.restype = None\n\nlib.olocus_free_string.argtypes = [c_char_p]\nlib.olocus_free_string.restype = None\n\n# Cryptographic operations\nlib.olocus_sign.argtypes = [FFIKeyPair, POINTER(c_uint8), c_size_t, POINTER(c_uint8)]\nlib.olocus_sign.restype = None\n\nlib.olocus_verify.argtypes = [POINTER(c_uint8), POINTER(c_uint8), c_size_t, POINTER(c_uint8)]\nlib.olocus_verify.restype = c_int\n\nlib.olocus_hash_sha256.argtypes = [POINTER(c_uint8), c_size_t, POINTER(c_uint8)]\nlib.olocus_hash_sha256.restype = None\n\nlib.olocus_random_bytes.argtypes = [POINTER(c_uint8), c_size_t]\nlib.olocus_random_bytes.restype = None\n\n# Error handling\nlib.olocus_get_last_error_code.argtypes = []\nlib.olocus_get_last_error_code.restype = c_int\n\nlib.olocus_get_last_error_message.argtypes = []\nlib.olocus_get_last_error_message.restype = c_char_p\n\nlib.olocus_clear_error.argtypes = []\nlib.olocus_clear_error.restype = None\n\n# Version information\nlib.olocus_version.argtypes = []\nlib.olocus_version.restype = c_char_p\n\n# High-level Python wrapper\nclass OlocusException(Exception):\n    def __init__(self, message, error_code=None):\n        super().__init__(message)\n        self.error_code = error_code\n\nclass KeyPair:\n    def __init__(self, ptr=None):\n        self._ptr = ptr or lib.olocus_keypair_generate()\n        if not self._ptr:\n            raise OlocusException("Failed to create keypair")\n    \n    @classmethod\n    def from_bytes(cls, private_key):\n        if len(private_key) != 32:\n            raise ValueError("Private key must be 32 bytes")\n        \n        key_array = (c_uint8 * 32)(*private_key)\n        ptr = lib.olocus_keypair_from_bytes(key_array)\n        if not ptr:\n            raise OlocusException("Failed to create keypair from bytes")\n        \n        return cls(ptr)\n    \n    def get_public_key(self):\n        public_key = (c_uint8 * 32)()\n        lib.olocus_keypair_get_public_key(self._ptr, public_key)\n        return bytes(public_key)\n    \n    def get_private_key(self):\n        private_key = (c_uint8 * 32)()\n        lib.olocus_keypair_get_private_key(self._ptr, private_key)\n        return bytes(private_key)\n    \n    def __del__(self):\n        if hasattr(self, \'_ptr\') and self._ptr:\n            lib.olocus_keypair_destroy(self._ptr)\n\nclass Block:\n    def __init__(self, ptr):\n        self._ptr = ptr\n    \n    @classmethod\n    def create_genesis(cls, payload, payload_type=0, signing_key=None):\n        if signing_key is None:\n            keypair = KeyPair()\n            signing_key = keypair.get_private_key()\n        \n        if len(signing_key) != 32:\n            raise ValueError("Signing key must be 32 bytes")\n        \n        payload_data = payload if isinstance(payload, bytes) else payload.encode(\'utf-8\')\n        payload_array = (c_uint8 * len(payload_data))(*payload_data)\n        key_array = (c_uint8 * 32)(*signing_key)\n        \n        ptr = lib.olocus_block_create_genesis(\n            int(time.time() * 1000),  # timestamp in ms\n            payload_array,\n            len(payload_data),\n            payload_type,\n            key_array\n        )\n        \n        if not ptr:\n            error_msg = lib.olocus_get_last_error_message()\n            if error_msg:\n                msg = error_msg.decode(\'utf-8\')\n                lib.olocus_free_string(error_msg)\n            else:\n                msg = "Unknown error"\n            raise OlocusException(msg, lib.olocus_get_last_error_code())\n        \n        return cls(ptr)\n    \n    def get_index(self):\n        return lib.olocus_block_get_index(self._ptr)\n    \n    def get_timestamp(self):\n        return lib.olocus_block_get_timestamp(self._ptr)\n    \n    def get_payload_type(self):\n        return lib.olocus_block_get_payload_type(self._ptr)\n    \n    def get_hash(self):\n        hash_bytes = (c_uint8 * 32)()\n        lib.olocus_block_get_hash(self._ptr, hash_bytes)\n        return bytes(hash_bytes)\n    \n    def verify(self):\n        result = lib.olocus_block_verify(self._ptr)\n        if result != 0:\n            error_msg = lib.olocus_get_last_error_message()\n            if error_msg:\n                msg = error_msg.decode(\'utf-8\')\n                lib.olocus_free_string(error_msg)\n                raise OlocusException(msg, result)\n        return True\n    \n    def to_json(self):\n        wire_format = lib.olocus_wire_format_json()\n        buffer = lib.olocus_block_to_wire_format(self._ptr, wire_format)\n        try:\n            data = ctypes.string_at(buffer.data, buffer.len)\n            return data.decode(\'utf-8\')\n        finally:\n            lib.olocus_byte_buffer_free(ctypes.byref(buffer))\n    \n    def __del__(self):\n        if hasattr(self, \'_ptr\') and self._ptr:\n            lib.olocus_block_destroy(self._ptr)\n\nclass Chain:\n    def __init__(self):\n        self._ptr = lib.olocus_chain_create()\n        if not self._ptr:\n            raise OlocusException("Failed to create chain")\n    \n    def add_block(self, block):\n        result = lib.olocus_chain_add_block(self._ptr, block._ptr)\n        if result != 0:\n            error_msg = lib.olocus_get_last_error_message()\n            if error_msg:\n                msg = error_msg.decode(\'utf-8\')\n                lib.olocus_free_string(error_msg)\n            else:\n                msg = "Unknown error"\n            raise OlocusException(msg, result)\n    \n    def get_length(self):\n        return lib.olocus_chain_get_length(self._ptr)\n    \n    def verify(self):\n        result = lib.olocus_chain_verify(self._ptr)\n        if result != 0:\n            error_msg = lib.olocus_get_last_error_message()\n            if error_msg:\n                msg = error_msg.decode(\'utf-8\')\n                lib.olocus_free_string(error_msg)\n                raise OlocusException(msg, result)\n        return True\n    \n    def __del__(self):\n        if hasattr(self, \'_ptr\') and self._ptr:\n            lib.olocus_chain_destroy(self._ptr)\n\n# Module initialization\ndef initialize():\n    result = lib.olocus_init()\n    if result != 0:\n        error_msg = lib.olocus_get_last_error_message()\n        if error_msg:\n            msg = error_msg.decode(\'utf-8\')\n            lib.olocus_free_string(error_msg)\n        else:\n            msg = "Unknown error"\n        raise OlocusException(msg, result)\n\ndef shutdown():\n    lib.olocus_shutdown()\n\ndef get_version():\n    version_ptr = lib.olocus_version()\n    return version_ptr.decode(\'utf-8\') if version_ptr else "unknown"\n\n# Utility functions\ndef sign_data(data, keypair):\n    if isinstance(data, str):\n        data = data.encode(\'utf-8\')\n    \n    data_array = (c_uint8 * len(data))(*data)\n    signature = (c_uint8 * 64)()\n    \n    lib.olocus_sign(keypair._ptr, data_array, len(data), signature)\n    return bytes(signature)\n\ndef verify_signature(data, signature, public_key):\n    if isinstance(data, str):\n        data = data.encode(\'utf-8\')\n    \n    if len(signature) != 64:\n        raise ValueError("Signature must be 64 bytes")\n    \n    if len(public_key) != 32:\n        raise ValueError("Public key must be 32 bytes")\n    \n    data_array = (c_uint8 * len(data))(*data)\n    sig_array = (c_uint8 * 64)(*signature)\n    key_array = (c_uint8 * 32)(*public_key)\n    \n    result = lib.olocus_verify(key_array, data_array, len(data), sig_array)\n    return result == 0\n\ndef hash_sha256(data):\n    if isinstance(data, str):\n        data = data.encode(\'utf-8\')\n    \n    data_array = (c_uint8 * len(data))(*data)\n    hash_bytes = (c_uint8 * 32)()\n    \n    lib.olocus_hash_sha256(data_array, len(data), hash_bytes)\n    return bytes(hash_bytes)\n\ndef random_bytes(length):\n    buffer = (c_uint8 * length)()\n    lib.olocus_random_bytes(buffer, length)\n    return bytes(buffer)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"go-cgo",children:"Go (CGO)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'// olocus.go\npackage olocus\n\n/*\n#cgo LDFLAGS: -L. -lolocus_ffi\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// Forward declarations for opaque types\ntypedef void* FFIConfig;\ntypedef void* FFIKeyPair;\ntypedef void* FFIBlock;\ntypedef void* FFIChain;\ntypedef void* FFIHasher;\ntypedef void* FFIAsyncHandle;\n\n// Structures\ntypedef struct {\n    uint8_t* data;\n    size_t len;\n    size_t capacity;\n} FFIByteBuffer;\n\ntypedef struct {\n    uint8_t encoding;\n    uint8_t compression;\n    uint8_t version;\n    uint8_t reserved;\n} FFIWireFormat;\n\n// Function declarations\nint olocus_init(void);\nint olocus_init_with_config(FFIConfig config);\nvoid olocus_shutdown(void);\nbool olocus_is_initialized(void);\n\nFFIConfig olocus_config_create(void);\nvoid olocus_config_destroy(FFIConfig config);\nvoid olocus_config_set_network_enabled(FFIConfig config, bool enabled);\n\nFFIKeyPair olocus_keypair_generate(void);\nFFIKeyPair olocus_keypair_from_bytes(const uint8_t* private_key);\nvoid olocus_keypair_destroy(FFIKeyPair keypair);\nvoid olocus_keypair_get_public_key(FFIKeyPair keypair, uint8_t* public_key);\nvoid olocus_keypair_get_private_key(FFIKeyPair keypair, uint8_t* private_key);\n\nFFIBlock olocus_block_create_genesis(\n    int64_t timestamp,\n    const uint8_t* payload,\n    size_t payload_len,\n    uint32_t payload_type,\n    const uint8_t* signing_key\n);\n\nFFIBlock olocus_block_create(\n    uint64_t index,\n    int64_t timestamp,\n    const uint8_t* previous_hash,\n    const uint8_t* payload,\n    size_t payload_len,\n    uint32_t payload_type,\n    const uint8_t* signing_key\n);\n\nvoid olocus_block_destroy(FFIBlock block);\nint olocus_block_verify(FFIBlock block);\nuint64_t olocus_block_get_index(FFIBlock block);\nint64_t olocus_block_get_timestamp(FFIBlock block);\nuint32_t olocus_block_get_payload_type(FFIBlock block);\nvoid olocus_block_get_hash(FFIBlock block, uint8_t* hash);\n\nFFIChain olocus_chain_create(void);\nvoid olocus_chain_destroy(FFIChain chain);\nint olocus_chain_add_block(FFIChain chain, FFIBlock block);\nsize_t olocus_chain_get_length(FFIChain chain);\nint olocus_chain_verify(FFIChain chain);\n\nFFIWireFormat olocus_wire_format_json(void);\nFFIByteBuffer olocus_block_to_wire_format(FFIBlock block, FFIWireFormat format);\nFFIBlock olocus_block_from_wire_format(const uint8_t* data, size_t data_len, FFIWireFormat format);\nvoid olocus_byte_buffer_free(FFIByteBuffer* buffer);\n\nvoid olocus_sign(FFIKeyPair keypair, const uint8_t* message, size_t message_len, uint8_t* signature);\nint olocus_verify(const uint8_t* public_key, const uint8_t* message, size_t message_len, const uint8_t* signature);\nvoid olocus_hash_sha256(const uint8_t* data, size_t data_len, uint8_t* hash);\nvoid olocus_random_bytes(uint8_t* buffer, size_t len);\n\nint olocus_get_last_error_code(void);\nchar* olocus_get_last_error_message(void);\nvoid olocus_clear_error(void);\nvoid olocus_free_string(char* str);\n\nconst char* olocus_version(void);\n*/\nimport "C"\n\nimport (\n    "errors"\n    "runtime"\n    "time"\n    "unsafe"\n)\n\n// Error types\ntype Error struct {\n    Code    int\n    Message string\n}\n\nfunc (e *Error) Error() string {\n    return e.Message\n}\n\n// Initialize the library\nfunc Initialize() error {\n    result := C.olocus_init()\n    if result != 0 {\n        return getLastError()\n    }\n    return nil\n}\n\n// Shutdown the library\nfunc Shutdown() {\n    C.olocus_shutdown()\n}\n\n// Check if library is initialized\nfunc IsInitialized() bool {\n    return bool(C.olocus_is_initialized())\n}\n\n// Get version information\nfunc Version() string {\n    cStr := C.olocus_version()\n    return C.GoString(cStr)\n}\n\n// KeyPair represents an Ed25519 key pair\ntype KeyPair struct {\n    ptr C.FFIKeyPair\n}\n\n// Generate a new key pair\nfunc GenerateKeyPair() (*KeyPair, error) {\n    ptr := C.olocus_keypair_generate()\n    if ptr == nil {\n        return nil, getLastError()\n    }\n    \n    kp := &KeyPair{ptr: ptr}\n    runtime.SetFinalizer(kp, (*KeyPair).destroy)\n    return kp, nil\n}\n\n// Create key pair from private key bytes\nfunc KeyPairFromBytes(privateKey []byte) (*KeyPair, error) {\n    if len(privateKey) != 32 {\n        return nil, errors.New("private key must be 32 bytes")\n    }\n    \n    ptr := C.olocus_keypair_from_bytes((*C.uint8_t)(unsafe.Pointer(&privateKey[0])))\n    if ptr == nil {\n        return nil, getLastError()\n    }\n    \n    kp := &KeyPair{ptr: ptr}\n    runtime.SetFinalizer(kp, (*KeyPair).destroy)\n    return kp, nil\n}\n\n// Get public key bytes\nfunc (kp *KeyPair) PublicKey() []byte {\n    publicKey := make([]byte, 32)\n    C.olocus_keypair_get_public_key(kp.ptr, (*C.uint8_t)(unsafe.Pointer(&publicKey[0])))\n    return publicKey\n}\n\n// Get private key bytes\nfunc (kp *KeyPair) PrivateKey() []byte {\n    privateKey := make([]byte, 32)\n    C.olocus_keypair_get_private_key(kp.ptr, (*C.uint8_t)(unsafe.Pointer(&privateKey[0])))\n    return privateKey\n}\n\n// Destroy the key pair (called by finalizer)\nfunc (kp *KeyPair) destroy() {\n    if kp.ptr != nil {\n        C.olocus_keypair_destroy(kp.ptr)\n        kp.ptr = nil\n    }\n}\n\n// Manually destroy the key pair\nfunc (kp *KeyPair) Destroy() {\n    kp.destroy()\n    runtime.SetFinalizer(kp, nil)\n}\n\n// Block represents a blockchain block\ntype Block struct {\n    ptr C.FFIBlock\n}\n\n// Create a genesis block\nfunc CreateGenesisBlock(payload []byte, payloadType uint32, signingKey []byte) (*Block, error) {\n    if len(signingKey) != 32 {\n        return nil, errors.New("signing key must be 32 bytes")\n    }\n    \n    timestamp := time.Now().UnixMilli()\n    \n    var payloadPtr *C.uint8_t\n    if len(payload) > 0 {\n        payloadPtr = (*C.uint8_t)(unsafe.Pointer(&payload[0]))\n    }\n    \n    ptr := C.olocus_block_create_genesis(\n        C.int64_t(timestamp),\n        payloadPtr,\n        C.size_t(len(payload)),\n        C.uint32_t(payloadType),\n        (*C.uint8_t)(unsafe.Pointer(&signingKey[0])),\n    )\n    \n    if ptr == nil {\n        return nil, getLastError()\n    }\n    \n    block := &Block{ptr: ptr}\n    runtime.SetFinalizer(block, (*Block).destroy)\n    return block, nil\n}\n\n// Create a regular block\nfunc CreateBlock(index uint64, previousHash, payload []byte, payloadType uint32, signingKey []byte) (*Block, error) {\n    if len(previousHash) != 32 {\n        return nil, errors.New("previous hash must be 32 bytes")\n    }\n    if len(signingKey) != 32 {\n        return nil, errors.New("signing key must be 32 bytes")\n    }\n    \n    timestamp := time.Now().UnixMilli()\n    \n    var payloadPtr *C.uint8_t\n    if len(payload) > 0 {\n        payloadPtr = (*C.uint8_t)(unsafe.Pointer(&payload[0]))\n    }\n    \n    ptr := C.olocus_block_create(\n        C.uint64_t(index),\n        C.int64_t(timestamp),\n        (*C.uint8_t)(unsafe.Pointer(&previousHash[0])),\n        payloadPtr,\n        C.size_t(len(payload)),\n        C.uint32_t(payloadType),\n        (*C.uint8_t)(unsafe.Pointer(&signingKey[0])),\n    )\n    \n    if ptr == nil {\n        return nil, getLastError()\n    }\n    \n    block := &Block{ptr: ptr}\n    runtime.SetFinalizer(block, (*Block).destroy)\n    return block, nil\n}\n\n// Get block index\nfunc (b *Block) Index() uint64 {\n    return uint64(C.olocus_block_get_index(b.ptr))\n}\n\n// Get block timestamp\nfunc (b *Block) Timestamp() time.Time {\n    timestamp := int64(C.olocus_block_get_timestamp(b.ptr))\n    return time.UnixMilli(timestamp)\n}\n\n// Get payload type\nfunc (b *Block) PayloadType() uint32 {\n    return uint32(C.olocus_block_get_payload_type(b.ptr))\n}\n\n// Get block hash\nfunc (b *Block) Hash() []byte {\n    hash := make([]byte, 32)\n    C.olocus_block_get_hash(b.ptr, (*C.uint8_t)(unsafe.Pointer(&hash[0])))\n    return hash\n}\n\n// Verify block\nfunc (b *Block) Verify() error {\n    result := C.olocus_block_verify(b.ptr)\n    if result != 0 {\n        return getLastError()\n    }\n    return nil\n}\n\n// Convert block to JSON\nfunc (b *Block) ToJSON() ([]byte, error) {\n    format := C.olocus_wire_format_json()\n    buffer := C.olocus_block_to_wire_format(b.ptr, format)\n    defer C.olocus_byte_buffer_free(&buffer)\n    \n    if buffer.data == nil {\n        return nil, getLastError()\n    }\n    \n    data := C.GoBytes(unsafe.Pointer(buffer.data), C.int(buffer.len))\n    return data, nil\n}\n\n// Destroy the block (called by finalizer)\nfunc (b *Block) destroy() {\n    if b.ptr != nil {\n        C.olocus_block_destroy(b.ptr)\n        b.ptr = nil\n    }\n}\n\n// Manually destroy the block\nfunc (b *Block) Destroy() {\n    b.destroy()\n    runtime.SetFinalizer(b, nil)\n}\n\n// Chain represents a blockchain\ntype Chain struct {\n    ptr C.FFIChain\n}\n\n// Create a new chain\nfunc CreateChain() (*Chain, error) {\n    ptr := C.olocus_chain_create()\n    if ptr == nil {\n        return nil, getLastError()\n    }\n    \n    chain := &Chain{ptr: ptr}\n    runtime.SetFinalizer(chain, (*Chain).destroy)\n    return chain, nil\n}\n\n// Add block to chain\nfunc (c *Chain) AddBlock(block *Block) error {\n    result := C.olocus_chain_add_block(c.ptr, block.ptr)\n    if result != 0 {\n        return getLastError()\n    }\n    return nil\n}\n\n// Get chain length\nfunc (c *Chain) Length() uint64 {\n    return uint64(C.olocus_chain_get_length(c.ptr))\n}\n\n// Verify chain\nfunc (c *Chain) Verify() error {\n    result := C.olocus_chain_verify(c.ptr)\n    if result != 0 {\n        return getLastError()\n    }\n    return nil\n}\n\n// Destroy the chain (called by finalizer)\nfunc (c *Chain) destroy() {\n    if c.ptr != nil {\n        C.olocus_chain_destroy(c.ptr)\n        c.ptr = nil\n    }\n}\n\n// Manually destroy the chain\nfunc (c *Chain) Destroy() {\n    c.destroy()\n    runtime.SetFinalizer(c, nil)\n}\n\n// Cryptographic functions\n\n// Sign data with key pair\nfunc Sign(kp *KeyPair, data []byte) []byte {\n    signature := make([]byte, 64)\n    \n    var dataPtr *C.uint8_t\n    if len(data) > 0 {\n        dataPtr = (*C.uint8_t)(unsafe.Pointer(&data[0]))\n    }\n    \n    C.olocus_sign(\n        kp.ptr,\n        dataPtr,\n        C.size_t(len(data)),\n        (*C.uint8_t)(unsafe.Pointer(&signature[0])),\n    )\n    \n    return signature\n}\n\n// Verify signature\nfunc Verify(publicKey, data, signature []byte) bool {\n    if len(publicKey) != 32 || len(signature) != 64 {\n        return false\n    }\n    \n    var dataPtr *C.uint8_t\n    if len(data) > 0 {\n        dataPtr = (*C.uint8_t)(unsafe.Pointer(&data[0]))\n    }\n    \n    result := C.olocus_verify(\n        (*C.uint8_t)(unsafe.Pointer(&publicKey[0])),\n        dataPtr,\n        C.size_t(len(data)),\n        (*C.uint8_t)(unsafe.Pointer(&signature[0])),\n    )\n    \n    return result == 0\n}\n\n// Hash data with SHA-256\nfunc HashSHA256(data []byte) []byte {\n    hash := make([]byte, 32)\n    \n    var dataPtr *C.uint8_t\n    if len(data) > 0 {\n        dataPtr = (*C.uint8_t)(unsafe.Pointer(&data[0]))\n    }\n    \n    C.olocus_hash_sha256(\n        dataPtr,\n        C.size_t(len(data)),\n        (*C.uint8_t)(unsafe.Pointer(&hash[0])),\n    )\n    \n    return hash\n}\n\n// Generate random bytes\nfunc RandomBytes(length int) []byte {\n    if length <= 0 {\n        return nil\n    }\n    \n    buffer := make([]byte, length)\n    C.olocus_random_bytes(\n        (*C.uint8_t)(unsafe.Pointer(&buffer[0])),\n        C.size_t(length),\n    )\n    \n    return buffer\n}\n\n// Utility functions\n\n// Get last error from the library\nfunc getLastError() error {\n    code := int(C.olocus_get_last_error_code())\n    \n    msgPtr := C.olocus_get_last_error_message()\n    var message string\n    if msgPtr != nil {\n        message = C.GoString(msgPtr)\n        C.olocus_free_string(msgPtr)\n    } else {\n        message = "Unknown error"\n    }\n    \n    return &Error{Code: code, Message: message}\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"platform-specific-considerations",children:"Platform-Specific Considerations"}),"\n",(0,i.jsx)(e.h3,{id:"ios-specific",children:"iOS Specific"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// iOS-specific functions\nvoid olocus_config_set_keychain_service(FFIConfig* config, const char* service);\nvoid olocus_config_set_keychain_access_group(FFIConfig* config, const char* access_group);\nvoid olocus_config_set_secure_enclave_enabled(FFIConfig* config, bool enabled);\nvoid olocus_config_set_biometric_auth_enabled(FFIConfig* config, bool enabled);\n\n// iOS Keychain integration\nint olocus_keychain_store_key(const char* identifier, const uint8_t* key, size_t key_len);\nint olocus_keychain_load_key(const char* identifier, uint8_t* key, size_t* key_len);\nint olocus_keychain_delete_key(const char* identifier);\nbool olocus_keychain_key_exists(const char* identifier);\n\n// Secure Enclave operations\nFFIKeyPair* olocus_secure_enclave_generate_key(const char* key_tag);\nint olocus_secure_enclave_sign(\n    const char* key_tag,\n    const uint8_t* data,\n    size_t data_len,\n    uint8_t* signature,\n    const char* auth_prompt\n);\n\n// App Attest integration\nint olocus_app_attest_generate_key(char** key_id);\nint olocus_app_attest_create_attestation(\n    const char* key_id,\n    const uint8_t* challenge,\n    size_t challenge_len,\n    uint8_t** attestation,\n    size_t* attestation_len\n);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"android-specific",children:"Android Specific"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Android-specific functions\nvoid olocus_config_set_keystore_alias(FFIConfig* config, const char* alias);\nvoid olocus_config_set_hardware_backed(FFIConfig* config, bool enabled);\nvoid olocus_config_set_strongbox_enabled(FFIConfig* config, bool enabled);\nvoid olocus_config_set_biometric_required(FFIConfig* config, bool required);\n\n// Android Keystore integration\nint olocus_android_keystore_generate_key(const char* alias);\nint olocus_android_keystore_sign(\n    const char* alias,\n    const uint8_t* data,\n    size_t data_len,\n    uint8_t* signature\n);\nint olocus_android_keystore_verify_key_properties(const char* alias);\nbool olocus_android_keystore_is_hardware_backed(const char* alias);\nbool olocus_android_keystore_is_strongbox_backed(const char* alias);\n\n// Play Integrity API integration\nint olocus_play_integrity_request_token(\n    const char* nonce,\n    char** integrity_token\n);\nint olocus_play_integrity_verify_token(\n    const char* token,\n    bool* is_valid\n);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"webassembly-specific",children:"WebAssembly Specific"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// WebAssembly-specific functions (when compiled with wasm feature)\nvoid olocus_config_set_memory_limit(FFIConfig* config, size_t limit_bytes);\nvoid olocus_config_set_wasm_optimization_level(FFIConfig* config, uint8_t level);\n\n// Web-specific storage\nint olocus_web_storage_set_item(const char* key, const uint8_t* data, size_t data_len);\nint olocus_web_storage_get_item(const char* key, uint8_t* data, size_t* data_len);\nint olocus_web_storage_remove_item(const char* key);\nvoid olocus_web_storage_clear(void);\n\n// Performance monitoring\nvoid olocus_wasm_get_memory_usage(size_t* used, size_t* total);\nuint32_t olocus_wasm_get_heap_size(void);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"threading-and-safety",children:"Threading and Safety"}),"\n",(0,i.jsx)(e.h3,{id:"thread-safety-rules",children:"Thread Safety Rules"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Initialization"}),": Only one thread should call ",(0,i.jsx)(e.code,{children:"olocus_init()"})," or ",(0,i.jsx)(e.code,{children:"olocus_shutdown()"})]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Error Context"}),": Error state is thread-local - each thread has its own error code and message"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Immutable Objects"}),": ",(0,i.jsx)(e.code,{children:"FFIBlock"})," objects are thread-safe for read operations once created"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Mutable Objects"}),": ",(0,i.jsx)(e.code,{children:"FFIChain"})," requires external synchronization for concurrent access"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cryptographic Operations"}),": All crypto functions are thread-safe"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Configuration"}),": ",(0,i.jsx)(e.code,{children:"FFIConfig"})," objects should not be shared between threads"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"synchronization-example-c",children:"Synchronization Example (C)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"#include <pthread.h>\n\ntypedef struct {\n    FFIChain* chain;\n    pthread_mutex_t mutex;\n    pthread_rwlock_t rwlock;\n} ThreadSafeChain;\n\nThreadSafeChain* thread_safe_chain_create() {\n    ThreadSafeChain* tsc = malloc(sizeof(ThreadSafeChain));\n    tsc->chain = olocus_chain_create();\n    pthread_mutex_init(&tsc->mutex, NULL);\n    pthread_rwlock_init(&tsc->rwlock, NULL);\n    return tsc;\n}\n\nint thread_safe_chain_add_block(ThreadSafeChain* tsc, const FFIBlock* block) {\n    pthread_rwlock_wrlock(&tsc->rwlock);\n    int result = olocus_chain_add_block(tsc->chain, block);\n    pthread_rwlock_unlock(&tsc->rwlock);\n    return result;\n}\n\nsize_t thread_safe_chain_get_length(ThreadSafeChain* tsc) {\n    pthread_rwlock_rdlock(&tsc->rwlock);\n    size_t length = olocus_chain_get_length(tsc->chain);\n    pthread_rwlock_unlock(&tsc->rwlock);\n    return length;\n}\n\nvoid thread_safe_chain_destroy(ThreadSafeChain* tsc) {\n    pthread_rwlock_destroy(&tsc->rwlock);\n    pthread_mutex_destroy(&tsc->mutex);\n    olocus_chain_destroy(tsc->chain);\n    free(tsc);\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"memory-management-best-practices",children:"Memory Management Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"raii-pattern-c",children:"RAII Pattern (C++)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'// olocus_raii.hpp\n#include "olocus_ffi.h"\n#include <memory>\n#include <stdexcept>\n\nnamespace olocus {\n\nclass KeyPair {\npublic:\n    KeyPair() : ptr_(olocus_keypair_generate()) {\n        if (!ptr_) {\n            throw std::runtime_error("Failed to generate keypair");\n        }\n    }\n    \n    explicit KeyPair(const std::array<uint8_t, 32>& private_key)\n        : ptr_(olocus_keypair_from_bytes(private_key.data())) {\n        if (!ptr_) {\n            throw std::runtime_error("Failed to create keypair from bytes");\n        }\n    }\n    \n    ~KeyPair() {\n        if (ptr_) {\n            olocus_keypair_destroy(ptr_);\n        }\n    }\n    \n    // Non-copyable, movable\n    KeyPair(const KeyPair&) = delete;\n    KeyPair& operator=(const KeyPair&) = delete;\n    \n    KeyPair(KeyPair&& other) noexcept : ptr_(other.ptr_) {\n        other.ptr_ = nullptr;\n    }\n    \n    KeyPair& operator=(KeyPair&& other) noexcept {\n        if (this != &other) {\n            if (ptr_) {\n                olocus_keypair_destroy(ptr_);\n            }\n            ptr_ = other.ptr_;\n            other.ptr_ = nullptr;\n        }\n        return *this;\n    }\n    \n    std::array<uint8_t, 32> public_key() const {\n        std::array<uint8_t, 32> key;\n        olocus_keypair_get_public_key(ptr_, key.data());\n        return key;\n    }\n    \n    std::array<uint8_t, 32> private_key() const {\n        std::array<uint8_t, 32> key;\n        olocus_keypair_get_private_key(ptr_, key.data());\n        return key;\n    }\n    \n    FFIKeyPair* get() const { return ptr_; }\n    \nprivate:\n    FFIKeyPair* ptr_;\n};\n\nclass Block {\npublic:\n    static Block create_genesis(const std::vector<uint8_t>& payload,\n                              uint32_t payload_type,\n                              const std::array<uint8_t, 32>& signing_key) {\n        auto ptr = olocus_block_create_genesis(\n            std::chrono::duration_cast<std::chrono::milliseconds>(\n                std::chrono::system_clock::now().time_since_epoch()\n            ).count(),\n            payload.data(),\n            payload.size(),\n            payload_type,\n            signing_key.data()\n        );\n        \n        if (!ptr) {\n            throw std::runtime_error("Failed to create genesis block");\n        }\n        \n        return Block(ptr);\n    }\n    \n    ~Block() {\n        if (ptr_) {\n            olocus_block_destroy(ptr_);\n        }\n    }\n    \n    Block(const Block&) = delete;\n    Block& operator=(const Block&) = delete;\n    \n    Block(Block&& other) noexcept : ptr_(other.ptr_) {\n        other.ptr_ = nullptr;\n    }\n    \n    Block& operator=(Block&& other) noexcept {\n        if (this != &other) {\n            if (ptr_) {\n                olocus_block_destroy(ptr_);\n            }\n            ptr_ = other.ptr_;\n            other.ptr_ = nullptr;\n        }\n        return *this;\n    }\n    \n    uint64_t index() const {\n        return olocus_block_get_index(ptr_);\n    }\n    \n    int64_t timestamp() const {\n        return olocus_block_get_timestamp(ptr_);\n    }\n    \n    uint32_t payload_type() const {\n        return olocus_block_get_payload_type(ptr_);\n    }\n    \n    std::array<uint8_t, 32> hash() const {\n        std::array<uint8_t, 32> h;\n        olocus_block_get_hash(ptr_, h.data());\n        return h;\n    }\n    \n    void verify() const {\n        int result = olocus_block_verify(ptr_);\n        if (result != 0) {\n            auto msg = olocus_get_last_error_message();\n            std::string error_msg = msg ? msg : "Unknown error";\n            if (msg) olocus_free_string(msg);\n            throw std::runtime_error(error_msg);\n        }\n    }\n    \n    FFIBlock* get() const { return ptr_; }\n    \nprivate:\n    explicit Block(FFIBlock* ptr) : ptr_(ptr) {}\n    FFIBlock* ptr_;\n};\n\nclass Chain {\npublic:\n    Chain() : ptr_(olocus_chain_create()) {\n        if (!ptr_) {\n            throw std::runtime_error("Failed to create chain");\n        }\n    }\n    \n    ~Chain() {\n        if (ptr_) {\n            olocus_chain_destroy(ptr_);\n        }\n    }\n    \n    Chain(const Chain&) = delete;\n    Chain& operator=(const Chain&) = delete;\n    \n    Chain(Chain&& other) noexcept : ptr_(other.ptr_) {\n        other.ptr_ = nullptr;\n    }\n    \n    Chain& operator=(Chain&& other) noexcept {\n        if (this != &other) {\n            if (ptr_) {\n                olocus_chain_destroy(ptr_);\n            }\n            ptr_ = other.ptr_;\n            other.ptr_ = nullptr;\n        }\n        return *this;\n    }\n    \n    void add_block(const Block& block) {\n        int result = olocus_chain_add_block(ptr_, block.get());\n        if (result != 0) {\n            auto msg = olocus_get_last_error_message();\n            std::string error_msg = msg ? msg : "Unknown error";\n            if (msg) olocus_free_string(msg);\n            throw std::runtime_error(error_msg);\n        }\n    }\n    \n    size_t length() const {\n        return olocus_chain_get_length(ptr_);\n    }\n    \n    void verify() const {\n        int result = olocus_chain_verify(ptr_);\n        if (result != 0) {\n            auto msg = olocus_get_last_error_message();\n            std::string error_msg = msg ? msg : "Unknown error";\n            if (msg) olocus_free_string(msg);\n            throw std::runtime_error(error_msg);\n        }\n    }\n    \nprivate:\n    FFIChain* ptr_;\n};\n\n} // namespace olocus\n'})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"error-codes-reference",children:"Error Codes Reference"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Core errors (0-99)\n#define OLOCUS_SUCCESS                    0\n#define OLOCUS_VERSION_MISMATCH          1\n#define OLOCUS_BROKEN_CHAIN              2\n#define OLOCUS_INVALID_INDEX             3\n#define OLOCUS_TIMESTAMP_REGRESSION      4\n#define OLOCUS_PAYLOAD_MISMATCH          5\n#define OLOCUS_INVALID_SIGNATURE         6\n#define OLOCUS_MALFORMED_BLOCK           7\n#define OLOCUS_UNKNOWN_PAYLOAD_TYPE      8\n#define OLOCUS_PAYLOAD_TOO_LARGE         9\n#define OLOCUS_TIMESTAMP_TOO_FUTURE     10\n#define OLOCUS_TIMESTAMP_TOO_OLD        11\n#define OLOCUS_FORK_TOO_DEEP            12\n\n// FFI errors (100-199)\n#define OLOCUS_NULL_POINTER            100\n#define OLOCUS_INVALID_UTF8            101\n#define OLOCUS_SERIALIZATION_ERROR     102\n#define OLOCUS_DESERIALIZATION_ERROR   103\n#define OLOCUS_INVALID_ARGUMENT        104\n#define OLOCUS_OUT_OF_MEMORY          105\n#define OLOCUS_NOT_INITIALIZED        106\n#define OLOCUS_ALREADY_INITIALIZED    107\n#define OLOCUS_OPERATION_FAILED       108\n#define OLOCUS_BUFFER_TOO_SMALL       109\n#define OLOCUS_INVALID_HANDLE         110\n#define OLOCUS_CRYPTO_ERROR           115\n#define OLOCUS_INVALID_KEY            116\n\n// Platform errors (200-299)\n#define OLOCUS_KEYCHAIN_ERROR         200\n#define OLOCUS_KEYSTORE_ERROR         201\n#define OLOCUS_PLATFORM_NOT_SUPPORTED 202\n"})}),"\n",(0,i.jsx)(e.h3,{id:"comprehensive-error-handling-c",children:"Comprehensive Error Handling (C)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'// error_handling.h\n#include "olocus_ffi.h"\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int code;\n    char message[256];\n    char details[512];\n} olocus_error_t;\n\n// Get comprehensive error information\nstatic inline olocus_error_t olocus_get_error_info() {\n    olocus_error_t error;\n    error.code = olocus_get_last_error_code();\n    \n    char* msg = olocus_get_last_error_message();\n    if (msg) {\n        strncpy(error.message, msg, sizeof(error.message) - 1);\n        error.message[sizeof(error.message) - 1] = \'\\0\';\n        olocus_free_string(msg);\n    } else {\n        strcpy(error.message, "Unknown error");\n    }\n    \n    char* details = olocus_get_last_error_details();\n    if (details) {\n        strncpy(error.details, details, sizeof(error.details) - 1);\n        error.details[sizeof(error.details) - 1] = \'\\0\';\n        olocus_free_string(details);\n    } else {\n        strcpy(error.details, "No additional details");\n    }\n    \n    return error;\n}\n\n// Check if operation succeeded\n#define OLOCUS_CHECK(expr) do { \\\n    int _result = (expr); \\\n    if (_result != 0) { \\\n        olocus_error_t _error = olocus_get_error_info(); \\\n        fprintf(stderr, "Olocus error %d in %s:%d: %s\\n", \\\n                _error.code, __FILE__, __LINE__, _error.message); \\\n        return _result; \\\n    } \\\n} while(0)\n\n// Check with custom error handling\n#define OLOCUS_CHECK_GOTO(expr, label) do { \\\n    int _result = (expr); \\\n    if (_result != 0) { \\\n        error = olocus_get_error_info(); \\\n        goto label; \\\n    } \\\n} while(0)\n\n// Example usage\nint example_with_error_handling() {\n    FFIConfig* config = NULL;\n    FFIKeyPair* keypair = NULL;\n    FFIBlock* block = NULL;\n    olocus_error_t error = {0};\n    int result = 0;\n    \n    // Create configuration\n    config = olocus_config_create();\n    if (!config) {\n        error = olocus_get_error_info();\n        fprintf(stderr, "Failed to create config: %s\\n", error.message);\n        result = -1;\n        goto cleanup;\n    }\n    \n    // Initialize library\n    OLOCUS_CHECK_GOTO(olocus_init_with_config(config), cleanup);\n    \n    // Generate keypair\n    keypair = olocus_keypair_generate();\n    if (!keypair) {\n        error = olocus_get_error_info();\n        fprintf(stderr, "Failed to generate keypair: %s\\n", error.message);\n        result = -1;\n        goto cleanup;\n    }\n    \n    // Create block\n    uint8_t payload[] = "Hello, world!";\n    uint8_t private_key[32];\n    olocus_keypair_get_private_key(keypair, private_key);\n    \n    block = olocus_block_create_genesis(\n        1234567890000LL,\n        payload,\n        sizeof(payload) - 1,\n        0,\n        private_key\n    );\n    \n    if (!block) {\n        error = olocus_get_error_info();\n        fprintf(stderr, "Failed to create block: %s\\n", error.message);\n        fprintf(stderr, "Details: %s\\n", error.details);\n        result = -1;\n        goto cleanup;\n    }\n    \n    // Verify block\n    OLOCUS_CHECK_GOTO(olocus_block_verify(block), cleanup);\n    \n    printf("Success: Block created and verified\\n");\n    \ncleanup:\n    // Clean up resources\n    if (block) olocus_block_destroy(block);\n    if (keypair) olocus_keypair_destroy(keypair);\n    if (config) olocus_config_destroy(config);\n    \n    // Clear sensitive data\n    memset(&private_key, 0, sizeof(private_key));\n    \n    if (result == 0) {\n        olocus_shutdown();\n    }\n    \n    return result;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Batch block verification\nint verify_blocks_batch(const FFIBlock* const* blocks, size_t block_count) {\n    for (size_t i = 0; i < block_count; i++) {\n        int result = olocus_block_verify(blocks[i]);\n        if (result != 0) {\n            return result;  // Return error code of first failure\n        }\n    }\n    return 0;\n}\n\n// Parallel verification using async operations\ntypedef struct {\n    const FFIBlock* block;\n    FFIAsyncHandle* handle;\n    int result;\n} async_verify_context_t;\n\nvoid verify_callback(void* user_data, int result, const void* data, size_t len) {\n    async_verify_context_t* ctx = (async_verify_context_t*)user_data;\n    ctx->result = result;\n}\n\nint verify_blocks_parallel(const FFIBlock* const* blocks, size_t block_count) {\n    async_verify_context_t* contexts = malloc(sizeof(async_verify_context_t) * block_count);\n    \n    // Start all verifications\n    for (size_t i = 0; i < block_count; i++) {\n        contexts[i].block = blocks[i];\n        contexts[i].handle = olocus_async_create(verify_callback, &contexts[i]);\n        contexts[i].result = -1;\n        \n        olocus_async_verify_block(contexts[i].handle, blocks[i]);\n    }\n    \n    // Wait for all to complete\n    int overall_result = 0;\n    for (size_t i = 0; i < block_count; i++) {\n        olocus_async_wait(contexts[i].handle);\n        \n        if (contexts[i].result != 0 && overall_result == 0) {\n            overall_result = contexts[i].result;\n        }\n        \n        olocus_async_destroy(contexts[i].handle);\n    }\n    \n    free(contexts);\n    return overall_result;\n}\n"})}),"\n",(0,i.jsx)(e.h3,{id:"memory-pool-allocation",children:"Memory Pool Allocation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"// Simple memory pool for frequent allocations\ntypedef struct {\n    uint8_t* pool;\n    size_t pool_size;\n    size_t offset;\n    size_t alignment;\n} memory_pool_t;\n\nmemory_pool_t* memory_pool_create(size_t size, size_t alignment) {\n    memory_pool_t* pool = malloc(sizeof(memory_pool_t));\n    pool->pool = aligned_alloc(alignment, size);\n    pool->pool_size = size;\n    pool->offset = 0;\n    pool->alignment = alignment;\n    return pool;\n}\n\nvoid* memory_pool_alloc(memory_pool_t* pool, size_t size) {\n    // Align size\n    size = (size + pool->alignment - 1) & ~(pool->alignment - 1);\n    \n    if (pool->offset + size > pool->pool_size) {\n        return NULL;  // Pool exhausted\n    }\n    \n    void* ptr = pool->pool + pool->offset;\n    pool->offset += size;\n    return ptr;\n}\n\nvoid memory_pool_reset(memory_pool_t* pool) {\n    pool->offset = 0;\n}\n\nvoid memory_pool_destroy(memory_pool_t* pool) {\n    free(pool->pool);\n    free(pool);\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"testing-and-debugging",children:"Testing and Debugging"}),"\n",(0,i.jsx)(e.h3,{id:"unit-test-framework-integration",children:"Unit Test Framework Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'// test_olocus.c - Example with Unity test framework\n#include "unity.h"\n#include "olocus_ffi.h"\n\nvoid setUp(void) {\n    int result = olocus_init();\n    TEST_ASSERT_EQUAL(0, result);\n}\n\nvoid tearDown(void) {\n    olocus_shutdown();\n}\n\nvoid test_keypair_generation(void) {\n    FFIKeyPair* keypair = olocus_keypair_generate();\n    TEST_ASSERT_NOT_NULL(keypair);\n    \n    uint8_t public_key[32];\n    uint8_t private_key[32];\n    \n    olocus_keypair_get_public_key(keypair, public_key);\n    olocus_keypair_get_private_key(keypair, private_key);\n    \n    // Test that keys are not all zeros\n    bool public_zero = true, private_zero = true;\n    for (int i = 0; i < 32; i++) {\n        if (public_key[i] != 0) public_zero = false;\n        if (private_key[i] != 0) private_zero = false;\n    }\n    \n    TEST_ASSERT_FALSE(public_zero);\n    TEST_ASSERT_FALSE(private_zero);\n    \n    olocus_keypair_destroy(keypair);\n}\n\nvoid test_block_creation_and_verification(void) {\n    FFIKeyPair* keypair = olocus_keypair_generate();\n    TEST_ASSERT_NOT_NULL(keypair);\n    \n    uint8_t private_key[32];\n    olocus_keypair_get_private_key(keypair, private_key);\n    \n    const char* payload = "Test payload";\n    FFIBlock* block = olocus_block_create_genesis(\n        1234567890000LL,\n        (const uint8_t*)payload,\n        strlen(payload),\n        0,\n        private_key\n    );\n    \n    TEST_ASSERT_NOT_NULL(block);\n    \n    // Test block properties\n    TEST_ASSERT_EQUAL(0, olocus_block_get_index(block));\n    TEST_ASSERT_EQUAL(1234567890000LL, olocus_block_get_timestamp(block));\n    TEST_ASSERT_EQUAL(0, olocus_block_get_payload_type(block));\n    \n    // Verify block\n    int result = olocus_block_verify(block);\n    TEST_ASSERT_EQUAL(0, result);\n    \n    olocus_block_destroy(block);\n    olocus_keypair_destroy(keypair);\n}\n\nvoid test_chain_operations(void) {\n    FFIChain* chain = olocus_chain_create();\n    TEST_ASSERT_NOT_NULL(chain);\n    \n    TEST_ASSERT_TRUE(olocus_chain_is_empty(chain));\n    TEST_ASSERT_EQUAL(0, olocus_chain_get_length(chain));\n    \n    // Create and add genesis block\n    FFIKeyPair* keypair = olocus_keypair_generate();\n    uint8_t private_key[32];\n    olocus_keypair_get_private_key(keypair, private_key);\n    \n    FFIBlock* genesis = olocus_block_create_genesis(\n        1000000000000LL,\n        (const uint8_t*)"Genesis",\n        7,\n        0,\n        private_key\n    );\n    \n    int result = olocus_chain_add_block(chain, genesis);\n    TEST_ASSERT_EQUAL(0, result);\n    \n    TEST_ASSERT_FALSE(olocus_chain_is_empty(chain));\n    TEST_ASSERT_EQUAL(1, olocus_chain_get_length(chain));\n    \n    // Verify chain\n    result = olocus_chain_verify(chain);\n    TEST_ASSERT_EQUAL(0, result);\n    \n    olocus_block_destroy(genesis);\n    olocus_keypair_destroy(keypair);\n    olocus_chain_destroy(chain);\n}\n\nint main(void) {\n    UNITY_BEGIN();\n    \n    RUN_TEST(test_keypair_generation);\n    RUN_TEST(test_block_creation_and_verification);\n    RUN_TEST(test_chain_operations);\n    \n    return UNITY_END();\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,i.jsx)(e.h3,{id:"security",children:"Security"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Always validate inputs"})," before passing to FFI functions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use secure memory functions"})," for sensitive data"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Clear sensitive data"})," after use (private keys, etc.)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Check return codes"})," from all operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use platform-specific secure storage"})," when available"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"performance",children:"Performance"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Batch operations"})," when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use async operations"})," for heavy workloads"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pool allocations"})," for frequent memory operations"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Cache frequently accessed data"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Profile and optimize"})," hot paths"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"memory-management-1",children:"Memory Management"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use RAII patterns"})," in C++"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement proper finalizers"})," in garbage-collected languages"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Track object lifecycles"})," carefully"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use reference counting"})," for shared objects"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Test for memory leaks"})," regularly"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"error-handling-1",children:"Error Handling"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Check all return codes"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Provide meaningful error messages"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use appropriate error handling patterns"})," for each language"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Log errors"})," for debugging"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Clean up resources"})," on error paths"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"cross-platform",children:"Cross-Platform"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Test on all target platforms"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use conditional compilation"})," for platform-specific features"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Provide fallbacks"})," for unsupported features"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Document platform requirements"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Use consistent calling conventions"})}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(_,{...n})}):_(n)}}}]);