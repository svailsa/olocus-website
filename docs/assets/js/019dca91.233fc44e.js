"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[7715],{5755:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/infrastructure/discovery","title":"Peer Discovery Mechanisms","description":"The Peer Discovery module provides multiple mechanisms for discovering and connecting to other Olocus Protocol nodes in distributed networks. Each discovery method is optimized for different network topologies, deployment scenarios, and privacy requirements.","source":"@site/docs/extensions/infrastructure/discovery.md","sourceDirName":"extensions/infrastructure","slug":"/extensions/infrastructure/discovery","permalink":"/docs/extensions/infrastructure/discovery","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/infrastructure/discovery.md","tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":3,"frontMatter":{"id":"discovery","title":"Peer Discovery Mechanisms","sidebar_position":3}}');var t=s(4848),o=s(8453);const i={id:"discovery",title:"Peer Discovery Mechanisms",sidebar_position:3},a="Peer Discovery Mechanisms",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Discovery Trait Interface",id:"discovery-trait-interface",level:2},{value:"Core Discovery Trait",id:"core-discovery-trait",level:3},{value:"DHT (Kademlia) Discovery",id:"dht-kademlia-discovery",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"mDNS Discovery",id:"mdns-discovery",level:2},{value:"Implementation",id:"implementation-1",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"Gossip Discovery",id:"gossip-discovery",level:2},{value:"Implementation",id:"implementation-2",level:3},{value:"Usage Example",id:"usage-example-2",level:3},{value:"Bootstrap Discovery",id:"bootstrap-discovery",level:2},{value:"Implementation",id:"implementation-3",level:3},{value:"Usage Example",id:"usage-example-3",level:3},{value:"DNS Discovery",id:"dns-discovery",level:2},{value:"Implementation",id:"implementation-4",level:3},{value:"Usage Example",id:"usage-example-4",level:3},{value:"Multi-Mechanism Discovery",id:"multi-mechanism-discovery",level:2},{value:"Implementation",id:"implementation-5",level:3},{value:"Usage Example",id:"usage-example-5",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Error Handling",id:"error-handling",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"peer-discovery-mechanisms",children:"Peer Discovery Mechanisms"})}),"\n",(0,t.jsx)(n.p,{children:"The Peer Discovery module provides multiple mechanisms for discovering and connecting to other Olocus Protocol nodes in distributed networks. Each discovery method is optimized for different network topologies, deployment scenarios, and privacy requirements."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Discovery mechanisms enable nodes to find peers and build network topology:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DHT (Kademlia)"}),": Distributed hash table for large-scale networks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"mDNS"}),": Local network discovery for LAN environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gossip"}),": Epidemic-style peer propagation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bootstrap"}),": Seed node discovery for network entry"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DNS"}),": DNS-based peer discovery with SRV records"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::*;\n\n// Configure discovery mechanisms\nlet discovery_config = DiscoveryConfig {\n    mechanisms: vec![\n        DiscoveryMechanism::DHT {\n            bootstrap_nodes: vec![\n                "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ".parse()?,\n                "/ip4/104.236.179.241/tcp/4001/p2p/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM".parse()?,\n            ],\n            k_bucket_size: 20,\n            replication_factor: 3,\n            query_timeout: Duration::from_secs(10),\n        },\n        DiscoveryMechanism::MDNS {\n            service_name: "_olocus._tcp.local".to_string(),\n            interface: None,\n            ttl: Duration::from_secs(120),\n        },\n        DiscoveryMechanism::Gossip {\n            fanout: 3,\n            gossip_interval: Duration::from_secs(30),\n            max_peers: 50,\n        },\n    ],\n    peer_limits: PeerLimits {\n        max_peers: 100,\n        max_inbound: 50,\n        max_outbound: 50,\n    },\n};\n\nlet discovery = PeerDiscovery::new(discovery_config).await?;\n'})}),"\n",(0,t.jsx)(n.h2,{id:"discovery-trait-interface",children:"Discovery Trait Interface"}),"\n",(0,t.jsx)(n.h3,{id:"core-discovery-trait",children:"Core Discovery Trait"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use olocus_network::discovery::traits::*;\nuse olocus_core::*;\n\n#[async_trait::async_trait]\npub trait DiscoveryMechanism: Send + Sync {\n    async fn start(&mut self, local_peer_id: PeerId) -> Result<()>;\n    async fn stop(&mut self) -> Result<()>;\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>>;\n    async fn announce_self(&mut self, peer_info: PeerInfo) -> Result<()>;\n    \n    fn mechanism_type(&self) -> DiscoveryType;\n    fn supports_content_routing(&self) -> bool;\n    fn supports_peer_routing(&self) -> bool;\n}\n\n#[async_trait::async_trait]\npub trait PeerStore: Send + Sync {\n    async fn add_peer(&mut self, peer: PeerInfo) -> Result<()>;\n    async fn remove_peer(&mut self, peer_id: &PeerId) -> Result<bool>;\n    async fn get_peer(&self, peer_id: &PeerId) -> Result<Option<PeerInfo>>;\n    async fn get_peers(&self) -> Result<Vec<PeerInfo>>;\n    async fn get_closest_peers(&self, key: &[u8], count: usize) -> Result<Vec<PeerInfo>>;\n    async fn update_peer_seen(&mut self, peer_id: &PeerId) -> Result<()>;\n}\n\n#[derive(Debug, Clone)]\npub struct PeerInfo {\n    pub peer_id: PeerId,\n    pub addresses: Vec<Multiaddr>,\n    pub protocols: Vec<String>,\n    pub last_seen: SystemTime,\n    pub connection_status: ConnectionStatus,\n    pub reputation_score: f64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DiscoveryType {\n    DHT,\n    MDNS,\n    Gossip,\n    Bootstrap,\n    DNS,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ConnectionStatus {\n    Connected,\n    Disconnected,\n    Connecting,\n    Failed,\n    Unknown,\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dht-kademlia-discovery",children:"DHT (Kademlia) Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Distributed Hash Table provides scalable peer discovery for large networks:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::dht::*;\nuse libp2p_kad::*;\n\n#[derive(Debug)]\npub struct DHTDiscovery {\n    config: DHTConfig,\n    kademlia: Kademlia<MemoryStore>,\n    bootstrap_nodes: Vec<PeerId>,\n}\n\n#[derive(Debug, Clone)]\npub struct DHTConfig {\n    pub bootstrap_nodes: Vec<String>,\n    pub k_bucket_size: usize,\n    pub replication_factor: usize,\n    pub query_timeout: Duration,\n    pub republish_interval: Duration,\n    pub provider_publication_interval: Duration,\n    pub provider_record_ttl: Duration,\n}\n\nimpl Default for DHTConfig {\n    fn default() -> Self {\n        Self {\n            bootstrap_nodes: vec![],\n            k_bucket_size: 20,\n            replication_factor: 3,\n            query_timeout: Duration::from_secs(10),\n            republish_interval: Duration::from_secs(86400), // 24 hours\n            provider_publication_interval: Duration::from_secs(43200), // 12 hours\n            provider_record_ttl: Duration::from_secs(86400), // 24 hours\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl DiscoveryMechanism for DHTDiscovery {\n    async fn start(&mut self, local_peer_id: PeerId) -> Result<()> {\n        // Bootstrap from known nodes\n        for bootstrap_addr in &self.config.bootstrap_nodes {\n            let multiaddr: Multiaddr = bootstrap_addr.parse()?;\n            self.kademlia.add_address(&local_peer_id, multiaddr);\n        }\n        \n        // Start bootstrap process\n        if let Ok(_query_id) = self.kademlia.bootstrap() {\n            // Bootstrap initiated successfully\n        }\n        \n        Ok(())\n    }\n\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>> {\n        let mut peers = Vec::new();\n        \n        // Get closest peers to random keys\n        let random_key = libp2p_kad::Key::new(&rand::random::<[u8; 32]>());\n        if let Ok(_query_id) = self.kademlia.get_closest_peers(random_key) {\n            // Query initiated, results will come via events\n        }\n        \n        // Convert Kademlia entries to PeerInfo\n        for bucket in self.kademlia.kbuckets() {\n            for entry in bucket.iter() {\n                let peer_info = PeerInfo {\n                    peer_id: *entry.node.key.preimage(),\n                    addresses: entry.node.value.clone().into_vec(),\n                    protocols: vec!["olocus/1.0.0".to_string()],\n                    last_seen: SystemTime::now(),\n                    connection_status: ConnectionStatus::Unknown,\n                    reputation_score: 1.0,\n                };\n                peers.push(peer_info);\n            }\n        }\n        \n        Ok(peers)\n    }\n\n    async fn announce_self(&mut self, peer_info: PeerInfo) -> Result<()> {\n        // Start providing our peer ID\n        if let Ok(_query_id) = self.kademlia.start_providing(\n            libp2p_kad::Key::new(&peer_info.peer_id.to_bytes())\n        ) {\n            // Announcement initiated\n        }\n        \n        Ok(())\n    }\n\n    fn mechanism_type(&self) -> DiscoveryType {\n        DiscoveryType::DHT\n    }\n\n    fn supports_content_routing(&self) -> bool {\n        true\n    }\n\n    fn supports_peer_routing(&self) -> bool {\n        true\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::dht::*;\n\nlet config = DHTConfig {\n    bootstrap_nodes: vec![\n        "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ".to_string(),\n        "/ip4/104.236.179.241/tcp/4001/p2p/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM".to_string(),\n    ],\n    k_bucket_size: 20,\n    replication_factor: 3,\n    query_timeout: Duration::from_secs(15),\n    ..Default::default()\n};\n\nlet mut dht = DHTDiscovery::new(config);\ndht.start(local_peer_id).await?;\n\n// Announce ourselves\nlet our_info = PeerInfo {\n    peer_id: local_peer_id,\n    addresses: vec!["/ip4/192.168.1.100/tcp/8000".parse()?],\n    protocols: vec!["olocus/1.0.0".to_string()],\n    last_seen: SystemTime::now(),\n    connection_status: ConnectionStatus::Connected,\n    reputation_score: 1.0,\n};\n\ndht.announce_self(our_info).await?;\n\n// Discover other peers\nlet peers = dht.discover_peers().await?;\nprintln!("Found {} peers via DHT", peers.len());\n'})}),"\n",(0,t.jsx)(n.h2,{id:"mdns-discovery",children:"mDNS Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Multicast DNS enables zero-configuration discovery on local networks:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::mdns::*;\nuse mdns::*;\n\n#[derive(Debug)]\npub struct MDNSDiscovery {\n    config: MDNSConfig,\n    service: Option<Service>,\n    discovered_peers: Arc<RwLock<HashMap<PeerId, PeerInfo>>>,\n}\n\n#[derive(Debug, Clone)]\npub struct MDNSConfig {\n    pub service_name: String,\n    pub service_type: String,\n    pub domain: String,\n    pub port: u16,\n    pub interface: Option<String>,\n    pub ttl: Duration,\n}\n\nimpl Default for MDNSConfig {\n    fn default() -> Self {\n        Self {\n            service_name: "olocus-node".to_string(),\n            service_type: "_olocus._tcp".to_string(),\n            domain: "local".to_string(),\n            port: 8000,\n            interface: None,\n            ttl: Duration::from_secs(120),\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl DiscoveryMechanism for MDNSDiscovery {\n    async fn start(&mut self, local_peer_id: PeerId) -> Result<()> {\n        let service_name = format!("{}.{}.{}", \n            local_peer_id.to_base58()[..8], // Truncated peer ID\n            self.config.service_type, \n            self.config.domain\n        );\n        \n        // Start mDNS service\n        let service = Service::new(&service_name, &self.config.service_type, self.config.port)?\n            .with_txt_record("peer_id", &local_peer_id.to_base58())?\n            .with_txt_record("protocol", "olocus/1.0.0")?\n            .with_ttl(self.config.ttl.as_secs() as u32);\n        \n        self.service = Some(service);\n        \n        // Start discovery listener\n        let discovered_peers = self.discovered_peers.clone();\n        tokio::spawn(async move {\n            if let Ok(receiver) = mdns::discover(&self.config.service_type) {\n                while let Ok(response) = receiver.recv().await {\n                    if let Some(peer_info) = Self::parse_mdns_response(response) {\n                        let mut peers = discovered_peers.write().await;\n                        peers.insert(peer_info.peer_id, peer_info);\n                    }\n                }\n            }\n        });\n        \n        Ok(())\n    }\n\n    async fn stop(&mut self) -> Result<()> {\n        if let Some(service) = self.service.take() {\n            service.unregister()?;\n        }\n        Ok(())\n    }\n\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>> {\n        let peers = self.discovered_peers.read().await;\n        Ok(peers.values().cloned().collect())\n    }\n\n    async fn announce_self(&mut self, peer_info: PeerInfo) -> Result<()> {\n        // mDNS announcement happens automatically when service is registered\n        Ok(())\n    }\n\n    fn mechanism_type(&self) -> DiscoveryType {\n        DiscoveryType::MDNS\n    }\n\n    fn supports_content_routing(&self) -> bool {\n        false\n    }\n\n    fn supports_peer_routing(&self) -> bool {\n        true\n    }\n}\n\nimpl MDNSDiscovery {\n    fn parse_mdns_response(response: mdns::Response) -> Option<PeerInfo> {\n        let peer_id_str = response.txt_records.get("peer_id")?;\n        let peer_id = PeerId::from_base58(peer_id_str).ok()?;\n        \n        let address = format!("/ip4/{}/tcp/{}", \n            response.ip_addr, \n            response.port\n        ).parse().ok()?;\n        \n        Some(PeerInfo {\n            peer_id,\n            addresses: vec![address],\n            protocols: vec!["olocus/1.0.0".to_string()],\n            last_seen: SystemTime::now(),\n            connection_status: ConnectionStatus::Unknown,\n            reputation_score: 1.0,\n        })\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::mdns::*;\n\nlet config = MDNSConfig {\n    service_name: "my-olocus-node".to_string(),\n    service_type: "_olocus._tcp".to_string(),\n    port: 8000,\n    ttl: Duration::from_secs(300),\n    ..Default::default()\n};\n\nlet mut mdns = MDNSDiscovery::new(config);\nmdns.start(local_peer_id).await?;\n\n// Wait for discovery\ntokio::time::sleep(Duration::from_secs(5)).await;\n\nlet peers = mdns.discover_peers().await?;\nprintln!("Found {} peers via mDNS", peers.len());\n\n// Stop discovery\nmdns.stop().await?;\n'})}),"\n",(0,t.jsx)(n.h2,{id:"gossip-discovery",children:"Gossip Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Epidemic-style peer propagation for efficient network-wide discovery:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::gossip::*;\n\n#[derive(Debug)]\npub struct GossipDiscovery {\n    config: GossipConfig,\n    known_peers: Arc<RwLock<HashMap<PeerId, PeerInfo>>>,\n    gossip_task: Option<JoinHandle<()>>,\n}\n\n#[derive(Debug, Clone)]\npub struct GossipConfig {\n    pub fanout: usize,\n    pub gossip_interval: Duration,\n    pub max_peers: usize,\n    pub max_gossip_history: usize,\n    pub gossip_ttl: u8,\n}\n\nimpl Default for GossipConfig {\n    fn default() -> Self {\n        Self {\n            fanout: 3,\n            gossip_interval: Duration::from_secs(30),\n            max_peers: 50,\n            max_gossip_history: 1000,\n            gossip_ttl: 3,\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GossipMessage {\n    pub message_id: Uuid,\n    pub sender_id: PeerId,\n    pub ttl: u8,\n    pub timestamp: SystemTime,\n    pub payload: GossipPayload,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum GossipPayload {\n    PeerAnnouncement(PeerInfo),\n    PeerList(Vec<PeerInfo>),\n    Ping,\n    Pong,\n}\n\n#[async_trait::async_trait]\nimpl DiscoveryMechanism for GossipDiscovery {\n    async fn start(&mut self, local_peer_id: PeerId) -> Result<()> {\n        let known_peers = self.known_peers.clone();\n        let config = self.config.clone();\n        \n        let task = tokio::spawn(async move {\n            let mut interval = tokio::time::interval(config.gossip_interval);\n            \n            loop {\n                interval.tick().await;\n                \n                // Select random peers to gossip with\n                let peers = {\n                    let peers_lock = known_peers.read().await;\n                    let mut peer_list: Vec<_> = peers_lock.values().cloned().collect();\n                    peer_list.shuffle(&mut thread_rng());\n                    peer_list.into_iter().take(config.fanout).collect::<Vec<_>>()\n                };\n                \n                // Send gossip messages\n                for peer in peers {\n                    if peer.connection_status == ConnectionStatus::Connected {\n                        let gossip_msg = GossipMessage {\n                            message_id: Uuid::new_v4(),\n                            sender_id: local_peer_id,\n                            ttl: 3,\n                            timestamp: SystemTime::now(),\n                            payload: GossipPayload::Ping,\n                        };\n                        \n                        // Send via network transport\n                        if let Err(e) = Self::send_gossip_message(&peer, &gossip_msg).await {\n                            eprintln!("Failed to send gossip to {}: {}", peer.peer_id, e);\n                        }\n                    }\n                }\n            }\n        });\n        \n        self.gossip_task = Some(task);\n        Ok(())\n    }\n\n    async fn stop(&mut self) -> Result<()> {\n        if let Some(task) = self.gossip_task.take() {\n            task.abort();\n        }\n        Ok(())\n    }\n\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>> {\n        let peers = self.known_peers.read().await;\n        Ok(peers.values().cloned().collect())\n    }\n\n    async fn announce_self(&mut self, peer_info: PeerInfo) -> Result<()> {\n        // Add ourselves to known peers\n        let mut peers = self.known_peers.write().await;\n        peers.insert(peer_info.peer_id, peer_info.clone());\n        \n        // Gossip our announcement\n        let gossip_msg = GossipMessage {\n            message_id: Uuid::new_v4(),\n            sender_id: peer_info.peer_id,\n            ttl: self.config.gossip_ttl,\n            timestamp: SystemTime::now(),\n            payload: GossipPayload::PeerAnnouncement(peer_info),\n        };\n        \n        self.broadcast_gossip_message(gossip_msg).await?;\n        Ok(())\n    }\n\n    fn mechanism_type(&self) -> DiscoveryType {\n        DiscoveryType::Gossip\n    }\n\n    fn supports_content_routing(&self) -> bool {\n        false\n    }\n\n    fn supports_peer_routing(&self) -> bool {\n        true\n    }\n}\n\nimpl GossipDiscovery {\n    pub async fn handle_gossip_message(&self, message: GossipMessage) -> Result<()> {\n        if message.ttl == 0 {\n            return Ok(()); // TTL expired\n        }\n        \n        match message.payload {\n            GossipPayload::PeerAnnouncement(peer_info) => {\n                let mut peers = self.known_peers.write().await;\n                if peers.len() < self.config.max_peers {\n                    peers.insert(peer_info.peer_id, peer_info);\n                }\n                \n                // Forward with decreased TTL\n                let forwarded_msg = GossipMessage {\n                    ttl: message.ttl - 1,\n                    ..message\n                };\n                \n                self.forward_gossip_message(forwarded_msg).await?;\n            }\n            GossipPayload::PeerList(peer_list) => {\n                let mut peers = self.known_peers.write().await;\n                for peer_info in peer_list {\n                    if peers.len() < self.config.max_peers {\n                        peers.insert(peer_info.peer_id, peer_info);\n                    }\n                }\n            }\n            GossipPayload::Ping => {\n                // Respond with pong\n                let pong_msg = GossipMessage {\n                    message_id: Uuid::new_v4(),\n                    sender_id: message.sender_id, // Echo back\n                    ttl: 1,\n                    timestamp: SystemTime::now(),\n                    payload: GossipPayload::Pong,\n                };\n                \n                // Send back to sender (implementation depends on transport)\n                // Self::send_to_peer(&message.sender_id, &pong_msg).await?;\n            }\n            GossipPayload::Pong => {\n                // Update peer last seen time\n                let mut peers = self.known_peers.write().await;\n                if let Some(peer_info) = peers.get_mut(&message.sender_id) {\n                    peer_info.last_seen = SystemTime::now();\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    async fn send_gossip_message(peer: &PeerInfo, message: &GossipMessage) -> Result<()> {\n        // Implementation depends on transport layer\n        // This would use the network transport to send the message\n        Ok(())\n    }\n    \n    async fn broadcast_gossip_message(&self, message: GossipMessage) -> Result<()> {\n        let peers = self.known_peers.read().await;\n        let selected_peers: Vec<_> = peers.values()\n            .filter(|p| p.connection_status == ConnectionStatus::Connected)\n            .take(self.config.fanout)\n            .collect();\n        \n        for peer in selected_peers {\n            if let Err(e) = Self::send_gossip_message(peer, &message).await {\n                eprintln!("Failed to broadcast gossip to {}: {}", peer.peer_id, e);\n            }\n        }\n        \n        Ok(())\n    }\n    \n    async fn forward_gossip_message(&self, message: GossipMessage) -> Result<()> {\n        if message.ttl > 0 {\n            self.broadcast_gossip_message(message).await?;\n        }\n        Ok(())\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-2",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::gossip::*;\n\nlet config = GossipConfig {\n    fanout: 5,\n    gossip_interval: Duration::from_secs(15),\n    max_peers: 100,\n    gossip_ttl: 4,\n    ..Default::default()\n};\n\nlet mut gossip = GossipDiscovery::new(config);\ngossip.start(local_peer_id).await?;\n\n// Add some initial peers (bootstrap)\ngossip.add_peer(bootstrap_peer).await?;\n\n// Announce ourselves\ngossip.announce_self(our_peer_info).await?;\n\n// Handle incoming gossip messages\ntokio::spawn(async move {\n    while let Some(msg) = gossip_receiver.recv().await {\n        gossip.handle_gossip_message(msg).await?;\n    }\n});\n\n// Discover peers\nlet peers = gossip.discover_peers().await?;\nprintln!("Found {} peers via gossip", peers.len());\n'})}),"\n",(0,t.jsx)(n.h2,{id:"bootstrap-discovery",children:"Bootstrap Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Seed node discovery for initial network entry:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::bootstrap::*;\n\n#[derive(Debug)]\npub struct BootstrapDiscovery {\n    config: BootstrapConfig,\n    bootstrap_status: HashMap<String, BootstrapStatus>,\n}\n\n#[derive(Debug, Clone)]\npub struct BootstrapConfig {\n    pub bootstrap_nodes: Vec<String>,\n    pub max_bootstrap_peers: usize,\n    pub bootstrap_timeout: Duration,\n    pub retry_interval: Duration,\n    pub max_retries: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct BootstrapStatus {\n    pub last_attempt: SystemTime,\n    pub success_count: usize,\n    pub failure_count: usize,\n    pub last_error: Option<String>,\n}\n\nimpl Default for BootstrapConfig {\n    fn default() -> Self {\n        Self {\n            bootstrap_nodes: vec![],\n            max_bootstrap_peers: 10,\n            bootstrap_timeout: Duration::from_secs(30),\n            retry_interval: Duration::from_secs(60),\n            max_retries: 3,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl DiscoveryMechanism for BootstrapDiscovery {\n    async fn start(&mut self, local_peer_id: PeerId) -> Result<()> {\n        // Initialize bootstrap status for each node\n        for node in &self.config.bootstrap_nodes {\n            self.bootstrap_status.insert(node.clone(), BootstrapStatus {\n                last_attempt: SystemTime::UNIX_EPOCH,\n                success_count: 0,\n                failure_count: 0,\n                last_error: None,\n            });\n        }\n        \n        Ok(())\n    }\n\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>> {\n        let mut discovered_peers = Vec::new();\n        \n        for bootstrap_node in &self.config.bootstrap_nodes.clone() {\n            match self.connect_to_bootstrap_node(bootstrap_node).await {\n                Ok(peer_info) => {\n                    discovered_peers.push(peer_info);\n                    \n                    // Update success status\n                    if let Some(status) = self.bootstrap_status.get_mut(bootstrap_node) {\n                        status.success_count += 1;\n                        status.last_attempt = SystemTime::now();\n                    }\n                    \n                    // Request peer list from bootstrap node\n                    if let Ok(additional_peers) = self.request_peer_list(bootstrap_node).await {\n                        discovered_peers.extend(additional_peers);\n                    }\n                }\n                Err(e) => {\n                    eprintln!("Failed to connect to bootstrap node {}: {}", bootstrap_node, e);\n                    \n                    // Update failure status\n                    if let Some(status) = self.bootstrap_status.get_mut(bootstrap_node) {\n                        status.failure_count += 1;\n                        status.last_attempt = SystemTime::now();\n                        status.last_error = Some(e.to_string());\n                    }\n                }\n            }\n            \n            if discovered_peers.len() >= self.config.max_bootstrap_peers {\n                break;\n            }\n        }\n        \n        Ok(discovered_peers)\n    }\n\n    async fn announce_self(&mut self, peer_info: PeerInfo) -> Result<()> {\n        // Announce to all responsive bootstrap nodes\n        for bootstrap_node in &self.config.bootstrap_nodes.clone() {\n            if let Some(status) = self.bootstrap_status.get(bootstrap_node) {\n                if status.success_count > 0 {\n                    if let Err(e) = self.announce_to_bootstrap_node(bootstrap_node, &peer_info).await {\n                        eprintln!("Failed to announce to bootstrap node {}: {}", bootstrap_node, e);\n                    }\n                }\n            }\n        }\n        \n        Ok(())\n    }\n\n    fn mechanism_type(&self) -> DiscoveryType {\n        DiscoveryType::Bootstrap\n    }\n\n    fn supports_content_routing(&self) -> bool {\n        false\n    }\n\n    fn supports_peer_routing(&self) -> bool {\n        true\n    }\n}\n\nimpl BootstrapDiscovery {\n    async fn connect_to_bootstrap_node(&self, node: &str) -> Result<PeerInfo> {\n        let multiaddr: Multiaddr = node.parse()?;\n        \n        // Extract peer ID and addresses from multiaddr\n        let mut peer_id = None;\n        let mut addresses = vec![multiaddr.clone()];\n        \n        for protocol in multiaddr.iter() {\n            if let Protocol::P2p(hash) = protocol {\n                peer_id = Some(PeerId::from_multihash(hash)?);\n                break;\n            }\n        }\n        \n        let peer_id = peer_id.ok_or_else(|| {\n            DiscoveryError::InvalidBootstrapNode("No peer ID in multiaddr".to_string())\n        })?;\n        \n        // Attempt connection with timeout\n        let connection_result = tokio::time::timeout(\n            self.config.bootstrap_timeout,\n            self.establish_connection(&multiaddr)\n        ).await;\n        \n        match connection_result {\n            Ok(Ok(_connection)) => {\n                Ok(PeerInfo {\n                    peer_id,\n                    addresses,\n                    protocols: vec!["olocus/1.0.0".to_string()],\n                    last_seen: SystemTime::now(),\n                    connection_status: ConnectionStatus::Connected,\n                    reputation_score: 1.0,\n                })\n            }\n            Ok(Err(e)) => Err(e.into()),\n            Err(_) => Err(DiscoveryError::Timeout.into()),\n        }\n    }\n    \n    async fn establish_connection(&self, addr: &Multiaddr) -> Result<()> {\n        // Implementation depends on transport layer\n        // This would use the network transport to establish connection\n        Ok(())\n    }\n    \n    async fn request_peer_list(&self, node: &str) -> Result<Vec<PeerInfo>> {\n        // Request peer list from bootstrap node\n        // Implementation would send a protocol message requesting known peers\n        Ok(vec![])\n    }\n    \n    async fn announce_to_bootstrap_node(&self, node: &str, peer_info: &PeerInfo) -> Result<()> {\n        // Announce our presence to bootstrap node\n        // Implementation would send a protocol message with our peer info\n        Ok(())\n    }\n    \n    pub fn get_bootstrap_status(&self) -> &HashMap<String, BootstrapStatus> {\n        &self.bootstrap_status\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-3",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::bootstrap::*;\n\nlet config = BootstrapConfig {\n    bootstrap_nodes: vec![\n        "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ".to_string(),\n        "/ip4/104.236.179.241/tcp/4001/p2p/QmSoLPppuBtQSGwKDZT2M73ULpjvfd3aZ6ha4oFGL1KrGM".to_string(),\n        "/dns4/bootstrap.olocus.io/tcp/4001/p2p/QmBootstrapOlocusNodeId".to_string(),\n    ],\n    max_bootstrap_peers: 5,\n    bootstrap_timeout: Duration::from_secs(15),\n    max_retries: 3,\n    ..Default::default()\n};\n\nlet mut bootstrap = BootstrapDiscovery::new(config);\nbootstrap.start(local_peer_id).await?;\n\n// Initial discovery\nlet peers = bootstrap.discover_peers().await?;\nprintln!("Bootstrapped with {} peers", peers.len());\n\n// Check bootstrap status\nfor (node, status) in bootstrap.get_bootstrap_status() {\n    println!("Bootstrap node {}: {} successes, {} failures", \n        node, status.success_count, status.failure_count);\n}\n\n// Announce ourselves\nbootstrap.announce_self(our_peer_info).await?;\n'})}),"\n",(0,t.jsx)(n.h2,{id:"dns-discovery",children:"DNS Discovery"}),"\n",(0,t.jsx)(n.p,{children:"DNS-based peer discovery using SRV records:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::dns::*;\nuse trust_dns_resolver::*;\n\n#[derive(Debug)]\npub struct DNSDiscovery {\n    config: DNSConfig,\n    resolver: TokioAsyncResolver,\n}\n\n#[derive(Debug, Clone)]\npub struct DNSConfig {\n    pub discovery_domains: Vec<String>,\n    pub service_name: String,\n    pub protocol: String,\n    pub dns_timeout: Duration,\n    pub cache_ttl: Duration,\n}\n\nimpl Default for DNSConfig {\n    fn default() -> Self {\n        Self {\n            discovery_domains: vec!["olocus.io".to_string()],\n            service_name: "olocus".to_string(),\n            protocol: "tcp".to_string(),\n            dns_timeout: Duration::from_secs(5),\n            cache_ttl: Duration::from_secs(300),\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl DiscoveryMechanism for DNSDiscovery {\n    async fn start(&mut self, _local_peer_id: PeerId) -> Result<()> {\n        // DNS discovery doesn\'t require startup\n        Ok(())\n    }\n\n    async fn discover_peers(&mut self) -> Result<Vec<PeerInfo>> {\n        let mut peers = Vec::new();\n        \n        for domain in &self.config.discovery_domains {\n            let srv_name = format!("_{}._{}.{}", \n                self.config.service_name, \n                self.config.protocol, \n                domain\n            );\n            \n            match self.query_srv_records(&srv_name).await {\n                Ok(discovered_peers) => peers.extend(discovered_peers),\n                Err(e) => eprintln!("DNS discovery failed for {}: {}", srv_name, e),\n            }\n        }\n        \n        Ok(peers)\n    }\n\n    async fn announce_self(&mut self, _peer_info: PeerInfo) -> Result<()> {\n        // DNS announcement requires DNS server configuration\n        // This would typically be done through external DNS management\n        Ok(())\n    }\n\n    fn mechanism_type(&self) -> DiscoveryType {\n        DiscoveryType::DNS\n    }\n\n    fn supports_content_routing(&self) -> bool {\n        false\n    }\n\n    fn supports_peer_routing(&self) -> bool {\n        true\n    }\n}\n\nimpl DNSDiscovery {\n    pub fn new(config: DNSConfig) -> Result<Self> {\n        let resolver = TokioAsyncResolver::tokio_from_system_conf()?;\n        Ok(Self { config, resolver })\n    }\n    \n    async fn query_srv_records(&self, srv_name: &str) -> Result<Vec<PeerInfo>> {\n        let mut peers = Vec::new();\n        \n        // Query SRV records\n        let srv_response = tokio::time::timeout(\n            self.config.dns_timeout,\n            self.resolver.srv_lookup(srv_name)\n        ).await??;\n        \n        for srv_record in srv_response.iter() {\n            // Query TXT records for additional peer information\n            let txt_name = format!("_olocus-peer.{}", srv_record.target());\n            let peer_info = match self.query_peer_txt_record(&txt_name).await {\n                Ok(info) => info,\n                Err(_) => {\n                    // Fallback: create peer info from SRV record only\n                    let addr = format!("/dns4/{}/tcp/{}", \n                        srv_record.target().to_utf8(), \n                        srv_record.port()\n                    ).parse()?;\n                    \n                    PeerInfo {\n                        peer_id: PeerId::random(), // Would need proper peer ID\n                        addresses: vec![addr],\n                        protocols: vec!["olocus/1.0.0".to_string()],\n                        last_seen: SystemTime::now(),\n                        connection_status: ConnectionStatus::Unknown,\n                        reputation_score: 1.0,\n                    }\n                }\n            };\n            \n            peers.push(peer_info);\n        }\n        \n        Ok(peers)\n    }\n    \n    async fn query_peer_txt_record(&self, txt_name: &str) -> Result<PeerInfo> {\n        let txt_response = self.resolver.txt_lookup(txt_name).await?;\n        let mut peer_id = None;\n        let mut addresses = Vec::new();\n        let mut protocols = vec!["olocus/1.0.0".to_string()];\n        \n        for txt_record in txt_response.iter() {\n            for txt_data in txt_record.iter() {\n                let txt_str = String::from_utf8_lossy(txt_data);\n                \n                if txt_str.starts_with("peer_id=") {\n                    if let Ok(id) = PeerId::from_base58(&txt_str[8..]) {\n                        peer_id = Some(id);\n                    }\n                } else if txt_str.starts_with("addr=") {\n                    if let Ok(addr) = txt_str[5..].parse() {\n                        addresses.push(addr);\n                    }\n                } else if txt_str.starts_with("protocol=") {\n                    protocols.push(txt_str[9..].to_string());\n                }\n            }\n        }\n        \n        let peer_id = peer_id.ok_or_else(|| {\n            DiscoveryError::InvalidDNSRecord("No peer_id in TXT record".to_string())\n        })?;\n        \n        Ok(PeerInfo {\n            peer_id,\n            addresses,\n            protocols,\n            last_seen: SystemTime::now(),\n            connection_status: ConnectionStatus::Unknown,\n            reputation_score: 1.0,\n        })\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-4",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::dns::*;\n\nlet config = DNSConfig {\n    discovery_domains: vec![\n        "olocus.io".to_string(),\n        "bootstrap.olocus.network".to_string(),\n    ],\n    service_name: "olocus".to_string(),\n    protocol: "tcp".to_string(),\n    dns_timeout: Duration::from_secs(10),\n    ..Default::default()\n};\n\nlet mut dns = DNSDiscovery::new(config)?;\ndns.start(local_peer_id).await?;\n\n// Discover peers via DNS\nlet peers = dns.discover_peers().await?;\nprintln!("Found {} peers via DNS", peers.len());\n\nfor peer in &peers {\n    println!("DNS discovered peer: {} at {:?}", \n        peer.peer_id, peer.addresses);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"multi-mechanism-discovery",children:"Multi-Mechanism Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Combining multiple discovery mechanisms for robust peer discovery:"}),"\n",(0,t.jsx)(n.h3,{id:"implementation-5",children:"Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::multi::*;\n\n#[derive(Debug)]\npub struct MultiDiscovery {\n    mechanisms: Vec<Box<dyn DiscoveryMechanism>>,\n    config: MultiDiscoveryConfig,\n    peer_store: Box<dyn PeerStore>,\n}\n\n#[derive(Debug, Clone)]\npub struct MultiDiscoveryConfig {\n    pub max_peers_per_mechanism: usize,\n    pub discovery_interval: Duration,\n    pub peer_refresh_interval: Duration,\n    pub peer_timeout: Duration,\n}\n\nimpl Default for MultiDiscoveryConfig {\n    fn default() -> Self {\n        Self {\n            max_peers_per_mechanism: 50,\n            discovery_interval: Duration::from_secs(60),\n            peer_refresh_interval: Duration::from_secs(300),\n            peer_timeout: Duration::from_secs(600),\n        }\n    }\n}\n\nimpl MultiDiscovery {\n    pub fn new(\n        mechanisms: Vec<Box<dyn DiscoveryMechanism>>,\n        config: MultiDiscoveryConfig,\n        peer_store: Box<dyn PeerStore>\n    ) -> Self {\n        Self {\n            mechanisms,\n            config,\n            peer_store,\n        }\n    }\n    \n    pub async fn start_continuous_discovery(&mut self, local_peer_id: PeerId) -> Result<()> {\n        // Start all discovery mechanisms\n        for mechanism in &mut self.mechanisms {\n            mechanism.start(local_peer_id).await?;\n        }\n        \n        // Start continuous discovery loop\n        let mechanisms = self.mechanisms.clone(); // Would need Arc<Mutex<>> in practice\n        let config = self.config.clone();\n        let peer_store = self.peer_store.clone(); // Would need Arc<Mutex<>> in practice\n        \n        tokio::spawn(async move {\n            let mut discovery_interval = tokio::time::interval(config.discovery_interval);\n            let mut refresh_interval = tokio::time::interval(config.peer_refresh_interval);\n            \n            loop {\n                tokio::select! {\n                    _ = discovery_interval.tick() => {\n                        // Run discovery on all mechanisms\n                        for mechanism in &mechanisms {\n                            match mechanism.discover_peers().await {\n                                Ok(peers) => {\n                                    for peer in peers.into_iter().take(config.max_peers_per_mechanism) {\n                                        if let Err(e) = peer_store.add_peer(peer).await {\n                                            eprintln!("Failed to add discovered peer: {}", e);\n                                        }\n                                    }\n                                }\n                                Err(e) => {\n                                    eprintln!("Discovery mechanism failed: {}", e);\n                                }\n                            }\n                        }\n                    }\n                    \n                    _ = refresh_interval.tick() => {\n                        // Clean up old peers\n                        let all_peers = peer_store.get_peers().await.unwrap_or_default();\n                        let now = SystemTime::now();\n                        \n                        for peer in all_peers {\n                            if let Ok(elapsed) = now.duration_since(peer.last_seen) {\n                                if elapsed > config.peer_timeout {\n                                    peer_store.remove_peer(&peer.peer_id).await.ok();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        \n        Ok(())\n    }\n    \n    pub async fn get_all_discovered_peers(&self) -> Result<Vec<PeerInfo>> {\n        self.peer_store.get_peers().await\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"usage-example-5",children:"Usage Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::{multi::*, dht::*, mdns::*, bootstrap::*};\n\n// Create multiple discovery mechanisms\nlet mechanisms: Vec<Box<dyn DiscoveryMechanism>> = vec![\n    Box::new(DHTDiscovery::new(DHTConfig::default())),\n    Box::new(MDNSDiscovery::new(MDNSConfig::default())),\n    Box::new(BootstrapDiscovery::new(BootstrapConfig {\n        bootstrap_nodes: vec![\n            "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ".to_string(),\n        ],\n        ..Default::default()\n    })),\n];\n\nlet config = MultiDiscoveryConfig {\n    max_peers_per_mechanism: 25,\n    discovery_interval: Duration::from_secs(30),\n    peer_refresh_interval: Duration::from_secs(180),\n    peer_timeout: Duration::from_secs(300),\n};\n\nlet peer_store = Box::new(MemoryPeerStore::new());\nlet mut multi_discovery = MultiDiscovery::new(mechanisms, config, peer_store);\n\n// Start continuous discovery\nmulti_discovery.start_continuous_discovery(local_peer_id).await?;\n\n// Wait and check discovered peers\ntokio::time::sleep(Duration::from_secs(60)).await;\nlet all_peers = multi_discovery.get_all_discovered_peers().await?;\nprintln!("Total discovered peers: {}", all_peers.len());\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Mechanism"}),(0,t.jsx)(n.th,{children:"Scalability"}),(0,t.jsx)(n.th,{children:"Latency"}),(0,t.jsx)(n.th,{children:"Overhead"}),(0,t.jsx)(n.th,{children:"Use Case"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DHT"}),(0,t.jsx)(n.td,{children:"Excellent"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Large networks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"mDNS"}),(0,t.jsx)(n.td,{children:"Limited"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Local networks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Gossip"}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Medium networks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Bootstrap"}),(0,t.jsx)(n.td,{children:"Good"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Initial discovery"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"DNS"}),(0,t.jsx)(n.td,{children:"Excellent"}),(0,t.jsx)(n.td,{children:"Medium"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Centralized networks"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_network::discovery::error::*;\n\n#[derive(Debug, thiserror::Error)]\npub enum DiscoveryError {\n    #[error("Network timeout")]\n    Timeout,\n    \n    #[error("Invalid bootstrap node: {0}")]\n    InvalidBootstrapNode(String),\n    \n    #[error("Invalid DNS record: {0}")]\n    InvalidDNSRecord(String),\n    \n    #[error("Peer store full")]\n    PeerStoreFull,\n    \n    #[error("DHT error: {0}")]\n    DHT(String),\n    \n    #[error("mDNS error: {0}")]\n    MDNS(#[from] mdns::Error),\n    \n    #[error("DNS error: {0}")]\n    DNS(#[from] trust_dns_resolver::error::ResolveError),\n    \n    #[error("Gossip error: {0}")]\n    Gossip(String),\n    \n    #[error("Network error: {0}")]\n    Network(#[from] NetworkError),\n    \n    #[error("Serialization error: {0}")]\n    Serialization(#[from] bincode::Error),\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Discovery mechanisms enable Olocus Protocol nodes to find each other and build robust, decentralized networks. Each mechanism can be used independently or combined for comprehensive peer discovery across different network topologies and environments."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var r=s(6540);const t={},o=r.createContext(t);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);