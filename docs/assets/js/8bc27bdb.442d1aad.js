"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[6835],{605:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"getting-started/first-chain","title":"Building Your First Chain","description":"Learn how to create and verify a chain of blocks using the Olocus Protocol.","source":"@site/docs/getting-started/first-chain.md","sourceDirName":"getting-started","slug":"/getting-started/first-chain","permalink":"/docs/getting-started/first-chain","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/getting-started/first-chain.md","tags":[],"version":"current","lastUpdatedAt":1764936851000,"sidebarPosition":2,"frontMatter":{"id":"first-chain","title":"Building Your First Chain","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Installation Guide","permalink":"/docs/getting-started/installation"},"next":{"title":"Understanding Measurements","permalink":"/docs/getting-started/understanding-measurements"}}');var t=i(4848),a=i(8453);const s={id:"first-chain",title:"Building Your First Chain",sidebar_position:2},l="Building Your First Chain",o={},c=[{value:"What is a Chain?",id:"what-is-a-chain",level:2},{value:"Creating a Chain",id:"creating-a-chain",level:2},{value:"Verifying a Chain",id:"verifying-a-chain",level:2},{value:"Chain Properties",id:"chain-properties",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Ordering",id:"ordering",level:3},{value:"Non-repudiation",id:"non-repudiation",level:3},{value:"Advanced Chain Operations",id:"advanced-chain-operations",level:2},{value:"Finding a Block",id:"finding-a-block",level:3},{value:"Chain Metrics",id:"chain-metrics",level:3},{value:"Persistence",id:"persistence",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Issues",id:"common-issues",level:2},{value:"Timestamp Drift",id:"timestamp-drift",level:3},{value:"Broken Chain",id:"broken-chain",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"building-your-first-chain",children:"Building Your First Chain"})}),"\n",(0,t.jsx)(e.p,{children:"Learn how to create and verify a chain of blocks using the Olocus Protocol."}),"\n",(0,t.jsx)(e.h2,{id:"what-is-a-chain",children:"What is a Chain?"}),"\n",(0,t.jsx)(e.p,{children:"A chain is a sequence of cryptographically linked blocks. Each block contains:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"A reference to the previous block (hash)"}),"\n",(0,t.jsx)(e.li,{children:"A timestamp"}),"\n",(0,t.jsx)(e.li,{children:"A payload (your data)"}),"\n",(0,t.jsx)(e.li,{children:"A digital signature"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"creating-a-chain",children:"Creating a Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::*;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Generate a key pair for signing\n    let key = generate_key();\n    \n    // Create the genesis (first) block\n    let mut chain = vec![];\n    let genesis = Block::genesis(\n        EmptyPayload,\n        &key,\n        current_timestamp()\n    );\n    chain.push(genesis.clone());\n    \n    // Add more blocks to the chain\n    for i in 1..5 {\n        let data = format!("Block {}", i);\n        let payload = StringPayload(data);\n        \n        let new_block = Block::next(\n            &chain.last().unwrap(),\n            payload,\n            &key,\n            current_timestamp()\n        )?;\n        \n        chain.push(new_block);\n    }\n    \n    println!("Created chain with {} blocks", chain.len());\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"verifying-a-chain",children:"Verifying a Chain"}),"\n",(0,t.jsx)(e.p,{children:"Always verify the integrity of a chain before trusting its contents:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn verify_chain(chain: &[Block<impl BlockPayload>]) -> Result<(), Error> {\n    // Verify genesis block\n    verify_block(&chain[0], None)?;\n    \n    // Verify each subsequent block\n    for i in 1..chain.len() {\n        verify_block(&chain[i], Some(&chain[i-1]))?;\n    }\n    \n    println!("\u2705 Chain verified successfully!");\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"chain-properties",children:"Chain Properties"}),"\n",(0,t.jsx)(e.h3,{id:"immutability",children:"Immutability"}),"\n",(0,t.jsx)(e.p,{children:"Once a block is added to the chain, it cannot be modified without breaking the cryptographic links."}),"\n",(0,t.jsx)(e.h3,{id:"ordering",children:"Ordering"}),"\n",(0,t.jsx)(e.p,{children:"Blocks are strictly ordered by their index and linked by hash references."}),"\n",(0,t.jsx)(e.h3,{id:"non-repudiation",children:"Non-repudiation"}),"\n",(0,t.jsx)(e.p,{children:"Each block is signed by its creator, providing proof of authorship."}),"\n",(0,t.jsx)(e.h2,{id:"advanced-chain-operations",children:"Advanced Chain Operations"}),"\n",(0,t.jsx)(e.h3,{id:"finding-a-block",children:"Finding a Block"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"fn find_block_by_index(chain: &[Block<impl BlockPayload>], index: u64) \n    -> Option<&Block<impl BlockPayload>> \n{\n    chain.iter().find(|block| block.header.index == index)\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"chain-metrics",children:"Chain Metrics"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn analyze_chain(chain: &[Block<impl BlockPayload>]) {\n    let total_blocks = chain.len();\n    let first_timestamp = chain.first().unwrap().header.timestamp;\n    let last_timestamp = chain.last().unwrap().header.timestamp;\n    let duration = last_timestamp - first_timestamp;\n    \n    println!("Chain Analysis:");\n    println!("  Total blocks: {}", total_blocks);\n    println!("  Duration: {} seconds", duration);\n    println!("  Average block time: {:.2} seconds", \n             duration as f64 / total_blocks as f64);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"persistence",children:"Persistence"}),"\n",(0,t.jsx)(e.p,{children:"Save and load chains from disk:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::fs;\n\nfn save_chain(chain: &[Block<impl BlockPayload>], path: &str) \n    -> Result<(), Box<dyn std::error::Error>> \n{\n    let wire_format = WireFormat::json();\n    let encoded = wire_format.encode_chain(chain)?;\n    fs::write(path, encoded)?;\n    Ok(())\n}\n\nfn load_chain<P: BlockPayload>(path: &str) \n    -> Result<Vec<Block<P>>, Box<dyn std::error::Error>> \n{\n    let data = fs::read(path)?;\n    let wire_format = WireFormat::json();\n    let chain = wire_format.decode_chain(&data)?;\n    Ok(chain)\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always verify"})," chains received from external sources"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use timestamps"})," appropriately - they should be monotonically increasing"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle errors"})," gracefully when blocks fail verification"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Store chains"})," persistently for audit trails"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement pruning"})," for long-running chains to manage storage"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,t.jsx)(e.h3,{id:"timestamp-drift",children:"Timestamp Drift"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Blocks can't be too far in the future\nif block.header.timestamp > current_timestamp() + MAX_FUTURE_DRIFT {\n    return Err(Error::TimestampTooFarInFuture);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"broken-chain",children:"Broken Chain"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Each block must reference the previous block's hash\nif block.header.previous != previous_block.hash() {\n    return Err(Error::BrokenChain);\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsx)(e.p,{children:"Now that you understand chains:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"../concepts/measurements",children:"Learn about Measurements"})," - Universal data representation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"../extensions/overview",children:"Explore Extensions"})," - Add functionality to your chains"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"../extensions/creating-extensions",children:"Implement a Custom Payload"})," - Store your own data types"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var r=i(6540);const t={},a=r.createContext(t);function s(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);