"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[4686],{7619:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"integration/wasm","title":"WebAssembly Guide","description":"Detailed guide for building and optimizing Olocus Protocol as WebAssembly (WASM) for use in web browsers and Node.js environments. This covers build configuration, JavaScript API design, performance optimization, and deployment strategies.","source":"@site/docs/integration/wasm.md","sourceDirName":"integration","slug":"/integration/wasm","permalink":"/docs/integration/wasm","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/integration/wasm.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":5,"frontMatter":{"id":"wasm","title":"WebAssembly Guide","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"FFI Reference","permalink":"/docs/integration/ffi"},"next":{"title":"Language SDKs","permalink":"/docs/integration/language-sdks"}}');var a=t(4848),s=t(8453);const o={id:"wasm",title:"WebAssembly Guide",sidebar_position:5},r="WebAssembly Guide",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"Install Required Tools",id:"install-required-tools",level:3},{value:"Configure Cargo.toml for WASM",id:"configure-cargotoml-for-wasm",level:3},{value:"Building WebAssembly",id:"building-webassembly",level:2},{value:"Basic Build Commands",id:"basic-build-commands",level:3},{value:"Advanced Build Script",id:"advanced-build-script",level:3},{value:"Rust WASM Implementation",id:"rust-wasm-implementation",level:2},{value:"Core WASM Module Structure",id:"core-wasm-module-structure",level:3},{value:"TypeScript Definitions",id:"typescript-definitions",level:2},{value:"Auto-generated TypeScript Types",id:"auto-generated-typescript-types",level:3},{value:"Enhanced TypeScript Wrapper",id:"enhanced-typescript-wrapper",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Size Optimization Techniques",id:"size-optimization-techniques",level:3},{value:"Runtime Optimization",id:"runtime-optimization",level:3},{value:"Browser Integration Examples",id:"browser-integration-examples",level:2},{value:"Vanilla JavaScript",id:"vanilla-javascript",level:3},{value:"React Integration",id:"react-integration",level:3},{value:"Deployment and Distribution",id:"deployment-and-distribution",level:2},{value:"NPM Package Setup",id:"npm-package-setup",level:3},{value:"CDN Distribution",id:"cdn-distribution",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Node.js Test Suite",id:"nodejs-test-suite",level:3},{value:"Browser Test Suite",id:"browser-test-suite",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance",id:"performance",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Security",id:"security",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Tips",id:"debug-tips",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"webassembly-guide",children:"WebAssembly Guide"})}),"\n",(0,a.jsx)(e.p,{children:"Detailed guide for building and optimizing Olocus Protocol as WebAssembly (WASM) for use in web browsers and Node.js environments. This covers build configuration, JavaScript API design, performance optimization, and deployment strategies."}),"\n",(0,a.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Rust 1.70+ with ",(0,a.jsx)(e.code,{children:"wasm32-unknown-unknown"})," target"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"wasm-pack"})," for building and packaging"]}),"\n",(0,a.jsx)(e.li,{children:"Node.js 16+ for testing and tooling"}),"\n",(0,a.jsx)(e.li,{children:"Modern browser with WebAssembly support"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,a.jsx)(e.h3,{id:"install-required-tools",children:"Install Required Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Install Rust if not already installed\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Add WebAssembly target\nrustup target add wasm32-unknown-unknown\n\n# Install wasm-pack\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n# or via cargo\ncargo install wasm-pack\n\n# Install additional optimization tools\ncargo install wasm-opt\nnpm install -g wasm-opt\n"})}),"\n",(0,a.jsx)(e.h3,{id:"configure-cargotoml-for-wasm",children:"Configure Cargo.toml for WASM"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-toml",children:'# extensions/olocus-ffi/Cargo.toml\n[package]\nname = "olocus-ffi"\nversion = "1.16.1"\nedition = "2021"\n\n[lib]\ncrate-type = ["cdylib", "rlib"]\n\n[dependencies]\nolocus-core = { path = "../olocus-core" }\nwasm-bindgen = { version = "0.2", optional = true }\njs-sys = { version = "0.3", optional = true }\nweb-sys = { version = "0.3", optional = true, features = [\n  "console",\n  "Performance",\n  "Window",\n  "Worker",\n  "WorkerGlobalScope"\n] }\nwee_alloc = { version = "0.4", optional = true }\nconsole_error_panic_hook = { version = "0.1", optional = true }\nserde = { version = "1.0", features = ["derive"], optional = true }\nserde-wasm-bindgen = { version = "0.4", optional = true }\ngloo-utils = { version = "0.2", optional = true }\n\n[features]\ndefault = []\nwasm = [\n  "wasm-bindgen",\n  "js-sys",\n  "web-sys",\n  "serde",\n  "serde-wasm-bindgen",\n  "gloo-utils",\n  "console_error_panic_hook"\n]\nwee_alloc = ["dep:wee_alloc"]\ndebug = ["console_error_panic_hook"]\n\n[profile.release]\ncodegen-units = 1\nlto = true\nopt-level = "z"  # Optimize for size\nstrip = "symbols"\npanic = "abort"\n\n[profile.dev]\nopt-level = "s"  # Some optimization for faster builds\nstrip = "none"\n'})}),"\n",(0,a.jsx)(e.h2,{id:"building-webassembly",children:"Building WebAssembly"}),"\n",(0,a.jsx)(e.h3,{id:"basic-build-commands",children:"Basic Build Commands"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"cd extensions/olocus-ffi\n\n# Build for bundlers (Webpack, Vite, etc.)\nwasm-pack build --target bundler --features wasm\n\n# Build for web (ES modules)\nwasm-pack build --target web --features wasm\n\n# Build for Node.js\nwasm-pack build --target nodejs --features wasm\n\n# Build with optimizations\nwasm-pack build --target web --features wasm --release\n\n# Build with size optimization\nwasm-pack build --target web --features wasm,wee_alloc --release\n\n# Build with debug features\nwasm-pack build --target web --features wasm,debug --dev\n"})}),"\n",(0,a.jsx)(e.h3,{id:"advanced-build-script",children:"Advanced Build Script"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:'#!/bin/bash\n# build-wasm.sh\n\nset -e\n\nTARGET=${1:-"web"}\nMODE=${2:-"release"}\nFEATURES="wasm"\n\necho "Building Olocus WASM for target: $TARGET, mode: $MODE"\n\n# Clean previous builds\nrm -rf pkg pkg-*\n\n# Add size optimizations for release\nif [ "$MODE" = "release" ]; then\n    FEATURES="$FEATURES,wee_alloc"\n    EXTRA_ARGS="--release"\nelse\n    FEATURES="$FEATURES,debug"\n    EXTRA_ARGS="--dev"\nfi\n\n# Build with wasm-pack\nwasm-pack build \\\n    --target "$TARGET" \\\n    --features "$FEATURES" \\\n    --out-dir "pkg-$TARGET" \\\n    $EXTRA_ARGS\n\n# Post-process optimization\nif [ "$MODE" = "release" ]; then\n    echo "Optimizing WASM binary..."\n    \n    # Use wasm-opt for further size reduction\n    if command -v wasm-opt >/dev/null 2>&1; then\n        wasm-opt -Oz "pkg-$TARGET/olocus_ffi_bg.wasm" -o "pkg-$TARGET/olocus_ffi_bg.wasm"\n        echo "Applied wasm-opt -Oz optimization"\n    fi\n    \n    # Optional: Use wasm-snip to remove unused functions\n    if command -v wasm-snip >/dev/null 2>&1; then\n        wasm-snip "pkg-$TARGET/olocus_ffi_bg.wasm" \\\n            --snip-rust-fmt-code \\\n            --snip-rust-panicking-code \\\n            -o "pkg-$TARGET/olocus_ffi_bg.wasm"\n        echo "Applied wasm-snip optimization"\n    fi\nfi\n\n# Generate package.json with correct metadata\ncat > "pkg-$TARGET/package.json" << EOF\n{\n  "name": "@olocus/wasm-$TARGET",\n  "version": "1.16.1",\n  "description": "Olocus Protocol WebAssembly bindings for $TARGET",\n  "main": "olocus_ffi.js",\n  "types": "olocus_ffi.d.ts",\n  "files": [\n    "olocus_ffi_bg.wasm",\n    "olocus_ffi.js",\n    "olocus_ffi.d.ts"\n  ],\n  "repository": {\n    "type": "git",\n    "url": "https://codeberg.org/olocus/protocol"\n  },\n  "keywords": ["blockchain", "crypto", "wasm", "olocus"],\n  "license": "MIT",\n  "sideEffects": false\nEOF\n\n# Add target-specific fields\nif [ "$TARGET" = "web" ]; then\n    cat >> "pkg-$TARGET/package.json" << EOF\n,\n  "module": "olocus_ffi.js",\n  "types": "olocus_ffi.d.ts"\n}\nEOF\nelif [ "$TARGET" = "nodejs" ]; then\n    cat >> "pkg-$TARGET/package.json" << EOF\n,\n  "main": "olocus_ffi.js",\n  "types": "olocus_ffi.d.ts"\n}\nEOF\nelse\n    echo "}" >> "pkg-$TARGET/package.json"\nfi\n\necho "Build complete! Output in pkg-$TARGET/"\necho "WASM size: $(du -h "pkg-$TARGET/olocus_ffi_bg.wasm" | cut -f1)"\n'})}),"\n",(0,a.jsx)(e.h2,{id:"rust-wasm-implementation",children:"Rust WASM Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"core-wasm-module-structure",children:"Core WASM Module Structure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:'// src/wasm.rs\nuse wasm_bindgen::prelude::*;\nuse js_sys::{Array, Uint8Array};\nuse web_sys::console;\nuse std::collections::HashMap;\nuse std::sync::Mutex;\n\n// Import the Olocus core types\nuse olocus_core::{\n    Block, Chain, KeyPair, CryptoSuite,\n    wire::{WireFormat, EncodingFormat, CompressionMethod},\n    error::OlocusError\n};\n\n// Global panic hook for better error messages\n#[cfg(feature = "debug")]\n#[wasm_bindgen(start)]\npub fn main() {\n    console_error_panic_hook::set_once();\n    console::log_1(&"Olocus WASM module initialized with debug features".into());\n}\n\n// Global allocator for smaller binary size\n#[cfg(feature = "wee_alloc")]\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n// Global state management\nlazy_static::lazy_static! {\n    static ref GLOBAL_STATE: Mutex<WasmState> = Mutex::new(WasmState::new());\n}\n\nstruct WasmState {\n    initialized: bool,\n    keypairs: HashMap<u32, KeyPair>,\n    blocks: HashMap<u32, Block>,\n    chains: HashMap<u32, Chain>,\n    next_id: u32,\n}\n\nimpl WasmState {\n    fn new() -> Self {\n        Self {\n            initialized: false,\n            keypairs: HashMap::new(),\n            blocks: HashMap::new(),\n            chains: HashMap::new(),\n            next_id: 1,\n        }\n    }\n    \n    fn next_id(&mut self) -> u32 {\n        let id = self.next_id;\n        self.next_id += 1;\n        id\n    }\n}\n\n// Error handling\n#[wasm_bindgen]\nextern "C" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn error(s: &str);\n}\n\nmacro_rules! console_error {\n    ($($t:tt)*) => (error(&format_args!($($t)*).to_string()))\n}\n\n// Result type for WASM\n#[wasm_bindgen]\npub struct WasmResult {\n    success: bool,\n    error_message: Option<String>,\n    data: Option<Vec<u8>>,\n}\n\n#[wasm_bindgen]\nimpl WasmResult {\n    #[wasm_bindgen(getter)]\n    pub fn success(&self) -> bool {\n        self.success\n    }\n    \n    #[wasm_bindgen(getter)]\n    pub fn error_message(&self) -> Option<String> {\n        self.error_message.clone()\n    }\n    \n    #[wasm_bindgen(getter)]\n    pub fn data(&self) -> Option<Vec<u8>> {\n        self.data.clone()\n    }\n}\n\nimpl WasmResult {\n    fn success(data: Option<Vec<u8>>) -> Self {\n        Self {\n            success: true,\n            error_message: None,\n            data,\n        }\n    }\n    \n    fn error(message: &str) -> Self {\n        Self {\n            success: false,\n            error_message: Some(message.to_string()),\n            data: None,\n        }\n    }\n    \n    fn from_result<T>(result: Result<T, OlocusError>, data_fn: impl FnOnce(T) -> Option<Vec<u8>>) -> Self {\n        match result {\n            Ok(value) => Self::success(data_fn(value)),\n            Err(e) => Self::error(&e.to_string()),\n        }\n    }\n}\n\n// Initialization and configuration\n#[wasm_bindgen]\npub fn init() -> WasmResult {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if state.initialized {\n        return WasmResult::error("Already initialized");\n    }\n    \n    // Initialize the core library\n    match olocus_core::init() {\n        Ok(_) => {\n            state.initialized = true;\n            WasmResult::success(None)\n        }\n        Err(e) => WasmResult::error(&e.to_string())\n    }\n}\n\n#[wasm_bindgen]\npub fn shutdown() {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    // Clear all stored objects\n    state.keypairs.clear();\n    state.blocks.clear();\n    state.chains.clear();\n    state.initialized = false;\n    \n    olocus_core::shutdown();\n}\n\n#[wasm_bindgen]\npub fn is_initialized() -> bool {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.initialized\n}\n\n#[wasm_bindgen]\npub fn get_version() -> String {\n    env!("CARGO_PKG_VERSION").to_string()\n}\n\n// Key management\n#[wasm_bindgen]\npub fn keypair_generate() -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0; // Error: not initialized\n    }\n    \n    match KeyPair::generate(CryptoSuite::Ed25519) {\n        Ok(keypair) => {\n            let id = state.next_id();\n            state.keypairs.insert(id, keypair);\n            id\n        }\n        Err(_) => 0 // Error\n    }\n}\n\n#[wasm_bindgen]\npub fn keypair_from_bytes(private_key: &[u8]) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    if private_key.len() != 32 {\n        return 0;\n    }\n    \n    let mut key_array = [0u8; 32];\n    key_array.copy_from_slice(private_key);\n    \n    match KeyPair::from_private_key(CryptoSuite::Ed25519, &key_array) {\n        Ok(keypair) => {\n            let id = state.next_id();\n            state.keypairs.insert(id, keypair);\n            id\n        }\n        Err(_) => 0\n    }\n}\n\n#[wasm_bindgen]\npub fn keypair_get_public_key(keypair_id: u32) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.keypairs.get(&keypair_id)\n        .map(|kp| kp.public_key().to_vec())\n}\n\n#[wasm_bindgen]\npub fn keypair_get_private_key(keypair_id: u32) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.keypairs.get(&keypair_id)\n        .map(|kp| kp.private_key().to_vec())\n}\n\n#[wasm_bindgen]\npub fn keypair_destroy(keypair_id: u32) -> bool {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    state.keypairs.remove(&keypair_id).is_some()\n}\n\n// Block operations\n#[wasm_bindgen]\npub fn block_create_genesis(\n    timestamp: f64,\n    payload: &[u8],\n    payload_type: u32,\n    signing_key: &[u8]\n) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    if signing_key.len() != 32 {\n        return 0;\n    }\n    \n    let mut key_array = [0u8; 32];\n    key_array.copy_from_slice(signing_key);\n    \n    let keypair = match KeyPair::from_private_key(CryptoSuite::Ed25519, &key_array) {\n        Ok(kp) => kp,\n        Err(_) => return 0,\n    };\n    \n    match Block::create_genesis(\n        timestamp as i64,\n        payload.to_vec(),\n        payload_type,\n        &keypair\n    ) {\n        Ok(block) => {\n            let id = state.next_id();\n            state.blocks.insert(id, block);\n            id\n        }\n        Err(_) => 0\n    }\n}\n\n#[wasm_bindgen]\npub fn block_create(\n    index: u64,\n    timestamp: f64,\n    previous_hash: &[u8],\n    payload: &[u8],\n    payload_type: u32,\n    signing_key: &[u8]\n) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    if previous_hash.len() != 32 || signing_key.len() != 32 {\n        return 0;\n    }\n    \n    let mut hash_array = [0u8; 32];\n    hash_array.copy_from_slice(previous_hash);\n    \n    let mut key_array = [0u8; 32];\n    key_array.copy_from_slice(signing_key);\n    \n    let keypair = match KeyPair::from_private_key(CryptoSuite::Ed25519, &key_array) {\n        Ok(kp) => kp,\n        Err(_) => return 0,\n    };\n    \n    match Block::create(\n        index,\n        timestamp as i64,\n        &hash_array,\n        payload.to_vec(),\n        payload_type,\n        &keypair\n    ) {\n        Ok(block) => {\n            let id = state.next_id();\n            state.blocks.insert(id, block);\n            id\n        }\n        Err(_) => 0\n    }\n}\n\n#[wasm_bindgen]\npub fn block_verify(block_id: u32) -> bool {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.blocks.get(&block_id)\n        .map(|block| block.verify().is_ok())\n        .unwrap_or(false)\n}\n\n#[wasm_bindgen]\npub fn block_get_index(block_id: u32) -> Option<u64> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.get(&block_id).map(|b| b.index())\n}\n\n#[wasm_bindgen]\npub fn block_get_timestamp(block_id: u32) -> Option<f64> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.get(&block_id).map(|b| b.timestamp() as f64)\n}\n\n#[wasm_bindgen]\npub fn block_get_payload_type(block_id: u32) -> Option<u32> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.get(&block_id).map(|b| b.payload_type())\n}\n\n#[wasm_bindgen]\npub fn block_get_hash(block_id: u32) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.get(&block_id).map(|b| b.hash().to_vec())\n}\n\n#[wasm_bindgen]\npub fn block_get_payload(block_id: u32) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.get(&block_id).map(|b| b.payload().clone())\n}\n\n#[wasm_bindgen]\npub fn block_destroy(block_id: u32) -> bool {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    state.blocks.remove(&block_id).is_some()\n}\n\n// Chain operations\n#[wasm_bindgen]\npub fn chain_create() -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    let chain = Chain::new();\n    let id = state.next_id();\n    state.chains.insert(id, chain);\n    id\n}\n\n#[wasm_bindgen]\npub fn chain_add_block(chain_id: u32, block_id: u32) -> bool {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    let block = match state.blocks.get(&block_id) {\n        Some(b) => b.clone(),\n        None => return false,\n    };\n    \n    match state.chains.get_mut(&chain_id) {\n        Some(chain) => chain.add_block(block).is_ok(),\n        None => false,\n    }\n}\n\n#[wasm_bindgen]\npub fn chain_get_length(chain_id: u32) -> u64 {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.chains.get(&chain_id)\n        .map(|c| c.len() as u64)\n        .unwrap_or(0)\n}\n\n#[wasm_bindgen]\npub fn chain_is_empty(chain_id: u32) -> bool {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.chains.get(&chain_id)\n        .map(|c| c.is_empty())\n        .unwrap_or(true)\n}\n\n#[wasm_bindgen]\npub fn chain_verify(chain_id: u32) -> bool {\n    let state = GLOBAL_STATE.lock().unwrap();\n    state.chains.get(&chain_id)\n        .map(|c| c.verify().is_ok())\n        .unwrap_or(false)\n}\n\n#[wasm_bindgen]\npub fn chain_get_block(chain_id: u32, index: u64) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    let block = match state.chains.get(&chain_id) {\n        Some(chain) => match chain.get_block(index as usize) {\n            Some(b) => b.clone(),\n            None => return 0,\n        },\n        None => return 0,\n    };\n    \n    let block_id = state.next_id();\n    state.blocks.insert(block_id, block);\n    block_id\n}\n\n#[wasm_bindgen]\npub fn chain_destroy(chain_id: u32) -> bool {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    state.chains.remove(&chain_id).is_some()\n}\n\n// Serialization\n#[wasm_bindgen]\npub fn block_to_json(block_id: u32) -> Option<String> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.blocks.get(&block_id)\n        .and_then(|block| {\n            let wire_format = WireFormat::new(\n                EncodingFormat::Json,\n                CompressionMethod::None\n            );\n            block.to_wire_format(&wire_format)\n                .ok()\n                .and_then(|bytes| String::from_utf8(bytes).ok())\n        })\n}\n\n#[wasm_bindgen]\npub fn block_from_json(json: &str) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    let wire_format = WireFormat::new(\n        EncodingFormat::Json,\n        CompressionMethod::None\n    );\n    \n    match Block::from_wire_format(json.as_bytes(), &wire_format) {\n        Ok(block) => {\n            let id = state.next_id();\n            state.blocks.insert(id, block);\n            id\n        }\n        Err(_) => 0\n    }\n}\n\n#[wasm_bindgen]\npub fn block_to_bytes(block_id: u32) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.blocks.get(&block_id)\n        .and_then(|block| {\n            let wire_format = WireFormat::new(\n                EncodingFormat::Binary,\n                CompressionMethod::None\n            );\n            block.to_wire_format(&wire_format).ok()\n        })\n}\n\n#[wasm_bindgen]\npub fn block_from_bytes(bytes: &[u8]) -> u32 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    if !state.initialized {\n        return 0;\n    }\n    \n    let wire_format = WireFormat::new(\n        EncodingFormat::Binary,\n        CompressionMethod::None\n    );\n    \n    match Block::from_wire_format(bytes, &wire_format) {\n        Ok(block) => {\n            let id = state.next_id();\n            state.blocks.insert(id, block);\n            id\n        }\n        Err(_) => 0\n    }\n}\n\n// Cryptographic utilities\n#[wasm_bindgen]\npub fn sign(keypair_id: u32, data: &[u8]) -> Option<Vec<u8>> {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    state.keypairs.get(&keypair_id)\n        .and_then(|kp| kp.sign(data).ok())\n        .map(|sig| sig.to_vec())\n}\n\n#[wasm_bindgen]\npub fn verify(public_key: &[u8], data: &[u8], signature: &[u8]) -> bool {\n    if public_key.len() != 32 || signature.len() != 64 {\n        return false;\n    }\n    \n    let mut pub_key_array = [0u8; 32];\n    pub_key_array.copy_from_slice(public_key);\n    \n    let mut sig_array = [0u8; 64];\n    sig_array.copy_from_slice(signature);\n    \n    olocus_core::crypto::verify_signature(\n        &pub_key_array,\n        data,\n        &sig_array\n    ).unwrap_or(false)\n}\n\n#[wasm_bindgen]\npub fn hash_sha256(data: &[u8]) -> Vec<u8> {\n    use sha2::{Sha256, Digest};\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hasher.finalize().to_vec()\n}\n\n#[wasm_bindgen]\npub fn random_bytes(length: usize) -> Vec<u8> {\n    use rand::RngCore;\n    let mut rng = rand::thread_rng();\n    let mut bytes = vec![0u8; length];\n    rng.fill_bytes(&mut bytes);\n    bytes\n}\n\n// Performance monitoring\n#[wasm_bindgen]\npub fn get_memory_usage() -> JsValue {\n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    let usage = serde_json::json!({\n        "keypairs": state.keypairs.len(),\n        "blocks": state.blocks.len(),\n        "chains": state.chains.len(),\n        "next_id": state.next_id\n    });\n    \n    serde_wasm_bindgen::to_value(&usage).unwrap_or(JsValue::NULL)\n}\n\n// Cleanup utility\n#[wasm_bindgen]\npub fn cleanup_objects() -> u64 {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    \n    let total_cleaned = state.keypairs.len() + state.blocks.len() + state.chains.len();\n    \n    state.keypairs.clear();\n    state.blocks.clear();\n    state.chains.clear();\n    \n    total_cleaned as u64\n}\n\n// Web-specific utilities\n#[cfg(target_arch = "wasm32")]\n#[wasm_bindgen]\npub fn get_performance_now() -> f64 {\n    web_sys::window()\n        .and_then(|w| w.performance())\n        .map(|p| p.now())\n        .unwrap_or(0.0)\n}\n\n#[cfg(target_arch = "wasm32")]\n#[wasm_bindgen]\npub fn console_log(message: &str) {\n    web_sys::console::log_1(&message.into());\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"typescript-definitions",children:"TypeScript Definitions"}),"\n",(0,a.jsx)(e.h3,{id:"auto-generated-typescript-types",children:"Auto-generated TypeScript Types"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Generated by wasm-pack - enhanced for better TypeScript support\n\nexport interface WasmResult {\n  readonly success: boolean;\n  readonly error_message?: string;\n  readonly data?: Uint8Array;\n}\n\nexport interface MemoryUsage {\n  keypairs: number;\n  blocks: number;\n  chains: number;\n  next_id: number;\n}\n\n// Initialization\nexport function init(): WasmResult;\nexport function shutdown(): void;\nexport function is_initialized(): boolean;\nexport function get_version(): string;\n\n// Key management\nexport function keypair_generate(): number;\nexport function keypair_from_bytes(private_key: Uint8Array): number;\nexport function keypair_get_public_key(keypair_id: number): Uint8Array | undefined;\nexport function keypair_get_private_key(keypair_id: number): Uint8Array | undefined;\nexport function keypair_destroy(keypair_id: number): boolean;\n\n// Block operations\nexport function block_create_genesis(\n  timestamp: number,\n  payload: Uint8Array,\n  payload_type: number,\n  signing_key: Uint8Array\n): number;\n\nexport function block_create(\n  index: number,\n  timestamp: number,\n  previous_hash: Uint8Array,\n  payload: Uint8Array,\n  payload_type: number,\n  signing_key: Uint8Array\n): number;\n\nexport function block_verify(block_id: number): boolean;\nexport function block_get_index(block_id: number): number | undefined;\nexport function block_get_timestamp(block_id: number): number | undefined;\nexport function block_get_payload_type(block_id: number): number | undefined;\nexport function block_get_hash(block_id: number): Uint8Array | undefined;\nexport function block_get_payload(block_id: number): Uint8Array | undefined;\nexport function block_destroy(block_id: number): boolean;\n\n// Chain operations\nexport function chain_create(): number;\nexport function chain_add_block(chain_id: number, block_id: number): boolean;\nexport function chain_get_length(chain_id: number): number;\nexport function chain_is_empty(chain_id: number): boolean;\nexport function chain_verify(chain_id: number): boolean;\nexport function chain_get_block(chain_id: number, index: number): number;\nexport function chain_destroy(chain_id: number): boolean;\n\n// Serialization\nexport function block_to_json(block_id: number): string | undefined;\nexport function block_from_json(json: string): number;\nexport function block_to_bytes(block_id: number): Uint8Array | undefined;\nexport function block_from_bytes(bytes: Uint8Array): number;\n\n// Cryptographic operations\nexport function sign(keypair_id: number, data: Uint8Array): Uint8Array | undefined;\nexport function verify(public_key: Uint8Array, data: Uint8Array, signature: Uint8Array): boolean;\nexport function hash_sha256(data: Uint8Array): Uint8Array;\nexport function random_bytes(length: number): Uint8Array;\n\n// Utilities\nexport function get_memory_usage(): MemoryUsage;\nexport function cleanup_objects(): number;\nexport function get_performance_now(): number;\nexport function console_log(message: string): void;\n\n// Initialize WASM module\nexport default function init(module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;\n\nexport type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;\nexport interface InitOutput {\n  readonly memory: WebAssembly.Memory;\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"enhanced-typescript-wrapper",children:"Enhanced TypeScript Wrapper"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// olocus-wasm.ts - High-level TypeScript wrapper\nimport init, * as wasm from './pkg/olocus_ffi.js';\n\nexport interface OlocusConfig {\n  wasmPath?: string;\n  debug?: boolean;\n  logLevel?: 'error' | 'warn' | 'info' | 'debug';\n}\n\nexport interface BlockInfo {\n  id: number;\n  index: number;\n  timestamp: Date;\n  payloadType: number;\n  hash: Uint8Array;\n  payload: Uint8Array;\n}\n\nexport interface ChainInfo {\n  id: number;\n  length: number;\n  isEmpty: boolean;\n  blocks: BlockInfo[];\n}\n\nexport class OlocusError extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string,\n    public readonly details?: any\n  ) {\n    super(message);\n    this.name = 'OlocusError';\n  }\n}\n\nexport class KeyPair {\n  constructor(private id: number) {}\n  \n  get publicKey(): Uint8Array {\n    const key = wasm.keypair_get_public_key(this.id);\n    if (!key) {\n      throw new OlocusError('Failed to get public key');\n    }\n    return key;\n  }\n  \n  get privateKey(): Uint8Array {\n    const key = wasm.keypair_get_private_key(this.id);\n    if (!key) {\n      throw new OlocusError('Failed to get private key');\n    }\n    return key;\n  }\n  \n  sign(data: Uint8Array): Uint8Array {\n    const signature = wasm.sign(this.id, data);\n    if (!signature) {\n      throw new OlocusError('Failed to sign data');\n    }\n    return signature;\n  }\n  \n  destroy(): void {\n    wasm.keypair_destroy(this.id);\n  }\n  \n  static generate(): KeyPair {\n    const id = wasm.keypair_generate();\n    if (id === 0) {\n      throw new OlocusError('Failed to generate keypair');\n    }\n    return new KeyPair(id);\n  }\n  \n  static fromBytes(privateKey: Uint8Array): KeyPair {\n    if (privateKey.length !== 32) {\n      throw new OlocusError('Private key must be 32 bytes');\n    }\n    \n    const id = wasm.keypair_from_bytes(privateKey);\n    if (id === 0) {\n      throw new OlocusError('Failed to create keypair from bytes');\n    }\n    return new KeyPair(id);\n  }\n}\n\nexport class Block {\n  constructor(private id: number) {}\n  \n  get index(): number {\n    const index = wasm.block_get_index(this.id);\n    if (index === undefined) {\n      throw new OlocusError('Failed to get block index');\n    }\n    return index;\n  }\n  \n  get timestamp(): Date {\n    const timestamp = wasm.block_get_timestamp(this.id);\n    if (timestamp === undefined) {\n      throw new OlocusError('Failed to get block timestamp');\n    }\n    return new Date(timestamp);\n  }\n  \n  get payloadType(): number {\n    const payloadType = wasm.block_get_payload_type(this.id);\n    if (payloadType === undefined) {\n      throw new OlocusError('Failed to get payload type');\n    }\n    return payloadType;\n  }\n  \n  get hash(): Uint8Array {\n    const hash = wasm.block_get_hash(this.id);\n    if (!hash) {\n      throw new OlocusError('Failed to get block hash');\n    }\n    return hash;\n  }\n  \n  get payload(): Uint8Array {\n    const payload = wasm.block_get_payload(this.id);\n    if (!payload) {\n      throw new OlocusError('Failed to get block payload');\n    }\n    return payload;\n  }\n  \n  verify(): boolean {\n    return wasm.block_verify(this.id);\n  }\n  \n  toJSON(): string {\n    const json = wasm.block_to_json(this.id);\n    if (!json) {\n      throw new OlocusError('Failed to serialize block to JSON');\n    }\n    return json;\n  }\n  \n  toBytes(): Uint8Array {\n    const bytes = wasm.block_to_bytes(this.id);\n    if (!bytes) {\n      throw new OlocusError('Failed to serialize block to bytes');\n    }\n    return bytes;\n  }\n  \n  getInfo(): BlockInfo {\n    return {\n      id: this.id,\n      index: this.index,\n      timestamp: this.timestamp,\n      payloadType: this.payloadType,\n      hash: this.hash,\n      payload: this.payload\n    };\n  }\n  \n  destroy(): void {\n    wasm.block_destroy(this.id);\n  }\n  \n  static createGenesis(\n    payload: Uint8Array | string,\n    payloadType: number = 0,\n    keypair?: KeyPair\n  ): Block {\n    const kp = keypair || KeyPair.generate();\n    const payloadBytes = typeof payload === 'string' \n      ? new TextEncoder().encode(payload)\n      : payload;\n    \n    const id = wasm.block_create_genesis(\n      Date.now(),\n      payloadBytes,\n      payloadType,\n      kp.privateKey\n    );\n    \n    if (id === 0) {\n      throw new OlocusError('Failed to create genesis block');\n    }\n    \n    return new Block(id);\n  }\n  \n  static create(\n    index: number,\n    previousHash: Uint8Array,\n    payload: Uint8Array | string,\n    payloadType: number = 0,\n    keypair?: KeyPair\n  ): Block {\n    if (previousHash.length !== 32) {\n      throw new OlocusError('Previous hash must be 32 bytes');\n    }\n    \n    const kp = keypair || KeyPair.generate();\n    const payloadBytes = typeof payload === 'string'\n      ? new TextEncoder().encode(payload)\n      : payload;\n    \n    const id = wasm.block_create(\n      index,\n      Date.now(),\n      previousHash,\n      payloadBytes,\n      payloadType,\n      kp.privateKey\n    );\n    \n    if (id === 0) {\n      throw new OlocusError('Failed to create block');\n    }\n    \n    return new Block(id);\n  }\n  \n  static fromJSON(json: string): Block {\n    const id = wasm.block_from_json(json);\n    if (id === 0) {\n      throw new OlocusError('Failed to deserialize block from JSON');\n    }\n    return new Block(id);\n  }\n  \n  static fromBytes(bytes: Uint8Array): Block {\n    const id = wasm.block_from_bytes(bytes);\n    if (id === 0) {\n      throw new OlocusError('Failed to deserialize block from bytes');\n    }\n    return new Block(id);\n  }\n}\n\nexport class Chain {\n  constructor(private id: number) {}\n  \n  get length(): number {\n    return wasm.chain_get_length(this.id);\n  }\n  \n  get isEmpty(): boolean {\n    return wasm.chain_is_empty(this.id);\n  }\n  \n  addBlock(block: Block): void {\n    const success = wasm.chain_add_block(this.id, (block as any).id);\n    if (!success) {\n      throw new OlocusError('Failed to add block to chain');\n    }\n  }\n  \n  getBlock(index: number): Block {\n    const blockId = wasm.chain_get_block(this.id, index);\n    if (blockId === 0) {\n      throw new OlocusError(`No block at index ${index}`);\n    }\n    return new Block(blockId);\n  }\n  \n  verify(): boolean {\n    return wasm.chain_verify(this.id);\n  }\n  \n  getBlocks(): Block[] {\n    const blocks: Block[] = [];\n    const length = this.length;\n    \n    for (let i = 0; i < length; i++) {\n      try {\n        blocks.push(this.getBlock(i));\n      } catch (e) {\n        // Block not found, skip\n      }\n    }\n    \n    return blocks;\n  }\n  \n  getInfo(): ChainInfo {\n    return {\n      id: this.id,\n      length: this.length,\n      isEmpty: this.isEmpty,\n      blocks: this.getBlocks().map(b => b.getInfo())\n    };\n  }\n  \n  destroy(): void {\n    wasm.chain_destroy(this.id);\n  }\n  \n  static create(): Chain {\n    const id = wasm.chain_create();\n    if (id === 0) {\n      throw new OlocusError('Failed to create chain');\n    }\n    return new Chain(id);\n  }\n}\n\nexport class Olocus {\n  private static initialized = false;\n  \n  static async initialize(config: OlocusConfig = {}): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n    \n    // Initialize WASM module\n    if (config.wasmPath) {\n      await init(config.wasmPath);\n    } else {\n      await init();\n    }\n    \n    // Initialize Olocus library\n    const result = wasm.init();\n    if (!result.success) {\n      throw new OlocusError(`Failed to initialize Olocus: ${result.error_message}`);\n    }\n    \n    this.initialized = true;\n    \n    if (config.debug) {\n      console.log(`Olocus WASM v${wasm.get_version()} initialized`);\n    }\n  }\n  \n  static shutdown(): void {\n    if (this.initialized) {\n      wasm.shutdown();\n      this.initialized = false;\n    }\n  }\n  \n  static get isInitialized(): boolean {\n    return wasm.is_initialized();\n  }\n  \n  static get version(): string {\n    return wasm.get_version();\n  }\n  \n  static getMemoryUsage(): wasm.MemoryUsage {\n    return wasm.get_memory_usage() as wasm.MemoryUsage;\n  }\n  \n  static cleanupObjects(): number {\n    return wasm.cleanup_objects();\n  }\n  \n  // Cryptographic utilities\n  static verify(publicKey: Uint8Array, data: Uint8Array, signature: Uint8Array): boolean {\n    return wasm.verify(publicKey, data, signature);\n  }\n  \n  static hash(data: Uint8Array | string): Uint8Array {\n    const bytes = typeof data === 'string'\n      ? new TextEncoder().encode(data)\n      : data;\n    return wasm.hash_sha256(bytes);\n  }\n  \n  static randomBytes(length: number): Uint8Array {\n    return wasm.random_bytes(length);\n  }\n  \n  // Utility functions\n  static bytesToHex(bytes: Uint8Array): string {\n    return Array.from(bytes)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('');\n  }\n  \n  static hexToBytes(hex: string): Uint8Array {\n    if (hex.length % 2 !== 0) {\n      throw new OlocusError('Hex string must have even length');\n    }\n    \n    const bytes = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n      const byte = parseInt(hex.substr(i * 2, 2), 16);\n      if (isNaN(byte)) {\n        throw new OlocusError(`Invalid hex string: ${hex}`);\n      }\n      bytes[i] = byte;\n    }\n    return bytes;\n  }\n  \n  static encodeString(str: string): Uint8Array {\n    return new TextEncoder().encode(str);\n  }\n  \n  static decodeString(bytes: Uint8Array): string {\n    return new TextDecoder().decode(bytes);\n  }\n}\n\n// Re-export main classes\nexport { KeyPair, Block, Chain, Olocus };\n\n// Default export\nexport default Olocus;\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(e.h3,{id:"size-optimization-techniques",children:"Size Optimization Techniques"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-toml",children:'# Cargo.toml - Aggressive size optimization\n[profile.release]\ncodegen-units = 1\nlto = "fat"\nopt-level = "z"\nstrip = "symbols"\npanic = "abort"\noverflow-checks = false\n\n[profile.release.package.olocus-ffi]\nopt-level = 3  # Optimize for speed for core operations\n\n# Remove unnecessary features\n[dependencies]\nserde = { version = "1.0", default-features = false, features = ["derive"] }\nwasm-bindgen = { version = "0.2", default-features = false, features = ["std"] }\n\n# Use smaller alternatives\ngetrandom = { version = "0.2", features = ["js"] }\nsha2 = { version = "0.10", default-features = false }\n'})}),"\n",(0,a.jsx)(e.h3,{id:"runtime-optimization",children:"Runtime Optimization"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-rust",children:'// Performance monitoring and optimization\nuse std::time::Instant;\nuse web_sys::console;\n\n#[wasm_bindgen]\npub struct PerformanceTimer {\n    start: f64,\n    label: String,\n}\n\n#[wasm_bindgen]\nimpl PerformanceTimer {\n    #[wasm_bindgen(constructor)]\n    pub fn new(label: &str) -> PerformanceTimer {\n        let start = web_sys::window()\n            .and_then(|w| w.performance())\n            .map(|p| p.now())\n            .unwrap_or(0.0);\n            \n        PerformanceTimer {\n            start,\n            label: label.to_string(),\n        }\n    }\n    \n    pub fn elapsed(&self) -> f64 {\n        let now = web_sys::window()\n            .and_then(|w| w.performance())\n            .map(|p| p.now())\n            .unwrap_or(0.0);\n        now - self.start\n    }\n    \n    pub fn finish(&self) {\n        let elapsed = self.elapsed();\n        console::log_1(&format!("{}: {:.2}ms", self.label, elapsed).into());\n    }\n}\n\n// Batch operations for better performance\n#[wasm_bindgen]\npub fn verify_blocks_batch(block_ids: &[u32]) -> Vec<bool> {\n    let _timer = PerformanceTimer::new("verify_blocks_batch");\n    \n    let state = GLOBAL_STATE.lock().unwrap();\n    \n    let results: Vec<bool> = block_ids\n        .iter()\n        .map(|&id| {\n            state.blocks.get(&id)\n                .map(|block| block.verify().is_ok())\n                .unwrap_or(false)\n        })\n        .collect();\n    \n    _timer.finish();\n    results\n}\n\n// Memory-efficient serialization\n#[wasm_bindgen]\npub fn serialize_chain_streaming(chain_id: u32, chunk_size: usize) -> js_sys::AsyncIterator {\n    // Implementation would return an async iterator for large chains\n    todo!("Streaming serialization implementation")\n}\n\n// Object pooling for frequent allocations\nstatic mut BLOCK_POOL: Vec<Block> = Vec::new();\n\n#[wasm_bindgen]\npub fn get_pooled_block() -> u32 {\n    unsafe {\n        if let Some(block) = BLOCK_POOL.pop() {\n            let mut state = GLOBAL_STATE.lock().unwrap();\n            let id = state.next_id();\n            state.blocks.insert(id, block);\n            return id;\n        }\n    }\n    0 // No pooled blocks available\n}\n\n#[wasm_bindgen]\npub fn return_block_to_pool(block_id: u32) {\n    let mut state = GLOBAL_STATE.lock().unwrap();\n    if let Some(block) = state.blocks.remove(&block_id) {\n        unsafe {\n            if BLOCK_POOL.len() < 100 {  // Limit pool size\n                BLOCK_POOL.push(block);\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"browser-integration-examples",children:"Browser Integration Examples"}),"\n",(0,a.jsx)(e.h3,{id:"vanilla-javascript",children:"Vanilla JavaScript"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>Olocus WASM Demo</title>\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }\n        button { margin: 5px; padding: 10px 15px; }\n        textarea { width: 100%; height: 100px; }\n        .output { background: #f5f5f5; padding: 10px; border-radius: 3px; font-family: monospace; }\n    </style>\n</head>\n<body>\n    <h1>Olocus WebAssembly Demo</h1>\n    \n    <div class=\"section\">\n        <h2>Initialization</h2>\n        <button id=\"init-btn\">Initialize Olocus</button>\n        <button id=\"shutdown-btn\" disabled>Shutdown</button>\n        <div id=\"init-status\" class=\"output\">Not initialized</div>\n    </div>\n    \n    <div class=\"section\">\n        <h2>Key Management</h2>\n        <button id=\"generate-key-btn\" disabled>Generate KeyPair</button>\n        <button id=\"import-key-btn\" disabled>Import from Hex</button>\n        <input type=\"text\" id=\"key-hex\" placeholder=\"64-character private key hex\" />\n        <div id=\"key-info\" class=\"output\">No key generated</div>\n    </div>\n    \n    <div class=\"section\">\n        <h2>Block Operations</h2>\n        <textarea id=\"payload-input\" placeholder=\"Enter block payload...\"></textarea>\n        <button id=\"create-genesis-btn\" disabled>Create Genesis Block</button>\n        <button id=\"add-block-btn\" disabled>Add Block to Chain</button>\n        <div id=\"block-info\" class=\"output\">No blocks created</div>\n    </div>\n    \n    <div class=\"section\">\n        <h2>Chain Operations</h2>\n        <button id=\"create-chain-btn\" disabled>Create Chain</button>\n        <button id=\"verify-chain-btn\" disabled>Verify Chain</button>\n        <button id=\"export-chain-btn\" disabled>Export as JSON</button>\n        <div id=\"chain-info\" class=\"output\">No chain created</div>\n    </div>\n    \n    <div class=\"section\">\n        <h2>Performance</h2>\n        <button id=\"benchmark-btn\" disabled>Run Benchmark</button>\n        <div id=\"performance-info\" class=\"output\">Click benchmark to test performance</div>\n    </div>\n\n    <script type=\"module\">\n        import { Olocus, KeyPair, Block, Chain } from './pkg/olocus-wasm.js';\n        \n        let keyPair = null;\n        let currentBlock = null;\n        let chain = null;\n        \n        // DOM elements\n        const initBtn = document.getElementById('init-btn');\n        const shutdownBtn = document.getElementById('shutdown-btn');\n        const initStatus = document.getElementById('init-status');\n        const generateKeyBtn = document.getElementById('generate-key-btn');\n        const importKeyBtn = document.getElementById('import-key-btn');\n        const keyHexInput = document.getElementById('key-hex');\n        const keyInfo = document.getElementById('key-info');\n        const payloadInput = document.getElementById('payload-input');\n        const createGenesisBtn = document.getElementById('create-genesis-btn');\n        const addBlockBtn = document.getElementById('add-block-btn');\n        const blockInfo = document.getElementById('block-info');\n        const createChainBtn = document.getElementById('create-chain-btn');\n        const verifyChainBtn = document.getElementById('verify-chain-btn');\n        const exportChainBtn = document.getElementById('export-chain-btn');\n        const chainInfo = document.getElementById('chain-info');\n        const benchmarkBtn = document.getElementById('benchmark-btn');\n        const performanceInfo = document.getElementById('performance-info');\n        \n        // Initialize Olocus\n        initBtn.addEventListener('click', async () => {\n            try {\n                initBtn.disabled = true;\n                initStatus.textContent = 'Initializing...';\n                \n                await Olocus.initialize({ debug: true });\n                \n                initStatus.textContent = `Initialized Olocus v${Olocus.version}`;\n                shutdownBtn.disabled = false;\n                generateKeyBtn.disabled = false;\n                importKeyBtn.disabled = false;\n                createChainBtn.disabled = false;\n                benchmarkBtn.disabled = false;\n            } catch (error) {\n                initStatus.textContent = `Initialization failed: ${error.message}`;\n                initBtn.disabled = false;\n            }\n        });\n        \n        // Shutdown\n        shutdownBtn.addEventListener('click', () => {\n            Olocus.shutdown();\n            initStatus.textContent = 'Shutdown complete';\n            \n            // Reset UI\n            initBtn.disabled = false;\n            shutdownBtn.disabled = true;\n            generateKeyBtn.disabled = true;\n            createGenesisBtn.disabled = true;\n            addBlockBtn.disabled = true;\n            createChainBtn.disabled = true;\n            verifyChainBtn.disabled = true;\n            exportChainBtn.disabled = true;\n            benchmarkBtn.disabled = true;\n            \n            keyInfo.textContent = 'No key generated';\n            blockInfo.textContent = 'No blocks created';\n            chainInfo.textContent = 'No chain created';\n        });\n        \n        // Generate KeyPair\n        generateKeyBtn.addEventListener('click', () => {\n            try {\n                keyPair = KeyPair.generate();\n                const publicKeyHex = Olocus.bytesToHex(keyPair.publicKey);\n                const privateKeyHex = Olocus.bytesToHex(keyPair.privateKey);\n                \n                keyInfo.innerHTML = `\n                    <strong>Public Key:</strong><br>${publicKeyHex}<br>\n                    <strong>Private Key:</strong><br>${privateKeyHex}\n                `;\n                \n                createGenesisBtn.disabled = false;\n            } catch (error) {\n                keyInfo.textContent = `Key generation failed: ${error.message}`;\n            }\n        });\n        \n        // Import KeyPair\n        importKeyBtn.addEventListener('click', () => {\n            try {\n                const hexKey = keyHexInput.value.trim();\n                if (hexKey.length !== 64) {\n                    throw new Error('Private key must be 64 hex characters');\n                }\n                \n                const privateKeyBytes = Olocus.hexToBytes(hexKey);\n                keyPair = KeyPair.fromBytes(privateKeyBytes);\n                \n                const publicKeyHex = Olocus.bytesToHex(keyPair.publicKey);\n                keyInfo.innerHTML = `\n                    <strong>Imported Key</strong><br>\n                    <strong>Public Key:</strong><br>${publicKeyHex}\n                `;\n                \n                createGenesisBtn.disabled = false;\n            } catch (error) {\n                keyInfo.textContent = `Key import failed: ${error.message}`;\n            }\n        });\n        \n        // Create Genesis Block\n        createGenesisBtn.addEventListener('click', () => {\n            try {\n                const payload = payloadInput.value || 'Genesis block';\n                currentBlock = Block.createGenesis(payload, 0, keyPair);\n                \n                const info = currentBlock.getInfo();\n                blockInfo.innerHTML = `\n                    <strong>Genesis Block Created</strong><br>\n                    <strong>Index:</strong> ${info.index}<br>\n                    <strong>Timestamp:</strong> ${info.timestamp.toISOString()}<br>\n                    <strong>Hash:</strong> ${Olocus.bytesToHex(info.hash)}<br>\n                    <strong>Payload:</strong> ${Olocus.decodeString(info.payload)}<br>\n                    <strong>Valid:</strong> ${currentBlock.verify()}\n                `;\n                \n                addBlockBtn.disabled = false;\n            } catch (error) {\n                blockInfo.textContent = `Block creation failed: ${error.message}`;\n            }\n        });\n        \n        // Create Chain\n        createChainBtn.addEventListener('click', () => {\n            try {\n                chain = Chain.create();\n                chainInfo.textContent = 'Empty chain created';\n                \n                verifyChainBtn.disabled = false;\n                exportChainBtn.disabled = false;\n            } catch (error) {\n                chainInfo.textContent = `Chain creation failed: ${error.message}`;\n            }\n        });\n        \n        // Add Block to Chain\n        addBlockBtn.addEventListener('click', () => {\n            try {\n                if (!chain) {\n                    throw new Error('Create a chain first');\n                }\n                if (!currentBlock) {\n                    throw new Error('Create a block first');\n                }\n                \n                chain.addBlock(currentBlock);\n                \n                const chainInfoData = chain.getInfo();\n                chainInfo.innerHTML = `\n                    <strong>Chain Info</strong><br>\n                    <strong>Length:</strong> ${chainInfoData.length}<br>\n                    <strong>Valid:</strong> ${chain.verify()}<br>\n                    <strong>Blocks:</strong> ${chainInfoData.blocks.length}\n                `;\n                \n                // Create next block if there's more payload\n                if (payloadInput.value.trim()) {\n                    const payload = `Block ${chainInfoData.length}: ${payloadInput.value}`;\n                    const lastBlock = chain.getBlock(chainInfoData.length - 1);\n                    currentBlock = Block.create(\n                        chainInfoData.length,\n                        lastBlock.hash,\n                        payload,\n                        0,\n                        keyPair\n                    );\n                    \n                    blockInfo.innerHTML += '<br><strong>Next block ready for adding</strong>';\n                }\n            } catch (error) {\n                chainInfo.textContent = `Add block failed: ${error.message}`;\n            }\n        });\n        \n        // Verify Chain\n        verifyChainBtn.addEventListener('click', () => {\n            try {\n                if (!chain) {\n                    throw new Error('Create a chain first');\n                }\n                \n                const isValid = chain.verify();\n                const chainInfoData = chain.getInfo();\n                \n                chainInfo.innerHTML = `\n                    <strong>Chain Verification</strong><br>\n                    <strong>Length:</strong> ${chainInfoData.length}<br>\n                    <strong>Valid:</strong> ${isValid ? 'YES' : 'NO'}<br>\n                    <strong>Memory Usage:</strong> ${JSON.stringify(Olocus.getMemoryUsage(), null, 2)}\n                `;\n            } catch (error) {\n                chainInfo.textContent = `Verification failed: ${error.message}`;\n            }\n        });\n        \n        // Export Chain\n        exportChainBtn.addEventListener('click', () => {\n            try {\n                if (!chain) {\n                    throw new Error('Create a chain first');\n                }\n                \n                const blocks = chain.getBlocks();\n                const exportData = blocks.map(block => {\n                    const info = block.getInfo();\n                    return {\n                        index: info.index,\n                        timestamp: info.timestamp.toISOString(),\n                        hash: Olocus.bytesToHex(info.hash),\n                        payload: Olocus.decodeString(info.payload),\n                        json: block.toJSON()\n                    };\n                });\n                \n                const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                    type: 'application/json'\n                });\n                \n                const url = URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = 'olocus-chain.json';\n                a.click();\n                URL.revokeObjectURL(url);\n                \n                chainInfo.textContent += `\\nExported ${blocks.length} blocks`;\n            } catch (error) {\n                chainInfo.textContent = `Export failed: ${error.message}`;\n            }\n        });\n        \n        // Benchmark\n        benchmarkBtn.addEventListener('click', async () => {\n            performanceInfo.textContent = 'Running benchmark...';\n            \n            try {\n                const results = await runBenchmark();\n                performanceInfo.innerHTML = `\n                    <strong>Benchmark Results</strong><br>\n                    ${Object.entries(results)\n                        .map(([key, value]) => `<strong>${key}:</strong> ${value}`)\n                        .join('<br>')}\n                `;\n            } catch (error) {\n                performanceInfo.textContent = `Benchmark failed: ${error.message}`;\n            }\n        });\n        \n        async function runBenchmark() {\n            const results = {};\n            \n            // Key generation benchmark\n            const keyStart = performance.now();\n            const testKeys = [];\n            for (let i = 0; i < 100; i++) {\n                testKeys.push(KeyPair.generate());\n            }\n            results['Key Generation (100)'] = `${(performance.now() - keyStart).toFixed(2)}ms`;\n            \n            // Block creation benchmark\n            const blockStart = performance.now();\n            const testBlocks = [];\n            for (let i = 0; i < 100; i++) {\n                const block = Block.createGenesis(`Test payload ${i}`, 0, testKeys[i % testKeys.length]);\n                testBlocks.push(block);\n            }\n            results['Block Creation (100)'] = `${(performance.now() - blockStart).toFixed(2)}ms`;\n            \n            // Block verification benchmark\n            const verifyStart = performance.now();\n            let verifiedCount = 0;\n            for (const block of testBlocks) {\n                if (block.verify()) verifiedCount++;\n            }\n            results['Block Verification (100)'] = `${(performance.now() - verifyStart).toFixed(2)}ms`;\n            results['Verified Blocks'] = `${verifiedCount}/100`;\n            \n            // Hashing benchmark\n            const hashStart = performance.now();\n            const testData = new TextEncoder().encode('Test data for hashing benchmark');\n            for (let i = 0; i < 1000; i++) {\n                Olocus.hash(testData);\n            }\n            results['SHA-256 Hashing (1000)'] = `${(performance.now() - hashStart).toFixed(2)}ms`;\n            \n            // Signing benchmark\n            const signStart = performance.now();\n            const testKey = testKeys[0];\n            for (let i = 0; i < 100; i++) {\n                testKey.sign(testData);\n            }\n            results['Signing (100)'] = `${(performance.now() - signStart).toFixed(2)}ms`;\n            \n            // Cleanup\n            testKeys.forEach(key => key.destroy());\n            testBlocks.forEach(block => block.destroy());\n            \n            results['Memory Cleanup'] = `${Olocus.cleanupObjects()} objects cleaned`;\n            \n            return results;\n        }\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,a.jsx)(e.h3,{id:"react-integration",children:"React Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:"// App.tsx\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Olocus, KeyPair, Block, Chain, OlocusError } from './olocus-wasm';\nimport './App.css';\n\ninterface AppState {\n  initialized: boolean;\n  loading: boolean;\n  error: string | null;\n  keyPair: KeyPair | null;\n  chain: Chain | null;\n  blocks: Block[];\n}\n\nconst App: React.FC = () => {\n  const [state, setState] = useState<AppState>({\n    initialized: false,\n    loading: false,\n    error: null,\n    keyPair: null,\n    chain: null,\n    blocks: []\n  });\n  \n  const [payload, setPayload] = useState('Hello, Olocus!');\n  \n  const updateState = useCallback((updates: Partial<AppState>) => {\n    setState(prev => ({ ...prev, ...updates }));\n  }, []);\n  \n  const handleError = useCallback((error: unknown) => {\n    const message = error instanceof Error ? error.message : String(error);\n    updateState({ error: message, loading: false });\n  }, [updateState]);\n  \n  useEffect(() => {\n    initializeOlocus();\n    \n    return () => {\n      if (state.initialized) {\n        Olocus.shutdown();\n      }\n    };\n  }, []);\n  \n  const initializeOlocus = async () => {\n    try {\n      updateState({ loading: true, error: null });\n      \n      await Olocus.initialize({\n        debug: process.env.NODE_ENV === 'development'\n      });\n      \n      updateState({\n        initialized: true,\n        loading: false\n      });\n    } catch (error) {\n      handleError(error);\n    }\n  };\n  \n  const generateKeyPair = useCallback(() => {\n    try {\n      const keyPair = KeyPair.generate();\n      updateState({ keyPair, error: null });\n    } catch (error) {\n      handleError(error);\n    }\n  }, [handleError, updateState]);\n  \n  const createChain = useCallback(() => {\n    try {\n      const chain = Chain.create();\n      updateState({ chain, blocks: [], error: null });\n    } catch (error) {\n      handleError(error);\n    }\n  }, [handleError, updateState]);\n  \n  const createGenesisBlock = useCallback(() => {\n    try {\n      if (!state.keyPair) {\n        throw new OlocusError('Generate a keypair first');\n      }\n      \n      const block = Block.createGenesis(payload, 0, state.keyPair);\n      updateState({\n        blocks: [block],\n        error: null\n      });\n    } catch (error) {\n      handleError(error);\n    }\n  }, [state.keyPair, payload, handleError, updateState]);\n  \n  const addBlock = useCallback(() => {\n    try {\n      if (!state.chain) {\n        throw new OlocusError('Create a chain first');\n      }\n      \n      if (state.blocks.length === 0) {\n        throw new OlocusError('Create a genesis block first');\n      }\n      \n      const lastBlock = state.blocks[state.blocks.length - 1];\n      state.chain.addBlock(lastBlock);\n      \n      // Create next block if chain has blocks\n      if (state.chain.length > 0 && state.keyPair) {\n        const nextIndex = state.chain.length;\n        const nextBlock = Block.create(\n          nextIndex,\n          lastBlock.hash,\n          `Block ${nextIndex}: ${payload}`,\n          0,\n          state.keyPair\n        );\n        \n        updateState({\n          blocks: [...state.blocks, nextBlock],\n          error: null\n        });\n      }\n    } catch (error) {\n      handleError(error);\n    }\n  }, [state.chain, state.blocks, state.keyPair, payload, handleError, updateState]);\n  \n  const verifyChain = useCallback(() => {\n    try {\n      if (!state.chain) {\n        throw new OlocusError('Create a chain first');\n      }\n      \n      const isValid = state.chain.verify();\n      updateState({\n        error: isValid ? null : 'Chain verification failed'\n      });\n      \n      alert(isValid ? 'Chain is valid!' : 'Chain verification failed!');\n    } catch (error) {\n      handleError(error);\n    }\n  }, [state.chain, handleError, updateState]);\n  \n  const exportChain = useCallback(() => {\n    try {\n      if (!state.chain) {\n        throw new OlocusError('Create a chain first');\n      }\n      \n      const chainInfo = state.chain.getInfo();\n      const exportData = {\n        version: Olocus.version,\n        timestamp: new Date().toISOString(),\n        chain: chainInfo\n      };\n      \n      const blob = new Blob(\n        [JSON.stringify(exportData, null, 2)],\n        { type: 'application/json' }\n      );\n      \n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `olocus-chain-${Date.now()}.json`;\n      a.click();\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      handleError(error);\n    }\n  }, [state.chain, handleError]);\n  \n  if (state.loading) {\n    return (\n      <div className=\"app loading\">\n        <h1>Loading Olocus...</h1>\n        <p>Initializing WebAssembly module...</p>\n      </div>\n    );\n  }\n  \n  if (!state.initialized) {\n    return (\n      <div className=\"app error\">\n        <h1>Initialization Failed</h1>\n        <p>{state.error || 'Failed to initialize Olocus WASM'}</p>\n        <button onClick={initializeOlocus}>Retry</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"app\">\n      <h1>Olocus WebAssembly Demo</h1>\n      <p>Version: {Olocus.version}</p>\n      \n      {state.error && (\n        <div className=\"error-banner\">\n          Error: {state.error}\n          <button onClick={() => updateState({ error: null })}>\u2715</button>\n        </div>\n      )}\n      \n      <div className=\"section\">\n        <h2>Key Management</h2>\n        <button onClick={generateKeyPair} disabled={!!state.keyPair}>\n          Generate KeyPair\n        </button>\n        \n        {state.keyPair && (\n          <div className=\"key-info\">\n            <p><strong>Public Key:</strong></p>\n            <code>{Olocus.bytesToHex(state.keyPair.publicKey)}</code>\n          </div>\n        )}\n      </div>\n      \n      <div className=\"section\">\n        <h2>Chain Operations</h2>\n        <button onClick={createChain} disabled={!!state.chain}>\n          Create Chain\n        </button>\n        \n        {state.chain && (\n          <div className=\"chain-info\">\n            <p>Chain Length: {state.chain.length}</p>\n            <p>Is Empty: {state.chain.isEmpty ? 'Yes' : 'No'}</p>\n            \n            <button onClick={verifyChain} disabled={state.chain.isEmpty}>\n              Verify Chain\n            </button>\n            <button onClick={exportChain} disabled={state.chain.isEmpty}>\n              Export Chain\n            </button>\n          </div>\n        )}\n      </div>\n      \n      <div className=\"section\">\n        <h2>Block Operations</h2>\n        <div className=\"input-group\">\n          <label htmlFor=\"payload\">Block Payload:</label>\n          <textarea\n            id=\"payload\"\n            value={payload}\n            onChange={(e) => setPayload(e.target.value)}\n            placeholder=\"Enter block payload...\"\n          />\n        </div>\n        \n        <button \n          onClick={createGenesisBlock}\n          disabled={!state.keyPair || !state.chain || state.blocks.length > 0}\n        >\n          Create Genesis Block\n        </button>\n        \n        <button\n          onClick={addBlock}\n          disabled={!state.chain || state.blocks.length === 0}\n        >\n          Add Block to Chain\n        </button>\n        \n        {state.blocks.length > 0 && (\n          <div className=\"blocks-list\">\n            <h3>Created Blocks:</h3>\n            {state.blocks.map((block, index) => {\n              const info = block.getInfo();\n              return (\n                <div key={index} className=\"block-item\">\n                  <p><strong>Index:</strong> {info.index}</p>\n                  <p><strong>Hash:</strong> <code>{Olocus.bytesToHex(info.hash)}</code></p>\n                  <p><strong>Payload:</strong> {Olocus.decodeString(info.payload)}</p>\n                  <p><strong>Valid:</strong> {block.verify() ? 'Yes' : 'No'}</p>\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n      \n      <div className=\"section\">\n        <h2>Performance</h2>\n        <PerformanceMonitor />\n      </div>\n    </div>\n  );\n};\n\nconst PerformanceMonitor: React.FC = () => {\n  const [memoryUsage, setMemoryUsage] = useState<any>(null);\n  const [benchmarkResults, setBenchmarkResults] = useState<any>(null);\n  const [running, setRunning] = useState(false);\n  \n  useEffect(() => {\n    const interval = setInterval(() => {\n      setMemoryUsage(Olocus.getMemoryUsage());\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, []);\n  \n  const runBenchmark = async () => {\n    setRunning(true);\n    setBenchmarkResults(null);\n    \n    try {\n      const results: Record<string, string> = {};\n      \n      // Key generation benchmark\n      const keyStart = performance.now();\n      const testKeys = Array.from({ length: 100 }, () => KeyPair.generate());\n      results['Key Generation (100)'] = `${(performance.now() - keyStart).toFixed(2)}ms`;\n      \n      // Block creation benchmark\n      const blockStart = performance.now();\n      const testBlocks = testKeys.map((key, i) => \n        Block.createGenesis(`Benchmark block ${i}`, 0, key)\n      );\n      results['Block Creation (100)'] = `${(performance.now() - blockStart).toFixed(2)}ms`;\n      \n      // Verification benchmark\n      const verifyStart = performance.now();\n      const verifiedCount = testBlocks.filter(block => block.verify()).length;\n      results['Block Verification (100)'] = `${(performance.now() - verifyStart).toFixed(2)}ms`;\n      results['Verification Success Rate'] = `${verifiedCount}/100`;\n      \n      // Cleanup\n      testKeys.forEach(key => key.destroy());\n      testBlocks.forEach(block => block.destroy());\n      \n      const cleanedObjects = Olocus.cleanupObjects();\n      results['Objects Cleaned'] = cleanedObjects.toString();\n      \n      setBenchmarkResults(results);\n    } catch (error) {\n      console.error('Benchmark failed:', error);\n    } finally {\n      setRunning(false);\n    }\n  };\n  \n  return (\n    <div>\n      <div className=\"memory-info\">\n        <h4>Memory Usage</h4>\n        {memoryUsage && (\n          <pre>{JSON.stringify(memoryUsage, null, 2)}</pre>\n        )}\n      </div>\n      \n      <button onClick={runBenchmark} disabled={running}>\n        {running ? 'Running Benchmark...' : 'Run Performance Benchmark'}\n      </button>\n      \n      {benchmarkResults && (\n        <div className=\"benchmark-results\">\n          <h4>Benchmark Results</h4>\n          <ul>\n            {Object.entries(benchmarkResults).map(([key, value]) => (\n              <li key={key}>\n                <strong>{key}:</strong> {value as string}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.h2,{id:"deployment-and-distribution",children:"Deployment and Distribution"}),"\n",(0,a.jsx)(e.h3,{id:"npm-package-setup",children:"NPM Package Setup"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-json",children:'{\n  "name": "@olocus/wasm",\n  "version": "1.16.1",\n  "description": "Olocus Protocol WebAssembly bindings",\n  "main": "olocus_ffi.js",\n  "module": "olocus_ffi.js",\n  "types": "olocus_ffi.d.ts",\n  "files": [\n    "olocus_ffi_bg.wasm",\n    "olocus_ffi.js",\n    "olocus_ffi.d.ts",\n    "olocus-wasm.js",\n    "olocus-wasm.d.ts",\n    "README.md"\n  ],\n  "scripts": {\n    "build": "./build-wasm.sh web release",\n    "build:dev": "./build-wasm.sh web dev",\n    "build:all": "./build-all-targets.sh",\n    "test": "npm run build:dev && npm run test:node",\n    "test:node": "node test/node-test.js",\n    "test:browser": "npm run build && npm run serve",\n    "serve": "python3 -m http.server 8000",\n    "size-check": "wasm-opt --print-features pkg/olocus_ffi_bg.wasm"\n  },\n  "repository": {\n    "type": "git",\n    "url": "https://codeberg.org/olocus/protocol.git"\n  },\n  "keywords": [\n    "blockchain",\n    "cryptography",\n    "wasm",\n    "webassembly",\n    "olocus",\n    "timestamping"\n  ],\n  "license": "MIT",\n  "devDependencies": {\n    "@types/node": "^18.0.0",\n    "typescript": "^4.8.0"\n  },\n  "engines": {\n    "node": ">=16.0.0"\n  },\n  "sideEffects": false\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"cdn-distribution",children:"CDN Distribution"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:"\x3c!-- Via JSDelivr CDN --\x3e\n<script type=\"module\">\n  import init, { Olocus } from 'https://cdn.jsdelivr.net/npm/@olocus/wasm@latest/olocus_ffi.js';\n  \n  async function main() {\n    await init();\n    await Olocus.initialize();\n    console.log('Olocus loaded from CDN:', Olocus.version);\n  }\n  \n  main();\n<\/script>\n\n\x3c!-- Via UNPKG CDN --\x3e\n<script type=\"module\">\n  import init, { Olocus } from 'https://unpkg.com/@olocus/wasm@latest/olocus_ffi.js';\n  \n  async function main() {\n    await init();\n    await Olocus.initialize();\n    console.log('Olocus loaded from CDN:', Olocus.version);\n  }\n  \n  main();\n<\/script>\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,a.jsx)(e.h3,{id:"nodejs-test-suite",children:"Node.js Test Suite"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// test/node-test.js\nconst { Olocus, KeyPair, Block, Chain } = require('../pkg/olocus_ffi.js');\nconst assert = require('assert');\n\nasync function runTests() {\n    console.log('Running Olocus WASM tests...');\n    \n    // Initialize\n    await Olocus.initialize();\n    console.log(`\u2713 Initialized Olocus v${Olocus.version}`);\n    \n    // Test key generation\n    const keyPair = KeyPair.generate();\n    assert(keyPair.publicKey.length === 32, 'Public key should be 32 bytes');\n    assert(keyPair.privateKey.length === 32, 'Private key should be 32 bytes');\n    console.log('\u2713 Key generation works');\n    \n    // Test block creation\n    const block = Block.createGenesis('Test payload', 0, keyPair);\n    assert(block.index === 0, 'Genesis block index should be 0');\n    assert(block.verify(), 'Block should verify');\n    console.log('\u2713 Block creation and verification works');\n    \n    // Test chain operations\n    const chain = Chain.create();\n    assert(chain.isEmpty, 'New chain should be empty');\n    \n    chain.addBlock(block);\n    assert(chain.length === 1, 'Chain should have 1 block');\n    assert(chain.verify(), 'Chain should verify');\n    console.log('\u2713 Chain operations work');\n    \n    // Test serialization\n    const blockJson = block.toJSON();\n    assert(typeof blockJson === 'string', 'Block JSON should be string');\n    \n    const blockBytes = block.toBytes();\n    assert(blockBytes instanceof Uint8Array, 'Block bytes should be Uint8Array');\n    console.log('\u2713 Serialization works');\n    \n    // Test cryptographic operations\n    const message = new TextEncoder().encode('Test message');\n    const signature = keyPair.sign(message);\n    assert(signature.length === 64, 'Signature should be 64 bytes');\n    \n    const isValid = Olocus.verify(keyPair.publicKey, message, signature);\n    assert(isValid, 'Signature should verify');\n    console.log('\u2713 Cryptographic operations work');\n    \n    // Test memory cleanup\n    keyPair.destroy();\n    block.destroy();\n    chain.destroy();\n    \n    const cleanedObjects = Olocus.cleanupObjects();\n    console.log(`\u2713 Cleaned up ${cleanedObjects} objects`);\n    \n    Olocus.shutdown();\n    console.log('\u2713 All tests passed!');\n}\n\nrunTests().catch(console.error);\n"})}),"\n",(0,a.jsx)(e.h3,{id:"browser-test-suite",children:"Browser Test Suite"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:"\x3c!-- test/browser-test.html --\x3e\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Olocus WASM Browser Tests</title>\n    <style>\n        body { font-family: monospace; padding: 20px; }\n        .test { margin: 10px 0; }\n        .pass { color: green; }\n        .fail { color: red; }\n        .pending { color: orange; }\n    </style>\n</head>\n<body>\n    <h1>Olocus WASM Browser Tests</h1>\n    <div id=\"test-results\"></div>\n    \n    <script type=\"module\">\n        import { Olocus, KeyPair, Block, Chain } from '../pkg/olocus_ffi.js';\n        \n        const results = document.getElementById('test-results');\n        \n        function addResult(test, status, message) {\n            const div = document.createElement('div');\n            div.className = `test ${status}`;\n            div.textContent = `${status.toUpperCase()}: ${test} - ${message}`;\n            results.appendChild(div);\n        }\n        \n        async function runTest(name, testFn) {\n            try {\n                addResult(name, 'pending', 'Running...');\n                await testFn();\n                addResult(name, 'pass', 'Passed');\n            } catch (error) {\n                addResult(name, 'fail', `Failed: ${error.message}`);\n            }\n        }\n        \n        async function runAllTests() {\n            await runTest('Initialization', async () => {\n                await Olocus.initialize({ debug: true });\n                if (!Olocus.isInitialized) {\n                    throw new Error('Not initialized');\n                }\n            });\n            \n            await runTest('Key Generation', async () => {\n                const keyPair = KeyPair.generate();\n                if (keyPair.publicKey.length !== 32) {\n                    throw new Error('Invalid public key length');\n                }\n                keyPair.destroy();\n            });\n            \n            await runTest('Block Operations', async () => {\n                const keyPair = KeyPair.generate();\n                const block = Block.createGenesis('Test', 0, keyPair);\n                \n                if (!block.verify()) {\n                    throw new Error('Block verification failed');\n                }\n                \n                block.destroy();\n                keyPair.destroy();\n            });\n            \n            await runTest('Chain Operations', async () => {\n                const chain = Chain.create();\n                const keyPair = KeyPair.generate();\n                const block = Block.createGenesis('Test', 0, keyPair);\n                \n                chain.addBlock(block);\n                \n                if (chain.length !== 1) {\n                    throw new Error('Invalid chain length');\n                }\n                \n                if (!chain.verify()) {\n                    throw new Error('Chain verification failed');\n                }\n                \n                chain.destroy();\n                block.destroy();\n                keyPair.destroy();\n            });\n            \n            await runTest('Performance', async () => {\n                const start = performance.now();\n                const keyPairs = [];\n                \n                // Generate 100 key pairs\n                for (let i = 0; i < 100; i++) {\n                    keyPairs.push(KeyPair.generate());\n                }\n                \n                const keyGenTime = performance.now() - start;\n                \n                // Create 100 blocks\n                const blockStart = performance.now();\n                const blocks = [];\n                for (let i = 0; i < 100; i++) {\n                    blocks.push(Block.createGenesis(`Block ${i}`, 0, keyPairs[i]));\n                }\n                const blockTime = performance.now() - blockStart;\n                \n                // Cleanup\n                keyPairs.forEach(kp => kp.destroy());\n                blocks.forEach(b => b.destroy());\n                \n                addResult('Performance Details', 'pass', \n                    `Key gen: ${keyGenTime.toFixed(2)}ms, Block creation: ${blockTime.toFixed(2)}ms`);\n                \n                if (keyGenTime > 5000 || blockTime > 5000) {\n                    throw new Error('Performance too slow');\n                }\n            });\n            \n            await runTest('Memory Management', async () => {\n                const initialUsage = Olocus.getMemoryUsage();\n                \n                // Create many objects\n                const objects = [];\n                for (let i = 0; i < 50; i++) {\n                    objects.push(KeyPair.generate());\n                    objects.push(Block.createGenesis(`Test ${i}`, 0, objects[objects.length - 1]));\n                }\n                \n                const maxUsage = Olocus.getMemoryUsage();\n                \n                // Cleanup explicitly\n                objects.forEach(obj => obj.destroy());\n                const cleanedCount = Olocus.cleanupObjects();\n                \n                const finalUsage = Olocus.getMemoryUsage();\n                \n                addResult('Memory Usage', 'pass', \n                    `Initial: ${JSON.stringify(initialUsage)}, Max: ${JSON.stringify(maxUsage)}, Final: ${JSON.stringify(finalUsage)}`);\n                \n                if (finalUsage.keypairs > initialUsage.keypairs + 5) {\n                    throw new Error('Memory leak detected');\n                }\n            });\n            \n            addResult('All Tests', 'pass', 'Test suite completed');\n        }\n        \n        runAllTests().catch(error => {\n            addResult('Test Suite', 'fail', `Fatal error: ${error.message}`);\n        });\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"performance",children:"Performance"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsxs)(e.strong,{children:["Use ",(0,a.jsx)(e.code,{children:"wee_alloc"})]})," for smaller binary size"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enable LTO"})," and size optimizations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Batch operations"})," when possible"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pool objects"})," for frequent allocations"]}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.strong,{children:"Profile with browser DevTools"})}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Always destroy WASM objects"})," when done"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use try/finally"})," for guaranteed cleanup"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Monitor memory usage"})," in production"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Implement object pooling"})," for performance-critical apps"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use WeakRef"})," for optional cleanup"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Check initialization"})," before all operations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validate inputs"})," before WASM calls"]}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.strong,{children:"Provide meaningful error messages"})}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use Result types"})," for better error handling"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Log errors"})," for debugging"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"security",children:"Security"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Validate all inputs"})," from JavaScript"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use secure random"})," for cryptographic operations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Clear sensitive data"})," from memory"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Verify WASM integrity"})," in production"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use CSP headers"})," to protect against attacks"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"WASM not loading"}),": Check MIME types and CORS"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Memory access errors"}),": Ensure proper object lifecycle"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Performance issues"}),": Use Web Workers for heavy computation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Bundle size too large"}),": Enable optimizations and use wasm-opt"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Browser compatibility"}),": Provide fallbacks for older browsers"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"debug-tips",children:"Debug Tips"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use debug builds"})," for development"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enable console logging"})," with debug features"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Monitor network requests"})," for WASM loading"]}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.strong,{children:"Use browser performance tools"})}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test across different browsers"})," and devices"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var i=t(6540);const a={},s=i.createContext(a);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);