"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[640],{8358:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"extensions/credentials/revocation","title":"Credential Revocation","description":"Overview","source":"@site/docs/extensions/credentials/revocation.md","sourceDirName":"extensions/credentials","slug":"/extensions/credentials/revocation","permalink":"/docs/extensions/credentials/revocation","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/credentials/revocation.md","tags":[],"version":"current","lastUpdatedAt":null,"frontMatter":{}}');var o=t(4848),r=t(8453);const a={},s="Credential Revocation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Revocation Manager",id:"revocation-manager",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Zero-Knowledge Revocation",id:"zero-knowledge-revocation",level:3},{value:"Cryptographic Accumulator",id:"cryptographic-accumulator",level:3},{value:"Integration with Olocus Core",id:"integration-with-olocus-core",level:2},{value:"Block Payload Implementation",id:"block-payload-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Cryptographic Security",id:"cryptographic-security",level:3},{value:"Privacy Protection",id:"privacy-protection",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Registry Design",id:"registry-design",level:3},{value:"Privacy Guidelines",id:"privacy-guidelines",level:3},{value:"Error Handling",id:"error-handling",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"credential-revocation",children:"Credential Revocation"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"The Olocus Credentials extension implements comprehensive credential revocation mechanisms to ensure that invalidated credentials can be reliably identified and rejected. The system supports multiple revocation methods including traditional revocation lists, privacy-preserving accumulator-based schemes, and blockchain-based revocation registries."}),"\n",(0,o.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,o.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::{Measurement, Value, Uncertainty, Provenance};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet, BTreeSet};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationRegistry {\n    pub registry_id: String,\n    pub issuer_did: String,\n    pub revocation_method: RevocationMethod,\n    pub revocation_lists: HashMap<String, RevocationList>,\n    pub revocation_events: Vec<RevocationEvent>,\n    pub privacy_settings: RevocationPrivacySettings,\n    pub measurement_attestations: Vec<RevocationMeasurementAttestation>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationMethod {\n    RevocationList2020,\n    BitstringStatusList,\n    StatusList2021,\n    CryptoAccumulator,\n    BlockchainRegistry,\n    ZeroKnowledgeRevocation,\n    // Future: Advanced privacy-preserving methods\n    Anonymous,\n    Unlinkable,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationList {\n    pub id: String,\n    pub list_type: RevocationListType,\n    pub issuer: String,\n    pub issued: DateTime<Utc>,\n    pub updated: DateTime<Utc>,\n    pub next_update: Option<DateTime<Utc>>,\n    pub revocation_entries: BTreeSet<u64>,\n    pub suspension_entries: BTreeSet<u64>,\n    pub bitstring: Option<String>, // For bitstring-based lists\n    pub merkle_root: Option<String>, // For Merkle tree-based lists\n    pub accumulator_value: Option<String>, // For cryptographic accumulators\n    pub size: u64,\n    pub purpose: RevocationPurpose,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationListType {\n    SimpleList,\n    BitstringCompressed,\n    MerkleTree,\n    CryptoAccumulator,\n    BloomFilter,\n    ZKAccumulator,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationPurpose {\n    Revocation,   // Permanent invalidation\n    Suspension,   // Temporary invalidation\n    Both,         // List handles both revocation and suspension\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationEvent {\n    pub event_id: String,\n    pub credential_id: String,\n    pub revocation_index: u64,\n    pub event_type: RevocationEventType,\n    pub reason: RevocationReason,\n    pub timestamp: DateTime<Utc>,\n    pub effective_date: Option<DateTime<Utc>>,\n    pub revoked_by: String,\n    pub proof: RevocationProof,\n    pub measurement_evidence: Option<Measurement>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationEventType {\n    Revoke,       // Permanent revocation\n    Suspend,      // Temporary suspension\n    Reinstate,    // Reverse suspension\n    Update,       // Update revocation details\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationReason {\n    Superseded,                    // Credential replaced by newer version\n    PrivilegeWithdrawn,           // Privileges no longer valid\n    AffiliationChanged,           // Subject changed affiliation\n    KeyCompromise,                // Private key compromised\n    CACompromise,                 // Issuer key compromised\n    CertificateHold,              // Temporary hold\n    CessationOfOperation,         // Issuer ceased operations\n    Unspecified,                  // Reason not specified\n    MeasurementInvalidation,      // Olocus-specific: measurement no longer valid\n    LocationVerificationFailure,   // Olocus-specific: location claim invalid\n    IdentityVerificationFailure,  // Olocus-specific: identity claim invalid\n    Custom(String),               // Custom reason\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationProof {\n    pub proof_type: String,\n    pub verification_method: String,\n    pub signature: String,\n    pub created: DateTime<Utc>,\n    pub nonce: Option<String>,\n    pub challenge: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationPrivacySettings {\n    pub hide_revocation_reason: bool,\n    pub hide_revocation_timing: bool,\n    pub use_anonymous_revocation: bool,\n    pub batch_updates: bool,\n    pub update_frequency: RevocationUpdateFrequency,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationUpdateFrequency {\n    Realtime,\n    Hourly,\n    Daily,\n    Weekly,\n    Monthly,\n    OnDemand,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationMeasurementAttestation {\n    pub attestation_id: String,\n    pub credential_id: String,\n    pub measurement: Measurement,\n    pub attestation_type: AttestationType,\n    pub verifier_did: String,\n    pub attestation_proof: String,\n    pub timestamp: DateTime<Utc>,\n    pub validity_period: Option<chrono::Duration>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AttestationType {\n    LocationVerification,    // Attest to location accuracy\n    IdentityVerification,    // Attest to identity claims\n    BiometricVerification,   // Attest to biometric authenticity\n    DeviceIntegrity,         // Attest to device trustworthiness\n    MeasurementAccuracy,     // Attest to measurement precision\n    TemporalVerification,    // Attest to timing claims\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"revocation-manager",children:"Revocation Manager"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'impl RevocationRegistry {\n    pub fn new(\n        issuer_did: String,\n        method: RevocationMethod,\n        privacy_settings: RevocationPrivacySettings,\n    ) -> Self {\n        let registry_id = format!("urn:uuid:{}", Uuid::new_v4());\n        \n        Self {\n            registry_id,\n            issuer_did,\n            revocation_method: method,\n            revocation_lists: HashMap::new(),\n            revocation_events: Vec::new(),\n            privacy_settings,\n            measurement_attestations: Vec::new(),\n        }\n    }\n\n    pub fn create_revocation_list(\n        &mut self,\n        list_type: RevocationListType,\n        purpose: RevocationPurpose,\n        initial_size: u64,\n    ) -> Result<String, RevocationError> {\n        let list_id = format!("{}#list-{}", self.registry_id, self.revocation_lists.len());\n        \n        let revocation_list = RevocationList {\n            id: list_id.clone(),\n            list_type: list_type.clone(),\n            issuer: self.issuer_did.clone(),\n            issued: Utc::now(),\n            updated: Utc::now(),\n            next_update: self.calculate_next_update(),\n            revocation_entries: BTreeSet::new(),\n            suspension_entries: BTreeSet::new(),\n            bitstring: match list_type {\n                RevocationListType::BitstringCompressed => {\n                    Some(self.create_initial_bitstring(initial_size)?)\n                },\n                _ => None,\n            },\n            merkle_root: match list_type {\n                RevocationListType::MerkleTree => {\n                    Some(self.create_initial_merkle_root(initial_size)?)\n                },\n                _ => None,\n            },\n            accumulator_value: match list_type {\n                RevocationListType::CryptoAccumulator => {\n                    Some(self.create_initial_accumulator()?)\n                },\n                _ => None,\n            },\n            size: initial_size,\n            purpose,\n        };\n\n        self.revocation_lists.insert(list_id.clone(), revocation_list);\n        Ok(list_id)\n    }\n\n    pub fn revoke_credential(\n        &mut self,\n        credential_id: String,\n        revocation_index: u64,\n        reason: RevocationReason,\n        proof: RevocationProof,\n        measurement_evidence: Option<Measurement>,\n    ) -> Result<(), RevocationError> {\n        // Find appropriate revocation list\n        let list_id = self.find_revocation_list_for_credential(&credential_id)?;\n        \n        // Validate proof\n        self.validate_revocation_proof(&proof)?;\n\n        // Create revocation event\n        let event = RevocationEvent {\n            event_id: format!("rev-{}", Uuid::new_v4()),\n            credential_id: credential_id.clone(),\n            revocation_index,\n            event_type: RevocationEventType::Revoke,\n            reason: reason.clone(),\n            timestamp: Utc::now(),\n            effective_date: None,\n            revoked_by: proof.verification_method.clone(),\n            proof,\n            measurement_evidence: measurement_evidence.clone(),\n        };\n\n        // Update revocation list\n        if let Some(list) = self.revocation_lists.get_mut(&list_id) {\n            match &mut list.list_type {\n                RevocationListType::SimpleList => {\n                    list.revocation_entries.insert(revocation_index);\n                },\n                RevocationListType::BitstringCompressed => {\n                    self.update_bitstring(list, revocation_index, true)?;\n                },\n                RevocationListType::MerkleTree => {\n                    self.update_merkle_tree(list, revocation_index, true)?;\n                },\n                RevocationListType::CryptoAccumulator => {\n                    self.update_accumulator(list, revocation_index, true)?;\n                },\n                _ => return Err(RevocationError::UnsupportedListType),\n            }\n            \n            list.updated = Utc::now();\n            list.next_update = self.calculate_next_update();\n        }\n\n        // Record event\n        self.revocation_events.push(event);\n\n        // Add measurement evidence if provided\n        if let Some(measurement) = measurement_evidence {\n            self.add_measurement_attestation(credential_id, measurement)?;\n        }\n\n        Ok(())\n    }\n\n    pub fn suspend_credential(\n        &mut self,\n        credential_id: String,\n        revocation_index: u64,\n        reason: RevocationReason,\n        proof: RevocationProof,\n        suspension_period: Option<chrono::Duration>,\n    ) -> Result<(), RevocationError> {\n        let list_id = self.find_revocation_list_for_credential(&credential_id)?;\n        \n        self.validate_revocation_proof(&proof)?;\n\n        let effective_date = suspension_period.map(|duration| Utc::now() + duration);\n\n        let event = RevocationEvent {\n            event_id: format!("sus-{}", Uuid::new_v4()),\n            credential_id: credential_id.clone(),\n            revocation_index,\n            event_type: RevocationEventType::Suspend,\n            reason,\n            timestamp: Utc::now(),\n            effective_date,\n            revoked_by: proof.verification_method.clone(),\n            proof,\n            measurement_evidence: None,\n        };\n\n        if let Some(list) = self.revocation_lists.get_mut(&list_id) {\n            match list.purpose {\n                RevocationPurpose::Suspension | RevocationPurpose::Both => {\n                    list.suspension_entries.insert(revocation_index);\n                    \n                    match &mut list.list_type {\n                        RevocationListType::BitstringCompressed => {\n                            // Use separate bit for suspension\n                            self.update_suspension_bitstring(list, revocation_index, true)?;\n                        },\n                        _ => {}, // Other types handle suspension in the entries set\n                    }\n                },\n                RevocationPurpose::Revocation => {\n                    return Err(RevocationError::SuspensionNotSupported);\n                }\n            }\n            \n            list.updated = Utc::now();\n        }\n\n        self.revocation_events.push(event);\n        Ok(())\n    }\n\n    pub fn reinstate_credential(\n        &mut self,\n        credential_id: String,\n        revocation_index: u64,\n        proof: RevocationProof,\n    ) -> Result<(), RevocationError> {\n        let list_id = self.find_revocation_list_for_credential(&credential_id)?;\n        \n        self.validate_revocation_proof(&proof)?;\n\n        let event = RevocationEvent {\n            event_id: format!("rei-{}", Uuid::new_v4()),\n            credential_id: credential_id.clone(),\n            revocation_index,\n            event_type: RevocationEventType::Reinstate,\n            reason: RevocationReason::Unspecified,\n            timestamp: Utc::now(),\n            effective_date: None,\n            revoked_by: proof.verification_method.clone(),\n            proof,\n            measurement_evidence: None,\n        };\n\n        if let Some(list) = self.revocation_lists.get_mut(&list_id) {\n            list.suspension_entries.remove(&revocation_index);\n            \n            match &mut list.list_type {\n                RevocationListType::BitstringCompressed => {\n                    self.update_suspension_bitstring(list, revocation_index, false)?;\n                },\n                _ => {},\n            }\n            \n            list.updated = Utc::now();\n        }\n\n        self.revocation_events.push(event);\n        Ok(())\n    }\n\n    pub async fn check_revocation_status(\n        &self,\n        credential_id: &str,\n        revocation_index: u64,\n    ) -> Result<RevocationStatus, RevocationError> {\n        let list_id = self.find_revocation_list_for_credential(credential_id)?;\n        \n        let list = self.revocation_lists.get(&list_id)\n            .ok_or(RevocationError::ListNotFound(list_id))?;\n\n        let is_revoked = list.revocation_entries.contains(&revocation_index);\n        let is_suspended = list.suspension_entries.contains(&revocation_index);\n\n        // Check if suspension has expired\n        let suspension_active = if is_suspended {\n            self.is_suspension_active(credential_id, revocation_index)?\n        } else {\n            false\n        };\n\n        let status = if is_revoked {\n            RevocationStatus::Revoked {\n                revoked_at: self.get_revocation_timestamp(credential_id)?,\n                reason: self.get_revocation_reason(credential_id)?,\n            }\n        } else if suspension_active {\n            RevocationStatus::Suspended {\n                suspended_at: self.get_suspension_timestamp(credential_id)?,\n                expires_at: self.get_suspension_expiry(credential_id)?,\n                reason: self.get_suspension_reason(credential_id)?,\n            }\n        } else {\n            RevocationStatus::Valid {\n                last_checked: Utc::now(),\n                next_update: list.next_update,\n            }\n        };\n\n        Ok(status)\n    }\n\n    pub fn add_measurement_attestation(\n        &mut self,\n        credential_id: String,\n        measurement: Measurement,\n    ) -> Result<(), RevocationError> {\n        // Validate measurement for attestation purposes\n        self.validate_attestation_measurement(&measurement)?;\n\n        let attestation = RevocationMeasurementAttestation {\n            attestation_id: format!("att-{}", Uuid::new_v4()),\n            credential_id,\n            measurement,\n            attestation_type: self.determine_attestation_type(&measurement)?,\n            verifier_did: self.issuer_did.clone(), // Could be different verifier\n            attestation_proof: "placeholder_proof".to_string(), // Would contain actual proof\n            timestamp: Utc::now(),\n            validity_period: Some(chrono::Duration::days(30)), // Attestations expire\n        };\n\n        self.measurement_attestations.push(attestation);\n        Ok(())\n    }\n\n    fn validate_revocation_proof(&self, proof: &RevocationProof) -> Result<(), RevocationError> {\n        // Verify that the proof is from an authorized entity\n        if proof.verification_method != self.issuer_did && \n           !self.is_authorized_revoker(&proof.verification_method) {\n            return Err(RevocationError::UnauthorizedRevocation);\n        }\n\n        // Verify signature (placeholder implementation)\n        if proof.signature.is_empty() {\n            return Err(RevocationError::InvalidProof("Empty signature".to_string()));\n        }\n\n        // Verify timestamp is reasonable\n        if proof.created > Utc::now() + chrono::Duration::minutes(5) {\n            return Err(RevocationError::InvalidProof("Future timestamp".to_string()));\n        }\n\n        Ok(())\n    }\n\n    fn find_revocation_list_for_credential(&self, credential_id: &str) -> Result<String, RevocationError> {\n        // In a real implementation, this would map credentials to lists\n        // For now, use the first available list\n        self.revocation_lists\n            .keys()\n            .next()\n            .cloned()\n            .ok_or(RevocationError::NoRevocationListAvailable)\n    }\n\n    fn is_authorized_revoker(&self, verifier_did: &str) -> bool {\n        // Check if the verifier is authorized to revoke credentials\n        // This could check against a list of authorized entities\n        verifier_did.starts_with("did:") && verifier_did.contains("authorized")\n    }\n\n    fn calculate_next_update(&self) -> Option<DateTime<Utc>> {\n        match self.privacy_settings.update_frequency {\n            RevocationUpdateFrequency::Realtime => None,\n            RevocationUpdateFrequency::Hourly => Some(Utc::now() + chrono::Duration::hours(1)),\n            RevocationUpdateFrequency::Daily => Some(Utc::now() + chrono::Duration::days(1)),\n            RevocationUpdateFrequency::Weekly => Some(Utc::now() + chrono::Duration::weeks(1)),\n            RevocationUpdateFrequency::Monthly => Some(Utc::now() + chrono::Duration::days(30)),\n            RevocationUpdateFrequency::OnDemand => None,\n        }\n    }\n\n    fn create_initial_bitstring(&self, size: u64) -> Result<String, RevocationError> {\n        // Create a bitstring of specified size with all bits set to 0 (not revoked)\n        let byte_count = (size + 7) / 8; // Round up to nearest byte\n        let bitstring = vec![0u8; byte_count as usize];\n        \n        // Compress and encode\n        let compressed = self.compress_bitstring(&bitstring)?;\n        Ok(base64::encode(&compressed))\n    }\n\n    fn create_initial_merkle_root(&self, size: u64) -> Result<String, RevocationError> {\n        // Create initial Merkle tree with all leaves set to "not revoked"\n        let leaves: Vec<[u8; 32]> = (0..size).map(|_| [0u8; 32]).collect();\n        let root = self.calculate_merkle_root(&leaves)?;\n        Ok(hex::encode(root))\n    }\n\n    fn create_initial_accumulator(&self) -> Result<String, RevocationError> {\n        // Initialize cryptographic accumulator\n        // Placeholder implementation\n        Ok("accumulator_initial_value".to_string())\n    }\n\n    fn update_bitstring(&self, list: &mut RevocationList, index: u64, revoked: bool) -> Result<(), RevocationError> {\n        if let Some(bitstring_b64) = &list.bitstring {\n            let compressed = base64::decode(bitstring_b64)\n                .map_err(|e| RevocationError::InvalidBitstring(e.to_string()))?;\n            \n            let mut bitstring = self.decompress_bitstring(&compressed)?;\n            \n            let byte_index = index / 8;\n            let bit_index = index % 8;\n            \n            if byte_index >= bitstring.len() as u64 {\n                return Err(RevocationError::IndexOutOfBounds);\n            }\n\n            if revoked {\n                bitstring[byte_index as usize] |= 1 << bit_index;\n            } else {\n                bitstring[byte_index as usize] &= !(1 << bit_index);\n            }\n\n            let compressed_updated = self.compress_bitstring(&bitstring)?;\n            list.bitstring = Some(base64::encode(&compressed_updated));\n        }\n\n        Ok(())\n    }\n\n    fn update_suspension_bitstring(&self, list: &mut RevocationList, index: u64, suspended: bool) -> Result<(), RevocationError> {\n        // Similar to update_bitstring but for suspension bits\n        // Could use separate bitstring or interleaved bits\n        self.update_bitstring(list, index, suspended)\n    }\n\n    fn update_merkle_tree(&self, list: &mut RevocationList, index: u64, revoked: bool) -> Result<(), RevocationError> {\n        // Update Merkle tree leaf and recalculate root\n        // Placeholder implementation\n        if revoked {\n            list.merkle_root = Some(format!("updated_merkle_root_for_index_{}", index));\n        }\n        Ok(())\n    }\n\n    fn update_accumulator(&self, list: &mut RevocationList, index: u64, revoked: bool) -> Result<(), RevocationError> {\n        // Update cryptographic accumulator\n        // Placeholder implementation\n        if revoked {\n            list.accumulator_value = Some(format!("updated_accumulator_for_index_{}", index));\n        }\n        Ok(())\n    }\n\n    fn compress_bitstring(&self, bitstring: &[u8]) -> Result<Vec<u8>, RevocationError> {\n        // Compress bitstring using efficient compression\n        // Placeholder: use simple RLE or actual compression library\n        Ok(bitstring.to_vec()) // No compression for simplicity\n    }\n\n    fn decompress_bitstring(&self, compressed: &[u8]) -> Result<Vec<u8>, RevocationError> {\n        // Decompress bitstring\n        Ok(compressed.to_vec()) // No compression for simplicity\n    }\n\n    fn calculate_merkle_root(&self, leaves: &[[u8; 32]]) -> Result<[u8; 32], RevocationError> {\n        // Calculate Merkle tree root\n        // Placeholder implementation\n        Ok([0u8; 32])\n    }\n\n    fn validate_attestation_measurement(&self, measurement: &Measurement) -> Result<(), RevocationError> {\n        match &measurement.value {\n            Value::None => Err(RevocationError::InvalidMeasurement("Empty measurement".to_string())),\n            _ => {\n                // Validate measurement has proper provenance\n                match measurement.provenance.source {\n                    olocus_core::measure::Source::Unknown => {\n                        Err(RevocationError::InvalidMeasurement("Unknown measurement source".to_string()))\n                    },\n                    _ => Ok(()),\n                }\n            }\n        }\n    }\n\n    fn determine_attestation_type(&self, measurement: &Measurement) -> Result<AttestationType, RevocationError> {\n        match &measurement.value {\n            Value::Point2D(_, _) | Value::Point3D(_, _, _) => Ok(AttestationType::LocationVerification),\n            Value::Timestamp(_) => Ok(AttestationType::TemporalVerification),\n            Value::Array(_) => {\n                // Could be biometric data\n                Ok(AttestationType::BiometricVerification)\n            },\n            _ => Ok(AttestationType::MeasurementAccuracy),\n        }\n    }\n\n    fn is_suspension_active(&self, credential_id: &str, revocation_index: u64) -> Result<bool, RevocationError> {\n        // Check if suspension is still active\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               event.revocation_index == revocation_index &&\n               matches!(event.event_type, RevocationEventType::Suspend) {\n                \n                if let Some(effective_date) = event.effective_date {\n                    return Ok(Utc::now() < effective_date);\n                } else {\n                    return Ok(true); // No expiration specified\n                }\n            }\n        }\n        Ok(false)\n    }\n\n    fn get_revocation_timestamp(&self, credential_id: &str) -> Result<DateTime<Utc>, RevocationError> {\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               matches!(event.event_type, RevocationEventType::Revoke) {\n                return Ok(event.timestamp);\n            }\n        }\n        Err(RevocationError::RevocationEventNotFound)\n    }\n\n    fn get_revocation_reason(&self, credential_id: &str) -> Result<RevocationReason, RevocationError> {\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               matches!(event.event_type, RevocationEventType::Revoke) {\n                return Ok(event.reason.clone());\n            }\n        }\n        Err(RevocationError::RevocationEventNotFound)\n    }\n\n    fn get_suspension_timestamp(&self, credential_id: &str) -> Result<DateTime<Utc>, RevocationError> {\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               matches!(event.event_type, RevocationEventType::Suspend) {\n                return Ok(event.timestamp);\n            }\n        }\n        Err(RevocationError::SuspensionEventNotFound)\n    }\n\n    fn get_suspension_expiry(&self, credential_id: &str) -> Result<Option<DateTime<Utc>>, RevocationError> {\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               matches!(event.event_type, RevocationEventType::Suspend) {\n                return Ok(event.effective_date);\n            }\n        }\n        Err(RevocationError::SuspensionEventNotFound)\n    }\n\n    fn get_suspension_reason(&self, credential_id: &str) -> Result<RevocationReason, RevocationError> {\n        for event in &self.revocation_events {\n            if event.credential_id == credential_id && \n               matches!(event.event_type, RevocationEventType::Suspend) {\n                return Ok(event.reason.clone());\n            }\n        }\n        Err(RevocationError::SuspensionEventNotFound)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RevocationStatus {\n    Valid {\n        last_checked: DateTime<Utc>,\n        next_update: Option<DateTime<Utc>>,\n    },\n    Revoked {\n        revoked_at: DateTime<Utc>,\n        reason: RevocationReason,\n    },\n    Suspended {\n        suspended_at: DateTime<Utc>,\n        expires_at: Option<DateTime<Utc>>,\n        reason: RevocationReason,\n    },\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,o.jsx)(n.h3,{id:"zero-knowledge-revocation",children:"Zero-Knowledge Revocation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'pub struct ZeroKnowledgeRevocation {\n    pub circuit_id: String,\n    pub proving_key: String,\n    pub verification_key: String,\n    pub merkle_tree_depth: usize,\n}\n\nimpl ZeroKnowledgeRevocation {\n    pub fn new(circuit_id: String, depth: usize) -> Self {\n        Self {\n            circuit_id,\n            proving_key: "placeholder_proving_key".to_string(),\n            verification_key: "placeholder_verification_key".to_string(),\n            merkle_tree_depth: depth,\n        }\n    }\n\n    pub fn generate_revocation_proof(\n        &self,\n        credential_id: &str,\n        revocation_index: u64,\n        merkle_path: &[String],\n        is_revoked: bool,\n    ) -> Result<ZKRevocationProof, RevocationError> {\n        // Generate zero-knowledge proof that credential is/isn\'t revoked\n        // without revealing the credential ID or revocation status to the verifier\n        \n        let proof = ZKRevocationProof {\n            proof_data: format!("zk_proof_for_{}", credential_id),\n            public_inputs: vec![\n                self.verification_key.clone(),\n                // Merkle root (public)\n                // Nullifier (public, prevents double-spending but doesn\'t reveal credential)\n            ],\n            circuit_id: self.circuit_id.clone(),\n        };\n\n        Ok(proof)\n    }\n\n    pub fn verify_revocation_proof(\n        &self,\n        proof: &ZKRevocationProof,\n        merkle_root: &str,\n        nullifier: &str,\n    ) -> Result<bool, RevocationError> {\n        // Verify zero-knowledge proof\n        // Placeholder implementation\n        Ok(proof.proof_data.contains("zk_proof"))\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ZKRevocationProof {\n    pub proof_data: String,\n    pub public_inputs: Vec<String>,\n    pub circuit_id: String,\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"cryptographic-accumulator",children:"Cryptographic Accumulator"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'pub struct CryptoAccumulator {\n    pub accumulator_value: String,\n    pub public_key: String,\n    pub accumulated_set: HashSet<String>,\n}\n\nimpl CryptoAccumulator {\n    pub fn new() -> Self {\n        Self {\n            accumulator_value: "initial_accumulator".to_string(),\n            public_key: "accumulator_public_key".to_string(),\n            accumulated_set: HashSet::new(),\n        }\n    }\n\n    pub fn add_element(&mut self, element: &str) -> Result<AccumulatorWitness, RevocationError> {\n        // Add element to accumulator and return witness\n        self.accumulated_set.insert(element.to_string());\n        \n        // Update accumulator value\n        self.accumulator_value = format!("{}_{}", self.accumulator_value, element);\n\n        let witness = AccumulatorWitness {\n            element: element.to_string(),\n            witness_value: format!("witness_for_{}", element),\n            accumulator_snapshot: self.accumulator_value.clone(),\n        };\n\n        Ok(witness)\n    }\n\n    pub fn remove_element(&mut self, element: &str) -> Result<(), RevocationError> {\n        // Remove element from accumulator (marks as revoked)\n        self.accumulated_set.remove(element);\n        \n        // Update accumulator value\n        self.accumulator_value = format!("{}_{}_removed", self.accumulator_value, element);\n\n        Ok(())\n    }\n\n    pub fn prove_membership(\n        &self,\n        element: &str,\n        witness: &AccumulatorWitness,\n    ) -> Result<bool, RevocationError> {\n        // Prove that element is in accumulator (not revoked)\n        Ok(self.accumulated_set.contains(element) && \n           witness.element == element)\n    }\n\n    pub fn prove_non_membership(\n        &self,\n        element: &str,\n    ) -> Result<NonMembershipProof, RevocationError> {\n        // Prove that element is not in accumulator (is revoked)\n        let proof = NonMembershipProof {\n            element: element.to_string(),\n            proof_value: format!("non_membership_proof_for_{}", element),\n            accumulator_value: self.accumulator_value.clone(),\n        };\n\n        Ok(proof)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccumulatorWitness {\n    pub element: String,\n    pub witness_value: String,\n    pub accumulator_snapshot: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NonMembershipProof {\n    pub element: String,\n    pub proof_value: String,\n    pub accumulator_value: String,\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-olocus-core",children:"Integration with Olocus Core"}),"\n",(0,o.jsx)(n.h3,{id:"block-payload-implementation",children:"Block Payload Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, BlockPayload};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationPayload {\n    pub registry_updates: Vec<RevocationRegistryUpdate>,\n    pub revocation_events: Vec<RevocationEvent>,\n    pub measurement_attestations: Vec<RevocationMeasurementAttestation>,\n    pub zk_proofs: Vec<ZKRevocationProof>,\n    pub accumulator_updates: Vec<AccumulatorUpdate>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RevocationRegistryUpdate {\n    pub registry_id: String,\n    pub list_id: String,\n    pub update_type: RegistryUpdateType,\n    pub merkle_root: Option<String>,\n    pub accumulator_value: Option<String>,\n    pub bitstring_delta: Option<String>,\n    pub timestamp: DateTime<Utc>,\n    pub proof: RevocationProof,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RegistryUpdateType {\n    NewList,\n    UpdateList,\n    RevokeBatch,\n    SuspendBatch,\n    ReinstateBatch,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccumulatorUpdate {\n    pub accumulator_id: String,\n    pub previous_value: String,\n    pub new_value: String,\n    pub added_elements: Vec<String>,\n    pub removed_elements: Vec<String>,\n    pub proof: String,\n}\n\nimpl BlockPayload for RevocationPayload {\n    fn payload_type(&self) -> u16 {\n        0x0602 // Credentials extension, revocation subtype\n    }\n\n    fn validate(&self) -> Result<(), Box<dyn std::error::Error>> {\n        // Validate registry updates\n        for update in &self.registry_updates {\n            if update.registry_id.is_empty() {\n                return Err("Registry update must have registry ID".into());\n            }\n            \n            if update.timestamp > Utc::now() + chrono::Duration::minutes(5) {\n                return Err("Registry update timestamp cannot be in the future".into());\n            }\n        }\n\n        // Validate revocation events\n        for event in &self.revocation_events {\n            if event.credential_id.is_empty() {\n                return Err("Revocation event must have credential ID".into());\n            }\n            \n            // Validate measurement evidence if present\n            if let Some(measurement) = &event.measurement_evidence {\n                if let Value::None = measurement.value {\n                    return Err("Measurement evidence cannot be empty".into());\n                }\n            }\n        }\n\n        // Validate measurement attestations\n        for attestation in &self.measurement_attestations {\n            if attestation.verifier_did.is_empty() {\n                return Err("Measurement attestation must have verifier DID".into());\n            }\n            \n            if let Value::None = attestation.measurement.value {\n                return Err("Attestation measurement cannot be empty".into());\n            }\n        }\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_credentials::{RevocationRegistry, RevocationMethod, RevocationListType, RevocationPurpose};\nuse olocus_core::measure::{Measurement, Value, Uncertainty};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Create revocation registry\n    let privacy_settings = RevocationPrivacySettings {\n        hide_revocation_reason: false,\n        hide_revocation_timing: false,\n        use_anonymous_revocation: false,\n        batch_updates: true,\n        update_frequency: RevocationUpdateFrequency::Daily,\n    };\n    \n    let mut registry = RevocationRegistry::new(\n        "did:olocus:issuer123".to_string(),\n        RevocationMethod::BitstringStatusList,\n        privacy_settings,\n    );\n    \n    // Create revocation list\n    let list_id = registry.create_revocation_list(\n        RevocationListType::BitstringCompressed,\n        RevocationPurpose::Both,\n        10000, // Support 10,000 credentials\n    )?;\n    \n    println!("Created revocation list: {}", list_id);\n    \n    // Create measurement evidence for revocation\n    let location_measurement = Measurement {\n        value: Value::Point2D(377749000, -1224194000), // San Francisco\n        uncertainty: Uncertainty::Circular { radius: 50.0 }, // 50m uncertainty\n        provenance: Default::default(),\n        validity: None,\n    };\n    \n    let revocation_proof = RevocationProof {\n        proof_type: "Ed25519Signature2020".to_string(),\n        verification_method: "did:olocus:issuer123#keys-1".to_string(),\n        signature: "placeholder_signature".to_string(),\n        created: Utc::now(),\n        nonce: Some("revocation_nonce_123".to_string()),\n        challenge: None,\n    };\n    \n    // Revoke a credential due to location verification failure\n    registry.revoke_credential(\n        "credential_001".to_string(),\n        42, // Revocation index\n        RevocationReason::LocationVerificationFailure,\n        revocation_proof,\n        Some(location_measurement),\n    )?;\n    \n    println!("Revoked credential_001 due to location verification failure");\n    \n    // Check revocation status\n    let status = registry.check_revocation_status("credential_001", 42).await?;\n    match status {\n        RevocationStatus::Revoked { revoked_at, reason } => {\n            println!("Credential revoked at {} for reason: {:?}", revoked_at, reason);\n        },\n        RevocationStatus::Valid { .. } => {\n            println!("Credential is valid");\n        },\n        RevocationStatus::Suspended { .. } => {\n            println!("Credential is suspended");\n        },\n    }\n    \n    // Suspend a credential temporarily\n    let suspension_proof = RevocationProof {\n        proof_type: "Ed25519Signature2020".to_string(),\n        verification_method: "did:olocus:issuer123#keys-1".to_string(),\n        signature: "suspension_signature".to_string(),\n        created: Utc::now(),\n        nonce: Some("suspension_nonce_456".to_string()),\n        challenge: None,\n    };\n    \n    registry.suspend_credential(\n        "credential_002".to_string(),\n        43,\n        RevocationReason::CertificateHold,\n        suspension_proof,\n        Some(chrono::Duration::days(30)), // 30-day suspension\n    )?;\n    \n    println!("Suspended credential_002 for 30 days");\n    \n    // Create revocation payload for blockchain\n    let payload = RevocationPayload {\n        registry_updates: vec![],\n        revocation_events: registry.revocation_events.clone(),\n        measurement_attestations: registry.measurement_attestations.clone(),\n        zk_proofs: vec![],\n        accumulator_updates: vec![],\n    };\n    \n    // Create block\n    let block = Block::new(payload)?;\n    println!("Created revocation block: {}", hex::encode(block.hash()));\n    \n    Ok(())\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,o.jsx)(n.h3,{id:"cryptographic-security",children:"Cryptographic Security"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Proof Integrity"}),": All revocation operations require cryptographic proof"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tamper Resistance"}),": Revocation lists protected by merkle trees or accumulators"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Non-Repudiation"}),": Revocation events are cryptographically signed and timestamped"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Key Management"}),": Proper authorization for revocation operations"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"privacy-protection",children:"Privacy Protection"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Anonymous Revocation"}),": Zero-knowledge proofs hide credential identity"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unlinkable Checks"}),": Multiple revocation checks cannot be correlated"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Timing Privacy"}),": Batch updates and configurable update frequencies"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Measurement Privacy"}),": Attestation evidence respects uncertainty and provenance"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Revocation Check"}),": <10ms for bitstring-based lists"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Revocation Update"}),": <50ms for simple lists, <200ms for accumulators"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"List Update"}),": <500ms for 10,000 entry list"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ZK Proof Generation"}),": <2s for membership proofs"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Measurement Attestation"}),": <30ms per attestation"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"registry-design",children:"Registry Design"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Choose appropriate list types"})," based on scale and privacy requirements"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configure update frequencies"})," to balance privacy and efficiency"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use measurement attestations"})," for additional verification"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement proper authorization"})," for revocation operations"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"privacy-guidelines",children:"Privacy Guidelines"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use anonymous revocation"})," for sensitive credentials"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Batch updates"})," to improve privacy and efficiency"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement proper key rotation"})," for revocation authorities"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Monitor for timing attacks"})," on revocation checks"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum RevocationError {\n    #[error("List not found: {0}")]\n    ListNotFound(String),\n    \n    #[error("Unauthorized revocation attempt")]\n    UnauthorizedRevocation,\n    \n    #[error("Invalid proof: {0}")]\n    InvalidProof(String),\n    \n    #[error("Invalid bitstring: {0}")]\n    InvalidBitstring(String),\n    \n    #[error("Index out of bounds")]\n    IndexOutOfBounds,\n    \n    #[error("Suspension not supported")]\n    SuspensionNotSupported,\n    \n    #[error("Unsupported list type")]\n    UnsupportedListType,\n    \n    #[error("No revocation list available")]\n    NoRevocationListAvailable,\n    \n    #[error("Invalid measurement: {0}")]\n    InvalidMeasurement(String),\n    \n    #[error("Revocation event not found")]\n    RevocationEventNotFound,\n    \n    #[error("Suspension event not found")]\n    SuspensionEventNotFound,\n    \n    #[error("Accumulator error: {0}")]\n    AccumulatorError(String),\n    \n    #[error("Zero-knowledge proof error: {0}")]\n    ZKProofError(String),\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This comprehensive revocation implementation provides robust, privacy-preserving credential revocation capabilities within the Olocus Credentials extension, supporting multiple revocation methods and measurement-based attestations while maintaining strong security guarantees."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);