"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5664],{184:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"extensions/infrastructure/consensus","title":"Consensus Algorithms","description":"The Consensus module provides multiple consensus algorithm implementations for distributed Olocus Protocol networks. Each algorithm is optimized for different network conditions, security requirements, and performance characteristics.","source":"@site/docs/extensions/infrastructure/consensus.md","sourceDirName":"extensions/infrastructure","slug":"/extensions/infrastructure/consensus","permalink":"/docs/extensions/infrastructure/consensus","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/infrastructure/consensus.md","tags":[],"version":"current","lastUpdatedAt":1764951516000,"sidebarPosition":4,"frontMatter":{"id":"consensus","title":"Consensus Algorithms","sidebar_position":4}}');var o=t(4848),a=t(8453);const i={id:"consensus",title:"Consensus Algorithms",sidebar_position:4},l="Consensus Algorithms",r={},c=[{value:"Overview",id:"overview",level:2},{value:"Consensus Trait Interface",id:"consensus-trait-interface",level:2},{value:"Core Consensus Trait",id:"core-consensus-trait",level:3},{value:"Proof of Work (PoW)",id:"proof-of-work-pow",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Proof of Stake (PoS)",id:"proof-of-stake-pos",level:2},{value:"Implementation",id:"implementation-1",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"PBFT (Practical Byzantine Fault Tolerance)",id:"pbft-practical-byzantine-fault-tolerance",level:2},{value:"Implementation",id:"implementation-2",level:3},{value:"Common Types and Traits",id:"common-types-and-traits",level:2},{value:"Performance Comparison",id:"performance-comparison",level:2},{value:"Usage Guidelines",id:"usage-guidelines",level:2},{value:"When to Use Each Algorithm",id:"when-to-use-each-algorithm",level:3},{value:"Configuration Recommendations",id:"configuration-recommendations",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"consensus-algorithms",children:"Consensus Algorithms"})}),"\n",(0,o.jsx)(n.p,{children:"The Consensus module provides multiple consensus algorithm implementations for distributed Olocus Protocol networks. Each algorithm is optimized for different network conditions, security requirements, and performance characteristics."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Consensus algorithms enable distributed agreement on block ordering and chain state:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Proof of Work (PoW)"}),": Energy-based consensus with cryptographic puzzles"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Proof of Stake (PoS)"}),": Stake-based consensus with validator selection"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"PBFT"}),": Practical Byzantine Fault Tolerance for permissioned networks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Raft"}),": Leader-based consensus for crash fault tolerance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tendermint"}),": BFT consensus with instant finality"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::consensus::*;\n\n// Configure consensus algorithm\nlet consensus_config = ConsensusConfig {\n    algorithm: ConsensusAlgorithm::PBFT {\n        validator_set: ValidatorSet::new(validators),\n        view_timeout: Duration::from_secs(30),\n        prepare_timeout: Duration::from_secs(10),\n        commit_timeout: Duration::from_secs(10),\n        max_faulty_nodes: 1, // f = 1, total nodes = 3f + 1 = 4\n    },\n    block_time: Duration::from_secs(5),\n    max_block_size: 1024 * 1024, // 1MB\n    finality_threshold: 6, // Number of confirmations for finality\n};\n\nlet consensus_engine = ConsensusEngine::new(consensus_config).await?;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"consensus-trait-interface",children:"Consensus Trait Interface"}),"\n",(0,o.jsx)(n.h3,{id:"core-consensus-trait",children:"Core Consensus Trait"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::consensus::traits::*;\nuse olocus_core::*;\n\n#[async_trait::async_trait]\npub trait ConsensusAlgorithm: Send + Sync {\n    async fn propose_block(&mut self, block: Block<impl BlockPayload>) -> Result<ProposalId>;\n    async fn validate_block(&self, block: &Block<impl BlockPayload>) -> Result<bool>;\n    async fn process_vote(&mut self, vote: Vote) -> Result<VoteResult>;\n    async fn finalize_block(&mut self, block_hash: BlockHash) -> Result<()>;\n    \n    async fn get_current_leader(&self) -> Result<Option<NodeId>>;\n    async fn get_consensus_state(&self) -> Result<ConsensusState>;\n    async fn handle_timeout(&mut self, timeout_type: TimeoutType) -> Result<()>;\n    \n    fn algorithm_type(&self) -> ConsensusType;\n    fn supports_instant_finality(&self) -> bool;\n    fn max_fault_tolerance(&self) -> f64; // Fraction of faulty nodes tolerated\n}\n\n#[async_trait::async_trait]\npub trait ValidatorSet: Send + Sync {\n    async fn get_validators(&self) -> Result<Vec<Validator>>;\n    async fn is_validator(&self, node_id: &NodeId) -> Result<bool>;\n    async fn get_validator_weight(&self, node_id: &NodeId) -> Result<u64>;\n    async fn get_total_stake(&self) -> Result<u64>;\n    async fn select_leader(&self, round: u64) -> Result<NodeId>;\n}\n\n#[derive(Debug, Clone)]\npub struct Vote {\n    pub voter_id: NodeId,\n    pub block_hash: BlockHash,\n    pub vote_type: VoteType,\n    pub round: u64,\n    pub view: u64,\n    pub signature: Signature,\n    pub timestamp: SystemTime,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum VoteType {\n    Prepare,\n    Commit,\n    Precommit,\n    Prevote,\n}\n\n#[derive(Debug, Clone)]\npub enum VoteResult {\n    Accepted,\n    Rejected(String),\n    Threshold(ThresholdReached),\n}\n\n#[derive(Debug, Clone)]\npub struct ThresholdReached {\n    pub vote_type: VoteType,\n    pub block_hash: BlockHash,\n    pub vote_count: usize,\n    pub total_weight: u64,\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"proof-of-work-pow",children:"Proof of Work (PoW)"}),"\n",(0,o.jsx)(n.p,{children:"Bitcoin-style proof of work with adjustable difficulty:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::consensus::pow::*;\nuse sha2::{Sha256, Digest};\n\n#[derive(Debug)]\npub struct ProofOfWork {\n    config: PoWConfig,\n    current_difficulty: u64,\n    mining_stats: MiningStats,\n}\n\n#[derive(Debug, Clone)]\npub struct PoWConfig {\n    pub initial_difficulty: u64,\n    pub target_block_time: Duration,\n    pub difficulty_adjustment_interval: u64, // Number of blocks\n    pub max_difficulty_change: f64, // Maximum change per adjustment (e.g., 4.0 = 400%)\n    pub min_difficulty: u64,\n    pub max_difficulty: u64,\n}\n\nimpl Default for PoWConfig {\n    fn default() -> Self {\n        Self {\n            initial_difficulty: 0x1d00ffff, // Bitcoin-style difficulty\n            target_block_time: Duration::from_secs(600), // 10 minutes\n            difficulty_adjustment_interval: 144, // ~1 day at 10 min blocks\n            max_difficulty_change: 4.0,\n            min_difficulty: 1,\n            max_difficulty: u64::MAX,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MiningStats {\n    pub blocks_mined: u64,\n    pub total_hash_rate: f64,\n    pub average_block_time: Duration,\n    pub last_difficulty_adjustment: SystemTime,\n}\n\n#[async_trait::async_trait]\nimpl ConsensusAlgorithm for ProofOfWork {\n    async fn propose_block(&mut self, mut block: Block<impl BlockPayload>) -> Result<ProposalId> {\n        // Mine the block by finding valid nonce\n        let start_time = SystemTime::now();\n        let (nonce, hash) = self.mine_block(&block).await?;\n        \n        // Update block with mining results\n        block.nonce = nonce;\n        block.hash = Some(hash);\n        \n        // Update mining statistics\n        let mining_duration = start_time.elapsed().unwrap_or_default();\n        self.update_mining_stats(mining_duration);\n        \n        // Adjust difficulty if needed\n        if self.should_adjust_difficulty() {\n            self.adjust_difficulty().await?;\n        }\n        \n        Ok(ProposalId::from_hash(hash))\n    }\n\n    async fn validate_block(&self, block: &Block<impl BlockPayload>) -> Result<bool> {\n        // Verify proof of work\n        let block_hash = self.calculate_block_hash(block)?;\n        let meets_difficulty = self.meets_difficulty_target(&block_hash, self.current_difficulty);\n        \n        if !meets_difficulty {\n            return Ok(false);\n        }\n        \n        // Verify block structure\n        if block.nonce == 0 && block.previous_hash.is_some() {\n            return Ok(false); // Genesis block exception\n        }\n        \n        // Verify hash chain\n        if let Some(prev_hash) = &block.previous_hash {\n            // Would verify against stored previous block\n        }\n        \n        Ok(true)\n    }\n\n    async fn process_vote(&mut self, _vote: Vote) -> Result<VoteResult> {\n        // PoW doesn't use explicit voting - acceptance is implicit through mining\n        Ok(VoteResult::Accepted)\n    }\n\n    async fn finalize_block(&mut self, block_hash: BlockHash) -> Result<()> {\n        // In PoW, finality is probabilistic based on chain depth\n        // This would update the canonical chain\n        self.mining_stats.blocks_mined += 1;\n        Ok(())\n    }\n\n    async fn get_current_leader(&self) -> Result<Option<NodeId>> {\n        // PoW has no fixed leader - anyone can mine\n        Ok(None)\n    }\n\n    async fn get_consensus_state(&self) -> Result<ConsensusState> {\n        Ok(ConsensusState {\n            algorithm_type: ConsensusType::ProofOfWork,\n            current_round: self.mining_stats.blocks_mined,\n            current_leader: None,\n            difficulty: Some(self.current_difficulty),\n            finalized_block_height: self.mining_stats.blocks_mined.saturating_sub(6), // 6-block finality\n        })\n    }\n\n    async fn handle_timeout(&mut self, _timeout_type: TimeoutType) -> Result<()> {\n        // PoW mining continues regardless of timeouts\n        Ok(())\n    }\n\n    fn algorithm_type(&self) -> ConsensusType {\n        ConsensusType::ProofOfWork\n    }\n\n    fn supports_instant_finality(&self) -> bool {\n        false // Probabilistic finality only\n    }\n\n    fn max_fault_tolerance(&self) -> f64 {\n        0.5 // 51% attack threshold\n    }\n}\n\nimpl ProofOfWork {\n    async fn mine_block(&self, block: &Block<impl BlockPayload>) -> Result<(u64, BlockHash)> {\n        let mut nonce = 0u64;\n        let target = self.difficulty_to_target(self.current_difficulty);\n        \n        loop {\n            let hash = self.calculate_hash_with_nonce(block, nonce)?;\n            \n            if self.hash_meets_target(&hash, &target) {\n                return Ok((nonce, hash));\n            }\n            \n            nonce += 1;\n            \n            // Yield occasionally to prevent blocking\n            if nonce % 100000 == 0 {\n                tokio::task::yield_now().await;\n            }\n            \n            // Check for cancellation\n            if nonce % 1000000 == 0 {\n                // Could check for stop signal here\n            }\n        }\n    }\n    \n    fn calculate_hash_with_nonce(&self, block: &Block<impl BlockPayload>, nonce: u64) -> Result<BlockHash> {\n        let mut hasher = Sha256::new();\n        \n        // Hash block content + nonce\n        hasher.update(&block.to_bytes()?);\n        hasher.update(&nonce.to_le_bytes());\n        \n        let hash_bytes = hasher.finalize();\n        Ok(BlockHash::from_bytes(hash_bytes.as_slice())?)\n    }\n    \n    fn difficulty_to_target(&self, difficulty: u64) -> [u8; 32] {\n        // Convert difficulty to target (simplified)\n        let mut target = [0xffu8; 32];\n        let leading_zeros = (difficulty.leading_zeros() / 8) as usize;\n        \n        for i in 0..leading_zeros.min(32) {\n            target[i] = 0;\n        }\n        \n        target\n    }\n    \n    fn hash_meets_target(&self, hash: &BlockHash, target: &[u8; 32]) -> bool {\n        hash.as_bytes() <= target\n    }\n    \n    fn meets_difficulty_target(&self, hash: &BlockHash, difficulty: u64) -> bool {\n        let target = self.difficulty_to_target(difficulty);\n        self.hash_meets_target(hash, &target)\n    }\n    \n    fn calculate_block_hash(&self, block: &Block<impl BlockPayload>) -> Result<BlockHash> {\n        self.calculate_hash_with_nonce(block, block.nonce)\n    }\n    \n    fn should_adjust_difficulty(&self) -> bool {\n        self.mining_stats.blocks_mined % self.config.difficulty_adjustment_interval == 0\n    }\n    \n    async fn adjust_difficulty(&mut self) -> Result<()> {\n        let actual_time = self.mining_stats.average_block_time;\n        let target_time = self.config.target_block_time;\n        \n        let adjustment_ratio = target_time.as_secs_f64() / actual_time.as_secs_f64();\n        let clamped_ratio = adjustment_ratio.clamp(\n            1.0 / self.config.max_difficulty_change, \n            self.config.max_difficulty_change\n        );\n        \n        let new_difficulty = ((self.current_difficulty as f64) * clamped_ratio) as u64;\n        self.current_difficulty = new_difficulty.clamp(\n            self.config.min_difficulty, \n            self.config.max_difficulty\n        );\n        \n        Ok(())\n    }\n    \n    fn update_mining_stats(&mut self, mining_duration: Duration) {\n        // Update rolling average block time\n        let alpha = 0.1; // Exponential moving average factor\n        let new_block_time_secs = mining_duration.as_secs_f64();\n        let current_avg_secs = self.mining_stats.average_block_time.as_secs_f64();\n        \n        let updated_avg_secs = alpha * new_block_time_secs + (1.0 - alpha) * current_avg_secs;\n        self.mining_stats.average_block_time = Duration::from_secs_f64(updated_avg_secs);\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::consensus::pow::*;\n\nlet config = PoWConfig {\n    initial_difficulty: 0x1e00ffff, // Lower difficulty for faster testing\n    target_block_time: Duration::from_secs(60), // 1 minute blocks\n    difficulty_adjustment_interval: 10, // Adjust every 10 blocks\n    max_difficulty_change: 2.0, // Max 200% change\n    ..Default::default()\n};\n\nlet mut pow = ProofOfWork::new(config);\n\n// Mine a block\nlet proposal_id = pow.propose_block(my_block).await?;\nprintln!("Mined block with proposal ID: {:?}", proposal_id);\n\n// Validate a received block\nlet is_valid = pow.validate_block(&received_block).await?;\nif is_valid {\n    pow.finalize_block(received_block.hash()?).await?;\n}\n\n// Check consensus state\nlet state = pow.get_consensus_state().await?;\nprintln!("Current difficulty: {:?}", state.difficulty);\n'})}),"\n",(0,o.jsx)(n.h2,{id:"proof-of-stake-pos",children:"Proof of Stake (PoS)"}),"\n",(0,o.jsx)(n.p,{children:"Ethereum-style proof of stake with validator selection:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::consensus::pos::*;\n\n#[derive(Debug)]\npub struct ProofOfStake {\n    config: PoSConfig,\n    validator_set: Box<dyn ValidatorSet>,\n    current_epoch: u64,\n    slot_time: Duration,\n}\n\n#[derive(Debug, Clone)]\npub struct PoSConfig {\n    pub slots_per_epoch: u64,\n    pub slot_duration: Duration,\n    pub min_stake: u64,\n    pub slashing_multiplier: f64,\n    pub reward_per_block: u64,\n}\n\nimpl Default for PoSConfig {\n    fn default() -> Self {\n        Self {\n            slots_per_epoch: 32,\n            slot_duration: Duration::from_secs(12),\n            min_stake: 32_000_000_000, // 32 ETH equivalent in wei\n            slashing_multiplier: 1.0,\n            reward_per_block: 1_000_000_000, // 1 unit\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct Validator {\n    pub node_id: NodeId,\n    pub public_key: PublicKey,\n    pub stake: u64,\n    pub status: ValidatorStatus,\n    pub last_attestation_slot: Option<u64>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ValidatorStatus {\n    Active,\n    PendingActivation,\n    PendingExit,\n    Exited,\n    Slashed,\n}\n\n#[async_trait::async_trait]\nimpl ConsensusAlgorithm for ProofOfStake {\n    async fn propose_block(&mut self, block: Block<impl BlockPayload>) -> Result<ProposalId> {\n        let current_slot = self.get_current_slot();\n        let proposer = self.validator_set.select_leader(current_slot).await?;\n        \n        // Verify we are the selected proposer\n        let our_node_id = self.get_our_node_id();\n        if proposer != our_node_id {\n            return Err(ConsensusError::NotSelectedProposer.into());\n        }\n        \n        // Sign the block\n        let signed_block = self.sign_block(block).await?;\n        \n        Ok(ProposalId::from_hash(signed_block.hash()?))\n    }\n\n    async fn validate_block(&self, block: &Block<impl BlockPayload>) -> Result<bool> {\n        // Verify proposer selection\n        let slot = self.block_slot(block);\n        let expected_proposer = self.validator_set.select_leader(slot).await?;\n        \n        if block.proposer != Some(expected_proposer) {\n            return Ok(false);\n        }\n        \n        // Verify proposer signature\n        if !self.verify_block_signature(block).await? {\n            return Ok(false);\n        }\n        \n        // Verify stake requirements\n        let proposer_stake = self.validator_set.get_validator_weight(&expected_proposer).await?;\n        if proposer_stake < self.config.min_stake {\n            return Ok(false);\n        }\n        \n        Ok(true)\n    }\n\n    async fn process_vote(&mut self, vote: Vote) -> Result<VoteResult> {\n        // Verify vote signature\n        if !self.verify_vote_signature(&vote).await? {\n            return Ok(VoteResult::Rejected("Invalid signature".to_string()));\n        }\n        \n        // Verify voter is active validator\n        if !self.validator_set.is_validator(&vote.voter_id).await? {\n            return Ok(VoteResult::Rejected("Not an active validator".to_string()));\n        }\n        \n        // Calculate vote weight based on stake\n        let vote_weight = self.validator_set.get_validator_weight(&vote.voter_id).await?;\n        \n        // Check if we\'ve reached threshold (2/3 of total stake)\n        let total_stake = self.validator_set.get_total_stake().await?;\n        let threshold = (total_stake * 2) / 3;\n        \n        // This would update vote tracking and check threshold\n        if self.get_total_vote_weight_for_block(&vote.block_hash, vote.vote_type).await? >= threshold {\n            return Ok(VoteResult::Threshold(ThresholdReached {\n                vote_type: vote.vote_type,\n                block_hash: vote.block_hash,\n                vote_count: 1, // Would track actual count\n                total_weight: vote_weight,\n            }));\n        }\n        \n        Ok(VoteResult::Accepted)\n    }\n\n    async fn finalize_block(&mut self, block_hash: BlockHash) -> Result<()> {\n        // Update validator rewards\n        self.distribute_rewards(block_hash).await?;\n        \n        // Update epoch if needed\n        self.check_epoch_transition().await?;\n        \n        Ok(())\n    }\n\n    async fn get_current_leader(&self) -> Result<Option<NodeId>> {\n        let current_slot = self.get_current_slot();\n        let leader = self.validator_set.select_leader(current_slot).await?;\n        Ok(Some(leader))\n    }\n\n    async fn get_consensus_state(&self) -> Result<ConsensusState> {\n        Ok(ConsensusState {\n            algorithm_type: ConsensusType::ProofOfStake,\n            current_round: self.get_current_slot(),\n            current_leader: self.get_current_leader().await?,\n            difficulty: None,\n            finalized_block_height: self.get_finalized_height().await?,\n        })\n    }\n\n    async fn handle_timeout(&mut self, timeout_type: TimeoutType) -> Result<()> {\n        match timeout_type {\n            TimeoutType::SlotTimeout => {\n                // Move to next slot\n                self.advance_slot().await?;\n            }\n            TimeoutType::EpochTimeout => {\n                // Move to next epoch\n                self.advance_epoch().await?;\n            }\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn algorithm_type(&self) -> ConsensusType {\n        ConsensusType::ProofOfStake\n    }\n\n    fn supports_instant_finality(&self) -> bool {\n        true // With sufficient attestations\n    }\n\n    fn max_fault_tolerance(&self) -> f64 {\n        0.33 // 1/3 Byzantine fault tolerance\n    }\n}\n\nimpl ProofOfStake {\n    fn get_current_slot(&self) -> u64 {\n        let genesis_time = SystemTime::UNIX_EPOCH; // Would be actual genesis\n        let elapsed = SystemTime::now().duration_since(genesis_time).unwrap_or_default();\n        elapsed.as_secs() / self.config.slot_duration.as_secs()\n    }\n    \n    fn block_slot(&self, block: &Block<impl BlockPayload>) -> u64 {\n        // Extract slot from block timestamp\n        let genesis_time = SystemTime::UNIX_EPOCH;\n        let block_elapsed = block.timestamp.duration_since(genesis_time).unwrap_or_default();\n        block_elapsed.as_secs() / self.config.slot_duration.as_secs()\n    }\n    \n    async fn sign_block(&self, mut block: Block<impl BlockPayload>) -> Result<Block<impl BlockPayload>> {\n        let our_node_id = self.get_our_node_id();\n        block.proposer = Some(our_node_id);\n        \n        // Sign with our validator key\n        let signature = self.create_block_signature(&block).await?;\n        block.signature = Some(signature);\n        \n        Ok(block)\n    }\n    \n    async fn verify_block_signature(&self, block: &Block<impl BlockPayload>) -> Result<bool> {\n        if let (Some(proposer), Some(signature)) = (&block.proposer, &block.signature) {\n            // Get proposer\'s public key\n            let validators = self.validator_set.get_validators().await?;\n            if let Some(validator) = validators.iter().find(|v| &v.node_id == proposer) {\n                return Ok(self.verify_signature(&validator.public_key, block, signature).await?);\n            }\n        }\n        Ok(false)\n    }\n    \n    async fn verify_vote_signature(&self, vote: &Vote) -> Result<bool> {\n        let validators = self.validator_set.get_validators().await?;\n        if let Some(validator) = validators.iter().find(|v| v.node_id == vote.voter_id) {\n            return Ok(self.verify_vote_sig(&validator.public_key, vote).await?);\n        }\n        Ok(false)\n    }\n    \n    async fn get_total_vote_weight_for_block(&self, _block_hash: &BlockHash, _vote_type: VoteType) -> Result<u64> {\n        // This would track votes and return total weight\n        Ok(0)\n    }\n    \n    async fn distribute_rewards(&mut self, _block_hash: BlockHash) -> Result<()> {\n        // Distribute block rewards to proposer and attesters\n        Ok(())\n    }\n    \n    async fn check_epoch_transition(&mut self) -> Result<()> {\n        let current_slot = self.get_current_slot();\n        let new_epoch = current_slot / self.config.slots_per_epoch;\n        \n        if new_epoch > self.current_epoch {\n            self.current_epoch = new_epoch;\n            // Update validator set, process exits/activations, etc.\n        }\n        \n        Ok(())\n    }\n    \n    async fn advance_slot(&mut self) -> Result<()> {\n        // Implementation for slot progression\n        Ok(())\n    }\n    \n    async fn advance_epoch(&mut self) -> Result<()> {\n        // Implementation for epoch progression\n        Ok(())\n    }\n    \n    async fn get_finalized_height(&self) -> Result<u64> {\n        // Return height of last finalized block\n        Ok(0)\n    }\n    \n    fn get_our_node_id(&self) -> NodeId {\n        // Return this node\'s ID\n        NodeId::default()\n    }\n    \n    async fn create_block_signature(&self, _block: &Block<impl BlockPayload>) -> Result<Signature> {\n        // Create signature using validator private key\n        Ok(Signature::default())\n    }\n    \n    async fn verify_signature(&self, _public_key: &PublicKey, _block: &Block<impl BlockPayload>, _signature: &Signature) -> Result<bool> {\n        // Verify block signature\n        Ok(true)\n    }\n    \n    async fn verify_vote_sig(&self, _public_key: &PublicKey, _vote: &Vote) -> Result<bool> {\n        // Verify vote signature\n        Ok(true)\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::consensus::pos::*;\n\nlet validators = vec![\n    Validator {\n        node_id: validator1_id,\n        public_key: validator1_pubkey,\n        stake: 32_000_000_000,\n        status: ValidatorStatus::Active,\n        last_attestation_slot: None,\n    },\n    // ... more validators\n];\n\nlet validator_set = Box::new(SimpleValidatorSet::new(validators));\nlet config = PoSConfig {\n    slots_per_epoch: 32,\n    slot_duration: Duration::from_secs(12),\n    min_stake: 32_000_000_000,\n    ..Default::default()\n};\n\nlet mut pos = ProofOfStake::new(config, validator_set);\n\n// Propose a block if we\'re the selected proposer\nif let Ok(Some(leader)) = pos.get_current_leader().await {\n    if leader == our_node_id {\n        let proposal_id = pos.propose_block(my_block).await?;\n        println!("Proposed block: {:?}", proposal_id);\n    }\n}\n\n// Process attestation votes\nlet vote = Vote {\n    voter_id: validator_id,\n    block_hash: block_hash,\n    vote_type: VoteType::Prevote,\n    round: current_slot,\n    view: 0,\n    signature: vote_signature,\n    timestamp: SystemTime::now(),\n};\n\nmatch pos.process_vote(vote).await? {\n    VoteResult::Threshold(threshold) => {\n        println!("Reached threshold for block: {:?}", threshold.block_hash);\n        pos.finalize_block(threshold.block_hash).await?;\n    }\n    VoteResult::Accepted => {\n        println!("Vote accepted");\n    }\n    VoteResult::Rejected(reason) => {\n        println!("Vote rejected: {}", reason);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"pbft-practical-byzantine-fault-tolerance",children:"PBFT (Practical Byzantine Fault Tolerance)"}),"\n",(0,o.jsx)(n.p,{children:"Three-phase Byzantine fault tolerant consensus:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::consensus::pbft::*;\n\n#[derive(Debug)]\npub struct PBFT {\n    config: PBFTConfig,\n    current_view: u64,\n    current_sequence: u64,\n    validator_set: Box<dyn ValidatorSet>,\n    message_log: HashMap<(u64, u64), PBFTMessage>, // (view, sequence) -> message\n    vote_tracker: HashMap<(u64, u64, VoteType), Vec<Vote>>, // Track votes\n}\n\n#[derive(Debug, Clone)]\npub struct PBFTConfig {\n    pub view_timeout: Duration,\n    pub prepare_timeout: Duration,\n    pub commit_timeout: Duration,\n    pub max_faulty_nodes: usize,\n    pub checkpoint_interval: u64,\n}\n\nimpl Default for PBFTConfig {\n    fn default() -> Self {\n        Self {\n            view_timeout: Duration::from_secs(30),\n            prepare_timeout: Duration::from_secs(10),\n            commit_timeout: Duration::from_secs(10),\n            max_faulty_nodes: 1, // f=1, n=3f+1=4 nodes minimum\n            checkpoint_interval: 100,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct PBFTMessage {\n    pub view: u64,\n    pub sequence: u64,\n    pub message_type: PBFTMessageType,\n    pub sender_id: NodeId,\n    pub timestamp: SystemTime,\n    pub signature: Signature,\n}\n\n#[derive(Debug, Clone)]\npub enum PBFTMessageType {\n    Request(Block<serde_json::Value>),\n    PrePrepare(BlockHash),\n    Prepare(BlockHash),\n    Commit(BlockHash),\n    ViewChange(u64), // new view\n    NewView(u64, Vec<PBFTMessage>), // new view + prepare messages\n    Checkpoint(u64, BlockHash), // sequence + state hash\n}\n\n#[async_trait::async_trait]\nimpl ConsensusAlgorithm for PBFT {\n    async fn propose_block(&mut self, block: Block<impl BlockPayload>) -> Result<ProposalId> {\n        // Check if we are the primary for current view\n        if !self.is_primary(self.current_view).await? {\n            return Err(ConsensusError::NotPrimary.into());\n        }\n        \n        self.current_sequence += 1;\n        let block_hash = block.hash()?;\n        \n        // Send PRE-PREPARE message\n        let pre_prepare = PBFTMessage {\n            view: self.current_view,\n            sequence: self.current_sequence,\n            message_type: PBFTMessageType::PrePrepare(block_hash),\n            sender_id: self.get_our_node_id(),\n            timestamp: SystemTime::now(),\n            signature: self.sign_message(&PBFTMessageType::PrePrepare(block_hash)).await?,\n        };\n        \n        self.message_log.insert((self.current_view, self.current_sequence), pre_prepare.clone());\n        self.broadcast_message(pre_prepare).await?;\n        \n        Ok(ProposalId::from_hash(block_hash))\n    }\n\n    async fn validate_block(&self, block: &Block<impl BlockPayload>) -> Result<bool> {\n        // Basic block validation\n        if !self.validate_block_structure(block).await? {\n            return Ok(false);\n        }\n        \n        // Check if block is part of current consensus round\n        let block_hash = block.hash()?;\n        if let Some(message) = self.message_log.get(&(self.current_view, self.current_sequence)) {\n            if let PBFTMessageType::PrePrepare(expected_hash) = &message.message_type {\n                return Ok(*expected_hash == block_hash);\n            }\n        }\n        \n        Ok(true)\n    }\n\n    async fn process_vote(&mut self, vote: Vote) -> Result<VoteResult> {\n        // Verify vote signature\n        if !self.verify_vote_signature(&vote).await? {\n            return Ok(VoteResult::Rejected("Invalid signature".to_string()));\n        }\n        \n        // Check if voter is valid\n        if !self.validator_set.is_validator(&vote.voter_id).await? {\n            return Ok(VoteResult::Rejected("Invalid validator".to_string()));\n        }\n        \n        // Add vote to tracker\n        let key = (vote.view, vote.round, vote.vote_type);\n        self.vote_tracker.entry(key).or_default().push(vote.clone());\n        \n        // Check thresholds\n        let votes = &self.vote_tracker[&key];\n        let required_votes = self.get_required_vote_count().await?;\n        \n        if votes.len() >= required_votes {\n            return Ok(VoteResult::Threshold(ThresholdReached {\n                vote_type: vote.vote_type,\n                block_hash: vote.block_hash,\n                vote_count: votes.len(),\n                total_weight: votes.len() as u64,\n            }));\n        }\n        \n        Ok(VoteResult::Accepted)\n    }\n\n    async fn finalize_block(&mut self, block_hash: BlockHash) -> Result<()> {\n        // Block is finalized when we have 2f+1 COMMIT messages\n        let commit_key = (self.current_view, self.current_sequence, VoteType::Commit);\n        \n        if let Some(commits) = self.vote_tracker.get(&commit_key) {\n            let required = self.get_required_vote_count().await?;\n            if commits.len() >= required {\n                // Block is committed\n                self.execute_block(block_hash).await?;\n                \n                // Send checkpoint if needed\n                if self.current_sequence % self.config.checkpoint_interval == 0 {\n                    self.send_checkpoint().await?;\n                }\n                \n                return Ok(());\n            }\n        }\n        \n        Err(ConsensusError::InsufficientVotes.into())\n    }\n\n    async fn get_current_leader(&self) -> Result<Option<NodeId>> {\n        let primary = self.get_primary_for_view(self.current_view).await?;\n        Ok(Some(primary))\n    }\n\n    async fn get_consensus_state(&self) -> Result<ConsensusState> {\n        Ok(ConsensusState {\n            algorithm_type: ConsensusType::PBFT,\n            current_round: self.current_sequence,\n            current_leader: self.get_current_leader().await?,\n            difficulty: None,\n            finalized_block_height: self.get_last_finalized_sequence(),\n        })\n    }\n\n    async fn handle_timeout(&mut self, timeout_type: TimeoutType) -> Result<()> {\n        match timeout_type {\n            TimeoutType::ViewTimeout => {\n                // Initiate view change\n                self.start_view_change().await?;\n            }\n            TimeoutType::PrepareTimeout => {\n                // Resend prepare or move to view change\n                self.handle_prepare_timeout().await?;\n            }\n            TimeoutType::CommitTimeout => {\n                // Resend commit or move to view change\n                self.handle_commit_timeout().await?;\n            }\n            _ => {}\n        }\n        Ok(())\n    }\n\n    fn algorithm_type(&self) -> ConsensusType {\n        ConsensusType::PBFT\n    }\n\n    fn supports_instant_finality(&self) -> bool {\n        true\n    }\n\n    fn max_fault_tolerance(&self) -> f64 {\n        0.33 // f < n/3\n    }\n}\n\nimpl PBFT {\n    pub async fn handle_pbft_message(&mut self, message: PBFTMessage) -> Result<()> {\n        // Verify message signature\n        if !self.verify_message_signature(&message).await? {\n            return Err(ConsensusError::InvalidSignature.into());\n        }\n        \n        match &message.message_type {\n            PBFTMessageType::PrePrepare(block_hash) => {\n                self.handle_pre_prepare(message, *block_hash).await?;\n            }\n            PBFTMessageType::Prepare(block_hash) => {\n                self.handle_prepare(message, *block_hash).await?;\n            }\n            PBFTMessageType::Commit(block_hash) => {\n                self.handle_commit(message, *block_hash).await?;\n            }\n            PBFTMessageType::ViewChange(new_view) => {\n                self.handle_view_change(message, *new_view).await?;\n            }\n            PBFTMessageType::NewView(new_view, prepare_messages) => {\n                self.handle_new_view(message, *new_view, prepare_messages).await?;\n            }\n            PBFTMessageType::Checkpoint(sequence, state_hash) => {\n                self.handle_checkpoint(message, *sequence, *state_hash).await?;\n            }\n            _ => {}\n        }\n        \n        Ok(())\n    }\n    \n    async fn handle_pre_prepare(&mut self, message: PBFTMessage, block_hash: BlockHash) -> Result<()> {\n        // Verify sender is primary for view\n        let primary = self.get_primary_for_view(message.view).await?;\n        if message.sender_id != primary {\n            return Err(ConsensusError::InvalidPrimary.into());\n        }\n        \n        // Store PRE-PREPARE message\n        self.message_log.insert((message.view, message.sequence), message);\n        \n        // Send PREPARE message\n        let prepare = PBFTMessage {\n            view: self.current_view,\n            sequence: message.sequence,\n            message_type: PBFTMessageType::Prepare(block_hash),\n            sender_id: self.get_our_node_id(),\n            timestamp: SystemTime::now(),\n            signature: self.sign_message(&PBFTMessageType::Prepare(block_hash)).await?,\n        };\n        \n        self.broadcast_message(prepare).await?;\n        Ok(())\n    }\n    \n    async fn handle_prepare(&mut self, message: PBFTMessage, block_hash: BlockHash) -> Result<()> {\n        // Add to vote tracker\n        let vote = Vote {\n            voter_id: message.sender_id,\n            block_hash,\n            vote_type: VoteType::Prepare,\n            round: message.sequence,\n            view: message.view,\n            signature: message.signature,\n            timestamp: message.timestamp,\n        };\n        \n        match self.process_vote(vote).await? {\n            VoteResult::Threshold(_) => {\n                // Send COMMIT message\n                let commit = PBFTMessage {\n                    view: self.current_view,\n                    sequence: message.sequence,\n                    message_type: PBFTMessageType::Commit(block_hash),\n                    sender_id: self.get_our_node_id(),\n                    timestamp: SystemTime::now(),\n                    signature: self.sign_message(&PBFTMessageType::Commit(block_hash)).await?,\n                };\n                \n                self.broadcast_message(commit).await?;\n            }\n            _ => {}\n        }\n        \n        Ok(())\n    }\n    \n    async fn handle_commit(&mut self, message: PBFTMessage, block_hash: BlockHash) -> Result<()> {\n        // Add to vote tracker\n        let vote = Vote {\n            voter_id: message.sender_id,\n            block_hash,\n            vote_type: VoteType::Commit,\n            round: message.sequence,\n            view: message.view,\n            signature: message.signature,\n            timestamp: message.timestamp,\n        };\n        \n        match self.process_vote(vote).await? {\n            VoteResult::Threshold(_) => {\n                // Execute block\n                self.finalize_block(block_hash).await?;\n            }\n            _ => {}\n        }\n        \n        Ok(())\n    }\n    \n    async fn is_primary(&self, view: u64) -> Result<bool> {\n        let primary = self.get_primary_for_view(view).await?;\n        Ok(primary == self.get_our_node_id())\n    }\n    \n    async fn get_primary_for_view(&self, view: u64) -> Result<NodeId> {\n        let validators = self.validator_set.get_validators().await?;\n        let primary_index = (view as usize) % validators.len();\n        Ok(validators[primary_index].node_id)\n    }\n    \n    async fn get_required_vote_count(&self) -> Result<usize> {\n        let total_validators = self.validator_set.get_validators().await?.len();\n        Ok(2 * self.config.max_faulty_nodes + 1)\n    }\n    \n    async fn start_view_change(&mut self) -> Result<()> {\n        self.current_view += 1;\n        \n        let view_change = PBFTMessage {\n            view: self.current_view,\n            sequence: self.current_sequence,\n            message_type: PBFTMessageType::ViewChange(self.current_view),\n            sender_id: self.get_our_node_id(),\n            timestamp: SystemTime::now(),\n            signature: self.sign_message(&PBFTMessageType::ViewChange(self.current_view)).await?,\n        };\n        \n        self.broadcast_message(view_change).await?;\n        Ok(())\n    }\n    \n    // Additional helper methods...\n    async fn handle_view_change(&mut self, _message: PBFTMessage, _new_view: u64) -> Result<()> {\n        // Implementation for view change handling\n        Ok(())\n    }\n    \n    async fn handle_new_view(&mut self, _message: PBFTMessage, _new_view: u64, _prepare_messages: &[PBFTMessage]) -> Result<()> {\n        // Implementation for new view handling\n        Ok(())\n    }\n    \n    async fn handle_checkpoint(&mut self, _message: PBFTMessage, _sequence: u64, _state_hash: BlockHash) -> Result<()> {\n        // Implementation for checkpoint handling\n        Ok(())\n    }\n    \n    async fn send_checkpoint(&mut self) -> Result<()> {\n        // Implementation for sending checkpoint\n        Ok(())\n    }\n    \n    async fn handle_prepare_timeout(&mut self) -> Result<()> {\n        // Implementation for prepare timeout\n        Ok(())\n    }\n    \n    async fn handle_commit_timeout(&mut self) -> Result<()> {\n        // Implementation for commit timeout\n        Ok(())\n    }\n    \n    async fn execute_block(&mut self, _block_hash: BlockHash) -> Result<()> {\n        // Implementation for block execution\n        Ok(())\n    }\n    \n    async fn validate_block_structure(&self, _block: &Block<impl BlockPayload>) -> Result<bool> {\n        // Implementation for block structure validation\n        Ok(true)\n    }\n    \n    async fn verify_vote_signature(&self, _vote: &Vote) -> Result<bool> {\n        // Implementation for vote signature verification\n        Ok(true)\n    }\n    \n    async fn verify_message_signature(&self, _message: &PBFTMessage) -> Result<bool> {\n        // Implementation for message signature verification\n        Ok(true)\n    }\n    \n    async fn sign_message(&self, _message_type: &PBFTMessageType) -> Result<Signature> {\n        // Implementation for message signing\n        Ok(Signature::default())\n    }\n    \n    async fn broadcast_message(&self, _message: PBFTMessage) -> Result<()> {\n        // Implementation for message broadcasting\n        Ok(())\n    }\n    \n    fn get_our_node_id(&self) -> NodeId {\n        NodeId::default()\n    }\n    \n    fn get_last_finalized_sequence(&self) -> u64 {\n        0\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"common-types-and-traits",children:"Common Types and Traits"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::consensus::types::*;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ConsensusType {\n    ProofOfWork,\n    ProofOfStake,\n    PBFT,\n    Raft,\n    Tendermint,\n}\n\n#[derive(Debug, Clone)]\npub struct ConsensusState {\n    pub algorithm_type: ConsensusType,\n    pub current_round: u64,\n    pub current_leader: Option<NodeId>,\n    pub difficulty: Option<u64>,\n    pub finalized_block_height: u64,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TimeoutType {\n    ViewTimeout,\n    SlotTimeout,\n    EpochTimeout,\n    PrepareTimeout,\n    CommitTimeout,\n    ElectionTimeout,\n    HeartbeatTimeout,\n}\n\n#[derive(Debug, Clone)]\npub struct ProposalId {\n    pub hash: BlockHash,\n    pub round: u64,\n    pub proposer: NodeId,\n}\n\nimpl ProposalId {\n    pub fn from_hash(hash: BlockHash) -> Self {\n        Self {\n            hash,\n            round: 0,\n            proposer: NodeId::default(),\n        }\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum ConsensusError {\n    #[error("Not selected as proposer for this round")]\n    NotSelectedProposer,\n    \n    #[error("Not the primary node")]\n    NotPrimary,\n    \n    #[error("Invalid primary node")]\n    InvalidPrimary,\n    \n    #[error("Invalid signature")]\n    InvalidSignature,\n    \n    #[error("Insufficient votes for consensus")]\n    InsufficientVotes,\n    \n    #[error("Network error: {0}")]\n    Network(#[from] NetworkError),\n    \n    #[error("Validation error: {0}")]\n    Validation(String),\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Algorithm"}),(0,o.jsx)(n.th,{children:"Throughput"}),(0,o.jsx)(n.th,{children:"Latency"}),(0,o.jsx)(n.th,{children:"Energy"}),(0,o.jsx)(n.th,{children:"Finality"}),(0,o.jsx)(n.th,{children:"Fault Tolerance"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"PoW"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Very High"}),(0,o.jsx)(n.td,{children:"Probabilistic"}),(0,o.jsx)(n.td,{children:"51% hash power"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"PoS"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Fast"}),(0,o.jsx)(n.td,{children:"33% stake"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"PBFT"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Instant"}),(0,o.jsx)(n.td,{children:"33% nodes"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Raft"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Instant"}),(0,o.jsx)(n.td,{children:"50% nodes (crash only)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Tendermint"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Instant"}),(0,o.jsx)(n.td,{children:"33% nodes"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"usage-guidelines",children:"Usage Guidelines"}),"\n",(0,o.jsx)(n.h3,{id:"when-to-use-each-algorithm",children:"When to Use Each Algorithm"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Proof of Work"}),": Public networks, maximum decentralization, energy not a concern"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Proof of Stake"}),": Public networks, energy efficiency important, economic security"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"PBFT"}),": Permissioned networks, Byzantine faults expected, instant finality required"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Raft"}),": Private networks, crash faults only, simplicity preferred"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tendermint"}),": High-performance applications, Byzantine faults, instant finality"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"configuration-recommendations",children:"Configuration Recommendations"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// Production PoW configuration\nlet pow_config = PoWConfig {\n    target_block_time: Duration::from_secs(300), // 5 minutes\n    difficulty_adjustment_interval: 288, // ~1 day\n    max_difficulty_change: 2.0,\n    ..Default::default()\n};\n\n// Production PoS configuration  \nlet pos_config = PoSConfig {\n    slot_duration: Duration::from_secs(12),\n    slots_per_epoch: 32,\n    min_stake: 32_000_000_000,\n    ..Default::default()\n};\n\n// Production PBFT configuration\nlet pbft_config = PBFTConfig {\n    view_timeout: Duration::from_secs(60),\n    prepare_timeout: Duration::from_secs(15),\n    commit_timeout: Duration::from_secs(15),\n    max_faulty_nodes: 2, // For 7-node cluster\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"Each consensus algorithm can be configured independently and integrated with the same high-level Olocus Protocol APIs, providing flexibility to choose the right algorithm for your specific use case and network requirements."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var s=t(6540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);