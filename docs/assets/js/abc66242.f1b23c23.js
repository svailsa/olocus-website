"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[2063],{2214:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/location-tracker","title":"Build a Location Tracker","description":"Learn how to build a privacy-preserving location tracker using Olocus Protocol.","source":"@site/docs/tutorials/location-tracker.md","sourceDirName":"tutorials","slug":"/tutorials/location-tracker","permalink":"/docs/tutorials/location-tracker","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/tutorials/location-tracker.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":1,"frontMatter":{"id":"location-tracker","title":"Build a Location Tracker","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Debugging","permalink":"/docs/tools/debugging"},"next":{"title":"Trust Networks","permalink":"/docs/tutorials/trust-networks"}}');var s=t(4848),a=t(8453);const r={id:"location-tracker",title:"Build a Location Tracker",sidebar_position:1},o="Build a Location Tracker",c={},l=[{value:"What We&#39;ll Build",id:"what-well-build",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Project Setup",id:"step-1-project-setup",level:2},{value:"Step 2: Basic Location Tracking",id:"step-2-basic-location-tracking",level:2},{value:"Step 3: Visit Detection",id:"step-3-visit-detection",level:2},{value:"Step 4: Privacy Protection",id:"step-4-privacy-protection",level:2},{value:"Step 5: Persistent Storage",id:"step-5-persistent-storage",level:2},{value:"Step 6: Real-time Tracking",id:"step-6-real-time-tracking",level:2},{value:"Step 7: Advanced Features",id:"step-7-advanced-features",level:2},{value:"Spoofing Detection",id:"spoofing-detection",level:3},{value:"Geofencing",id:"geofencing",level:3},{value:"Step 8: Testing",id:"step-8-testing",level:2},{value:"Running the Application",id:"running-the-application",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Add More Features",id:"add-more-features",level:3},{value:"Enhance Privacy",id:"enhance-privacy",level:3},{value:"Scale It Up",id:"scale-it-up",level:3},{value:"Integrate More Extensions",id:"integrate-more-extensions",level:3},{value:"Complete Code",id:"complete-code",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"build-a-location-tracker",children:"Build a Location Tracker"})}),"\n",(0,s.jsx)(n.p,{children:"Learn how to build a privacy-preserving location tracker using Olocus Protocol."}),"\n",(0,s.jsx)(n.h2,{id:"what-well-build",children:"What We'll Build"}),"\n",(0,s.jsx)(n.p,{children:"A location tracking application that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Records GPS positions with accuracy"}),"\n",(0,s.jsx)(n.li,{children:"Detects visits to significant locations"}),"\n",(0,s.jsx)(n.li,{children:"Preserves privacy with obfuscation"}),"\n",(0,s.jsx)(n.li,{children:"Creates an immutable audit trail"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rust 1.75+"}),"\n",(0,s.jsx)(n.li,{children:"Basic understanding of GPS/location services"}),"\n",(0,s.jsx)(n.li,{children:"Familiarity with async Rust (helpful but not required)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"step-1-project-setup",children:"Step 1: Project Setup"}),"\n",(0,s.jsx)(n.p,{children:"Create a new Rust project:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cargo new olocus-tracker\ncd olocus-tracker\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Add dependencies to ",(0,s.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nolocus-core = "0.1"\nolocus-location = "0.1"\nolocus-privacy = "0.1"\nolocus-storage = { version = "0.1", features = ["sqlite"] }\ntokio = { version = "1.0", features = ["full"] }\nchrono = "0.4"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-2-basic-location-tracking",children:"Step 2: Basic Location Tracking"}),"\n",(0,s.jsxs)(n.p,{children:["Create ",(0,s.jsx)(n.code,{children:"src/tracker.rs"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{\n    Block, BlockPayload, generate_key, current_timestamp,\n    Measurement, Value, Uncertainty, Provenance, Source,\n    ValidityWindow, Coordinate\n};\nuse olocus_location::{LocationPayload, LocationProvider};\n\npub struct LocationTracker {\n    signing_key: [u8; 32],\n    chain: Vec<Block<LocationPayload>>,\n}\n\nimpl LocationTracker {\n    pub fn new() -> Self {\n        let (signing_key, _) = generate_key();\n        Self {\n            signing_key,\n            chain: Vec::new(),\n        }\n    }\n    \n    pub fn record_location(\n        &mut self,\n        latitude: f64,\n        longitude: f64,\n        accuracy: f32,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        // Convert to fixed-point\n        let lat_fixed = Coordinate::latitude_to_fixed(latitude);\n        let lon_fixed = Coordinate::longitude_to_fixed(longitude);\n        \n        // Create location payload with measurement\n        let location = LocationPayload {\n            measurement: Measurement {\n                value: Value::Point2D {\n                    lat: lat_fixed,\n                    lon: lon_fixed,\n                },\n                uncertainty: Uncertainty::Circular {\n                    angle: 0.0,\n                    radius: accuracy as f64,\n                },\n                provenance: Provenance {\n                    source: Source::Sensor {\n                        device_id: [0; 32], // Your device ID\n                        sensor_type: 0x0001, // GPS\n                        calibration_id: None,\n                    },\n                    transformations: vec![],\n                    attestations: vec![],\n                },\n                validity: ValidityWindow::new(\n                    current_timestamp() as i64,\n                    Some((current_timestamp() + 300) as i64), // Valid for 5 minutes\n                ),\n            },\n            provider: LocationProvider::Gps,\n            metadata: Default::default(),\n        };\n        \n        // Create block\n        let block = if self.chain.is_empty() {\n            Block::genesis(location, &self.signing_key, current_timestamp())\n        } else {\n            Block::next(\n                self.chain.last().unwrap(),\n                location,\n                &self.signing_key,\n                current_timestamp(),\n            )?\n        };\n        \n        // Verify and add to chain\n        block.verify_signature()?;\n        self.chain.push(block);\n        \n        Ok(())\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-3-visit-detection",children:"Step 3: Visit Detection"}),"\n",(0,s.jsx)(n.p,{children:"Add visit detection using DBSCAN clustering:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_location::{\n    VisitDetector, Visit, BuiltInClusteringAlgorithm,\n    ClusteringAlgorithm,\n};\n\nimpl LocationTracker {\n    pub fn detect_visits(&self) -> Vec<Visit> {\n        let detector = VisitDetector::new()\n            .with_min_duration(300)  // 5 minutes minimum\n            .with_max_radius(100.0);  // 100 meter radius\n        \n        // Extract locations from chain\n        let locations: Vec<_> = self.chain\n            .iter()\n            .map(|block| &block.payload)\n            .collect();\n        \n        // Detect visits using DBSCAN\n        let visits = detector.detect_visits(&locations);\n        \n        // Classify visits\n        for visit in &visits {\n            let visit_type = self.classify_visit(visit);\n            println!("Visit detected: {:?} at {}", \n                visit_type, \n                visit.start_time\n            );\n        }\n        \n        visits\n    }\n    \n    fn classify_visit(&self, visit: &Visit) -> VisitType {\n        let duration = visit.end_time - visit.start_time;\n        \n        if duration > 28800 { // 8 hours\n            VisitType::Home\n        } else if duration > 14400 { // 4 hours\n            VisitType::Work\n        } else if duration > 1800 { // 30 minutes\n            VisitType::Shopping\n        } else {\n            VisitType::Transit\n        }\n    }\n}\n\n#[derive(Debug)]\nenum VisitType {\n    Home,\n    Work,\n    Shopping,\n    Transit,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-4-privacy-protection",children:"Step 4: Privacy Protection"}),"\n",(0,s.jsx)(n.p,{children:"Add location obfuscation for privacy:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::{\n    BuiltInObfuscation, ObfuscationMethod,\n    PrivacyLevel,\n};\n\nimpl LocationTracker {\n    pub fn record_private_location(\n        &mut self,\n        latitude: f64,\n        longitude: f64,\n        accuracy: f32,\n        privacy_level: PrivacyLevel,\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        // Apply obfuscation based on privacy level\n        let obfuscator = match privacy_level {\n            PrivacyLevel::Low => BuiltInObfuscation::GridSnapping {\n                grid_size_meters: 10.0,\n            },\n            PrivacyLevel::Medium => BuiltInObfuscation::GaussianNoise {\n                sigma_meters: 50.0,\n            },\n            PrivacyLevel::High => BuiltInObfuscation::GridSnapping {\n                grid_size_meters: 100.0,\n            },\n        };\n        \n        // Obfuscate location\n        let (obf_lat, obf_lon) = obfuscator.obfuscate(\n            latitude, \n            longitude\n        )?;\n        \n        // Record obfuscated location with updated uncertainty\n        self.record_location_with_uncertainty(\n            obf_lat,\n            obf_lon,\n            accuracy + obfuscator.added_uncertainty(),\n        )\n    }\n}\n\n#[derive(Debug)]\npub enum PrivacyLevel {\n    Low,    // 10m grid snapping\n    Medium, // 50m Gaussian noise\n    High,   // 100m grid snapping\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-5-persistent-storage",children:"Step 5: Persistent Storage"}),"\n",(0,s.jsx)(n.p,{children:"Add SQLite storage for the location chain:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_storage::{BuiltInStorageBackend, StorageBackend};\nuse std::path::PathBuf;\n\nimpl LocationTracker {\n    pub async fn save_to_disk(&self) -> Result<(), Box<dyn std::error::Error>> {\n        let storage = BuiltInStorageBackend::Sqlite {\n            path: PathBuf::from("locations.db"),\n        };\n        \n        // Initialize storage\n        storage.initialize().await?;\n        \n        // Save each block\n        for block in &self.chain {\n            let hash = block.hash();\n            let data = block.to_bytes()?;\n            storage.put(&hash, &data).await?;\n        }\n        \n        Ok(())\n    }\n    \n    pub async fn load_from_disk() -> Result<Self, Box<dyn std::error::Error>> {\n        let storage = BuiltInStorageBackend::Sqlite {\n            path: PathBuf::from("locations.db"),\n        };\n        \n        // Load chain from storage\n        let blocks = storage.list(1000, 0).await?;\n        \n        let mut chain = Vec::new();\n        for hash in blocks {\n            if let Some(data) = storage.get(&hash).await? {\n                let block = Block::<LocationPayload>::from_bytes(&data)?;\n                chain.push(block);\n            }\n        }\n        \n        // Verify chain integrity\n        olocus_core::verify_chain(&chain)?;\n        \n        Ok(Self {\n            signing_key: generate_key().0,\n            chain,\n        })\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-6-real-time-tracking",children:"Step 6: Real-time Tracking"}),"\n",(0,s.jsxs)(n.p,{children:["Create the main application in ",(0,s.jsx)(n.code,{children:"src/main.rs"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_tracker::{LocationTracker, PrivacyLevel};\nuse tokio::time::{sleep, Duration};\nuse std::f64::consts::PI;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut tracker = LocationTracker::new();\n    \n    // Simulate GPS updates\n    println!("Starting location tracking...");\n    \n    for i in 0..100 {\n        // Simulate movement (circular path for demo)\n        let angle = (i as f64) * 2.0 * PI / 100.0;\n        let latitude = 37.7749 + 0.001 * angle.cos();\n        let longitude = -122.4194 + 0.001 * angle.sin();\n        let accuracy = 5.0 + (i as f32 % 10) as f32; // Variable accuracy\n        \n        // Determine privacy level based on time of day\n        let privacy = if i % 24 < 8 {\n            PrivacyLevel::High  // Night time - high privacy\n        } else if i % 24 < 18 {\n            PrivacyLevel::Low   // Day time - low privacy\n        } else {\n            PrivacyLevel::Medium // Evening - medium privacy\n        };\n        \n        // Record location\n        tracker.record_private_location(\n            latitude,\n            longitude,\n            accuracy,\n            privacy,\n        )?;\n        \n        println!("Location {} recorded: {:.6}, {:.6} (\xb1{}m)", \n            i + 1, latitude, longitude, accuracy\n        );\n        \n        // Check for visits every 10 locations\n        if i % 10 == 9 {\n            let visits = tracker.detect_visits();\n            println!("Found {} visits", visits.len());\n        }\n        \n        // Simulate GPS update interval\n        sleep(Duration::from_secs(1)).await;\n    }\n    \n    // Save to disk\n    tracker.save_to_disk().await?;\n    println!("Location chain saved to disk");\n    \n    // Final visit detection\n    let visits = tracker.detect_visits();\n    println!("\\nFinal Summary:");\n    println!("Total locations: {}", tracker.chain.len());\n    println!("Total visits: {}", visits.len());\n    \n    // Verify chain integrity\n    olocus_core::verify_chain(&tracker.chain)?;\n    println!("Chain integrity verified \u2713");\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-7-advanced-features",children:"Step 7: Advanced Features"}),"\n",(0,s.jsx)(n.h3,{id:"spoofing-detection",children:"Spoofing Detection"}),"\n",(0,s.jsx)(n.p,{children:"Add velocity-based spoofing detection:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_location::{SpoofingDetector, BuiltInSpoofingDetector};\n\nimpl LocationTracker {\n    pub fn check_for_spoofing(&self) -> Vec<SpoofingAlert> {\n        let detector = BuiltInSpoofingDetector::VelocityCheck {\n            max_speed_ms: 55.0, // ~200 km/h max realistic speed\n        };\n        \n        let mut alerts = Vec::new();\n        \n        for window in self.chain.windows(2) {\n            let prev = &window[0].payload;\n            let curr = &window[1].payload;\n            \n            if detector.is_suspicious(prev, curr) {\n                alerts.push(SpoofingAlert {\n                    timestamp: curr.measurement.validity.start,\n                    reason: "Impossible velocity detected".to_string(),\n                });\n            }\n        }\n        \n        alerts\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"geofencing",children:"Geofencing"}),"\n",(0,s.jsx)(n.p,{children:"Add geofence monitoring:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct Geofence {\n    pub center_lat: f64,\n    pub center_lon: f64,\n    pub radius_meters: f64,\n    pub name: String,\n}\n\nimpl LocationTracker {\n    pub fn check_geofences(\n        &self,\n        geofences: &[Geofence],\n    ) -> Vec<GeofenceEvent> {\n        let mut events = Vec::new();\n        \n        for block in &self.chain {\n            let lat = Coordinate::fixed_to_latitude(\n                block.payload.measurement.value.lat()\n            );\n            let lon = Coordinate::fixed_to_longitude(\n                block.payload.measurement.value.lon()\n            );\n            \n            for fence in geofences {\n                let distance = Coordinate::haversine_distance(\n                    Coordinate::latitude_to_fixed(fence.center_lat),\n                    Coordinate::longitude_to_fixed(fence.center_lon),\n                    Coordinate::latitude_to_fixed(lat),\n                    Coordinate::longitude_to_fixed(lon),\n                );\n                \n                if distance <= fence.radius_meters {\n                    events.push(GeofenceEvent::Enter {\n                        fence_name: fence.name.clone(),\n                        timestamp: block.header.timestamp,\n                    });\n                }\n            }\n        }\n        \n        events\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-8-testing",children:"Step 8: Testing"}),"\n",(0,s.jsxs)(n.p,{children:["Create tests in ",(0,s.jsx)(n.code,{children:"src/lib.rs"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_location_recording() {\n        let mut tracker = LocationTracker::new();\n        \n        // Record location\n        tracker.record_location(37.7749, -122.4194, 10.0).unwrap();\n        \n        assert_eq!(tracker.chain.len(), 1);\n        \n        // Verify block\n        let block = &tracker.chain[0];\n        assert!(block.verify_signature().is_ok());\n    }\n    \n    #[test]\n    fn test_visit_detection() {\n        let mut tracker = LocationTracker::new();\n        \n        // Record multiple locations at same spot (visit)\n        for _ in 0..10 {\n            tracker.record_location(37.7749, -122.4194, 5.0).unwrap();\n        }\n        \n        let visits = tracker.detect_visits();\n        assert!(visits.len() > 0);\n    }\n    \n    #[test]\n    fn test_privacy_obfuscation() {\n        let mut tracker = LocationTracker::new();\n        \n        // Record with high privacy\n        tracker.record_private_location(\n            37.7749, \n            -122.4194, \n            5.0,\n            PrivacyLevel::High\n        ).unwrap();\n        \n        // Location should be snapped to grid\n        let block = &tracker.chain[0];\n        let lat = Coordinate::fixed_to_latitude(\n            block.payload.measurement.value.lat()\n        );\n        \n        // Check grid snapping (100m grid)\n        let grid_size = 100.0 / 111111.0; // meters to degrees\n        assert!((lat % grid_size).abs() < 0.0001);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"running-the-application",children:"Running the Application"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Build and run:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cargo build --release\ncargo run --release\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Run tests:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Check the output:"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Watch real-time location tracking"}),"\n",(0,s.jsx)(n.li,{children:"See visit detection results"}),"\n",(0,s.jsx)(n.li,{children:"Verify chain integrity"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Congratulations! You've built a privacy-preserving location tracker. Here are some ideas to extend it:"}),"\n",(0,s.jsx)(n.h3,{id:"add-more-features",children:"Add More Features"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Real GPS integration (using system APIs)"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Export to GPX/KML formats"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Web visualization with maps"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Battery optimization strategies"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"enhance-privacy",children:"Enhance Privacy"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement k-anonymity"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add differential privacy"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Create privacy zones"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scale-it-up",children:"Scale It Up"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Multi-device synchronization"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cloud backup"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Real-time sharing"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integrate-more-extensions",children:"Integrate More Extensions"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add ",(0,s.jsx)(n.code,{children:"olocus-trust"})," for location attestations"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Use ",(0,s.jsx)(n.code,{children:"olocus-metrics"})," for tracking statistics"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Implement ",(0,s.jsx)(n.code,{children:"olocus-http"})," for REST API"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complete-code",children:"Complete Code"}),"\n",(0,s.jsx)(n.p,{children:"The complete code for this tutorial is available at:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://codeberg.org/olocus/tutorials/location-tracker",children:"Codeberg"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://codeberg.org/olocus/tutorials/location-tracker",children:"Codeberg"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../extensions/location/tracking",children:"Location Extension Docs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../extensions/privacy/techniques",children:"Privacy Extension Docs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"../api/core",children:"API Reference"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://codeberg.org/olocus/forum/issues",children:"Community Forum"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);