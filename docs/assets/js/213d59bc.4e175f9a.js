"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[2418],{67:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"concepts/measurements","title":"Universal Measurement Foundation","description":"The Olocus Protocol includes a comprehensive system for representing any measured data with uncertainty, provenance, and validity.","source":"@site/docs/concepts/measurements.md","sourceDirName":"concepts","slug":"/concepts/measurements","permalink":"/docs/concepts/measurements","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/measurements.md","tags":[],"version":"current","lastUpdatedAt":1764937116000,"sidebarPosition":4,"frontMatter":{"id":"measurements","title":"Universal Measurement Foundation","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Blocks and Chains","permalink":"/docs/concepts/blocks-and-chains"},"next":{"title":"Cryptographic Primitives","permalink":"/docs/concepts/cryptographic-primitives"}}');var a=i(4848),r=i(8453);const s={id:"measurements",title:"Universal Measurement Foundation",sidebar_position:4},l="Universal Measurement Foundation",o={},c=[{value:"Core Concept",id:"core-concept",level:2},{value:"The Measurement Type",id:"the-measurement-type",level:2},{value:"Value Types",id:"value-types",level:2},{value:"Primitives",id:"primitives",level:3},{value:"Temporal",id:"temporal",level:3},{value:"Spatial (Fixed-Point)",id:"spatial-fixed-point",level:3},{value:"Collections",id:"collections",level:3},{value:"Uncertainty Types",id:"uncertainty-types",level:2},{value:"Gaussian (Normal Distribution)",id:"gaussian-normal-distribution",level:3},{value:"Interval",id:"interval",level:3},{value:"Circular (Directional)",id:"circular-directional",level:3},{value:"Exact or Unknown",id:"exact-or-unknown",level:3},{value:"Provenance Tracking",id:"provenance-tracking",level:2},{value:"Source Types",id:"source-types",level:3},{value:"Transformations",id:"transformations",level:3},{value:"Attestations",id:"attestations",level:3},{value:"Validity Windows",id:"validity-windows",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"GPS Location",id:"gps-location",level:3},{value:"Temperature Reading",id:"temperature-reading",level:3},{value:"Machine Learning Prediction",id:"machine-learning-prediction",level:3},{value:"Coordinate Utilities",id:"coordinate-utilities",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"universal-measurement-foundation",children:"Universal Measurement Foundation"})}),"\n",(0,a.jsx)(n.p,{children:"The Olocus Protocol includes a comprehensive system for representing any measured data with uncertainty, provenance, and validity."}),"\n",(0,a.jsx)(n.h2,{id:"core-concept",children:"Core Concept"}),"\n",(0,a.jsx)(n.p,{children:"Every piece of data in the real world has:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Value"}),": The actual measurement"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Uncertainty"}),": How accurate is it?"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Provenance"}),": Where did it come from?"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validity"}),": When is it valid?"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"the-measurement-type",children:"The Measurement Type"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct Measurement {\n    pub value: Value,\n    pub uncertainty: Uncertainty,\n    pub provenance: Provenance,\n    pub validity: ValidityWindow,\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"value-types",children:"Value Types"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Value"})," enum supports ~40 different types:"]}),"\n",(0,a.jsx)(n.h3,{id:"primitives",children:"Primitives"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'Value::Bool(true)\nValue::Int(42)\nValue::Float(3.14159)\nValue::String("Hello".to_string())\n'})}),"\n",(0,a.jsx)(n.h3,{id:"temporal",children:"Temporal"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Value::Timestamp(1701234567)  // Unix seconds\nValue::Duration(3600)          // Nanoseconds\nValue::Date { year: 2024, month: 12, day: 25 }\n"})}),"\n",(0,a.jsx)(n.h3,{id:"spatial-fixed-point",children:"Spatial (Fixed-Point)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// San Francisco coordinates (degrees \xd7 10^7)\nValue::Point2D { \n    lat: 377749000,  // 37.7749\xb0\n    lon: -1224194000 // -122.4194\xb0\n}\n\n// With altitude (millimeters)\nValue::Point3D {\n    lat: 377749000,\n    lon: -1224194000,\n    alt: 52000  // 52 meters\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'Value::Array(vec![Value::Int(1), Value::Int(2), Value::Int(3)])\nValue::Object(BTreeMap::from([\n    ("name".to_string(), Value::String("Alice".to_string())),\n    ("age".to_string(), Value::Int(30))\n]))\n'})}),"\n",(0,a.jsx)(n.h2,{id:"uncertainty-types",children:"Uncertainty Types"}),"\n",(0,a.jsx)(n.p,{children:"Quantify how certain you are about a measurement:"}),"\n",(0,a.jsx)(n.h3,{id:"gaussian-normal-distribution",children:"Gaussian (Normal Distribution)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Uncertainty::Gaussian { std_dev: 2.0 }\n"})}),"\n",(0,a.jsx)(n.h3,{id:"interval",children:"Interval"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Uncertainty::Interval {\n    lower: 10.0,\n    upper: 20.0,\n    confidence: 0.95  // 95% confidence interval\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"circular-directional",children:"Circular (Directional)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Uncertainty::Circular {\n    angle: 45.0,   // degrees\n    radius: 5.0    // uncertainty radius\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"exact-or-unknown",children:"Exact or Unknown"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Uncertainty::Exact        // No uncertainty\nUncertainty::Unknown      // Uncertainty not quantified\n"})}),"\n",(0,a.jsx)(n.h2,{id:"provenance-tracking",children:"Provenance Tracking"}),"\n",(0,a.jsx)(n.p,{children:"Track where data comes from and how it's been transformed:"}),"\n",(0,a.jsx)(n.h3,{id:"source-types",children:"Source Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Source::Sensor {\n    device_id: [0u8; 32],\n    sensor_type: 0x0001,  // GPS\n    calibration_id: Some([1u8; 32])\n}\n\nSource::Derived {\n    algorithm_id: 0x1000,\n    input_hashes: vec![previous_hash]\n}\n\nSource::SelfReported {\n    reporter_id: [0u8; 32],\n    method: 0x0001  // Manual entry\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"transformations",children:"Transformations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Transformation {\n    operation: TransformationOp::Filter {\n        algorithm: 0x0001,  // Kalman filter\n        parameters: vec![]\n    },\n    timestamp: current_timestamp(),\n    actor: actor_id,\n    input_hash: input_data_hash\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"attestations",children:"Attestations"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"Attestation {\n    attestor: attestor_id,\n    claim: AttestationClaim::Witnessed,\n    signature: signature_bytes,\n    timestamp: current_timestamp()\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"validity-windows",children:"Validity Windows"}),"\n",(0,a.jsx)(n.p,{children:"Define when measurements are valid:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// Valid forever\nValidityWindow::perpetual()\n\n// Valid for 1 hour\nValidityWindow::new(\n    start_timestamp as i64,\n    Some((start_timestamp + 3600) as i64)\n)\n\n// With decay function\nValidityWindow {\n    start: now,\n    end: Some(now + 86400),\n    decay: Some(DecayFunction::Exponential {\n        half_life: 3600  // Value decays by half every hour\n    })\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.h3,{id:"gps-location",children:"GPS Location"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let gps_measurement = Measurement {\n    value: Value::Point2D {\n        lat: Coordinate::latitude_to_fixed(37.7749),\n        lon: Coordinate::longitude_to_fixed(-122.4194),\n    },\n    uncertainty: Uncertainty::Circular {\n        angle: 0.0,\n        radius: 10.0,  // 10 meter accuracy\n    },\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: device_id,\n            sensor_type: 0x0001,  // GPS\n            calibration_id: None,\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::new(\n        current_timestamp() as i64,\n        Some((current_timestamp() + 300) as i64)  // Valid for 5 minutes\n    ),\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"temperature-reading",children:"Temperature Reading"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let temperature = Measurement {\n    value: Value::Float(22.5),  // 22.5\xb0C\n    uncertainty: Uncertainty::Gaussian {\n        std_dev: 0.1  // \xb10.1\xb0C standard deviation\n    },\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: sensor_id,\n            sensor_type: 0x0002,  // Temperature sensor\n            calibration_id: Some(calibration_id),\n        },\n        transformations: vec![\n            Transformation {\n                operation: TransformationOp::UnitConversion {\n                    from_unit: 0x0001,  // Fahrenheit\n                    to_unit: 0x0002,    // Celsius\n                },\n                timestamp: current_timestamp(),\n                actor: converter_id,\n                input_hash: raw_reading_hash,\n            }\n        ],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::perpetual(),\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"machine-learning-prediction",children:"Machine Learning Prediction"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let ml_prediction = Measurement {\n    value: Value::Float(0.87),  // 87% probability\n    uncertainty: Uncertainty::Confidence {\n        level: 0.95  // Model confidence\n    },\n    provenance: Provenance {\n        source: Source::Derived {\n            algorithm_id: 0x2000,  // Neural network\n            input_hashes: vec![input_data_hash],\n        },\n        transformations: vec![],\n        attestations: vec![\n            Attestation {\n                attestor: model_validator_id,\n                claim: AttestationClaim::Verified {\n                    reference_id: validation_hash,\n                },\n                signature: validator_signature,\n                timestamp: validation_timestamp,\n            }\n        ],\n    },\n    validity: ValidityWindow::new(\n        current_timestamp() as i64,\n        Some((current_timestamp() + 3600) as i64)  // Valid for 1 hour\n    ),\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"coordinate-utilities",children:"Coordinate Utilities"}),"\n",(0,a.jsx)(n.p,{children:"Helper functions for working with geographic coordinates:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// Convert degrees to fixed-point\nlet lat_fixed = Coordinate::latitude_to_fixed(37.7749);\nlet lon_fixed = Coordinate::longitude_to_fixed(-122.4194);\n\n// Convert back to degrees\nlet lat_degrees = Coordinate::fixed_to_latitude(lat_fixed);\nlet lon_degrees = Coordinate::fixed_to_longitude(lon_fixed);\n\n// Calculate distance (meters)\nlet distance = Coordinate::haversine_distance(\n    lat1_fixed, lon1_fixed,\n    lat2_fixed, lon2_fixed\n);\n\n// Calculate bearing (degrees)\nlet bearing = Coordinate::bearing(\n    lat1_fixed, lon1_fixed,\n    lat2_fixed, lon2_fixed\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always include uncertainty"})," - Even if it's ",(0,a.jsx)(n.code,{children:"Uncertainty::Unknown"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Track provenance"})," - Know where your data comes from"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Set appropriate validity"})," - Data gets stale"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use fixed-point for coordinates"})," - Ensures cross-platform consistency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Include attestations"})," - When third-party verification is available"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../extensions/overview",children:"Browse Extensions"})," - Available extensions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../extensions/creating-extensions",children:"Creating Extensions"})," - Build custom extensions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../api/core",children:"API Reference"})," - Core API documentation"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);