"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[6697],{757:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"concepts/wire-formats","title":"Wire Formats","description":"The Olocus Protocol wire format system provides flexible, efficient data encoding with multiple format options and compression methods. This enables applications to choose optimal representations for their specific requirements while maintaining interoperability.","source":"@site/docs/concepts/wire-formats.md","sourceDirName":"concepts","slug":"/concepts/wire-formats","permalink":"/docs/concepts/wire-formats","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/wire-formats.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":3,"frontMatter":{"id":"wire-formats","title":"Wire Formats","sidebar_position":3}}');var s=r(4848),o=r(8453);const t={id:"wire-formats",title:"Wire Formats",sidebar_position:3},a="Wire Formats",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Design Goals",id:"design-goals",level:3},{value:"Encoding Formats",id:"encoding-formats",level:2},{value:"1. Binary Format (Default)",id:"1-binary-format-default",level:3},{value:"Structure Layout",id:"structure-layout",level:4},{value:"Header Layout (86 bytes)",id:"header-layout-86-bytes",level:4},{value:"Binary Encoding Implementation",id:"binary-encoding-implementation",level:4},{value:"2. JSON Format",id:"2-json-format",level:3},{value:"JSON Structure",id:"json-structure",level:4},{value:"JSON Encoding Features",id:"json-encoding-features",level:4},{value:"3. MessagePack Format",id:"3-messagepack-format",level:3},{value:"Advantages",id:"advantages",level:4},{value:"Performance Comparison",id:"performance-comparison",level:4},{value:"MessagePack Structure",id:"messagepack-structure",level:4},{value:"4. Protobuf Format",id:"4-protobuf-format",level:3},{value:"Protobuf Wire Format",id:"protobuf-wire-format",level:4},{value:"Cross-Language Compatibility",id:"cross-language-compatibility",level:4},{value:"5. SSZ Format (Simple Serialize)",id:"5-ssz-format-simple-serialize",level:3},{value:"SSZ Characteristics",id:"ssz-characteristics",level:4},{value:"SSZ Compatibility",id:"ssz-compatibility",level:4},{value:"Compression Methods",id:"compression-methods",level:2},{value:"1. No Compression (Default)",id:"1-no-compression-default",level:3},{value:"2. Zstd Compression",id:"2-zstd-compression",level:3},{value:"Zstd Characteristics",id:"zstd-characteristics",level:4},{value:"3. LZ4 Compression",id:"3-lz4-compression",level:3},{value:"LZ4 Characteristics",id:"lz4-characteristics",level:4},{value:"4. Gzip Compression",id:"4-gzip-compression",level:3},{value:"Gzip Characteristics",id:"gzip-characteristics",level:4},{value:"WireFormat API",id:"wireformat-api",level:2},{value:"Core Structure",id:"core-structure",level:3},{value:"Common Presets",id:"common-presets",level:3},{value:"Encoding/Decoding Operations",id:"encodingdecoding-operations",level:3},{value:"Content Type Negotiation",id:"content-type-negotiation",level:2},{value:"Content-Type Headers",id:"content-type-headers",level:3},{value:"Compression Suffixes",id:"compression-suffixes",level:3},{value:"Content-Type Parsing",id:"content-type-parsing",level:3},{value:"HTTP Integration Example",id:"http-integration-example",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Benchmark Results",id:"benchmark-results",level:3},{value:"Performance Factors",id:"performance-factors",level:3},{value:"Encoding Performance",id:"encoding-performance",level:4},{value:"Compression Performance",id:"compression-performance",level:4},{value:"Memory Usage",id:"memory-usage",level:4},{value:"Format Selection Guidelines",id:"format-selection-guidelines",level:2},{value:"Decision Matrix",id:"decision-matrix",level:3},{value:"Use Case Examples",id:"use-case-examples",level:3},{value:"High-Frequency Trading",id:"high-frequency-trading",level:4},{value:"Archival Storage",id:"archival-storage",level:4},{value:"Web API",id:"web-api",level:4},{value:"IoT Sensor Network",id:"iot-sensor-network",level:4},{value:"Version Compatibility",id:"version-compatibility",level:2},{value:"Format Evolution",id:"format-evolution",level:3},{value:"Migration Support",id:"migration-support",level:3},{value:"Feature Detection",id:"feature-detection",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Wire Format Errors",id:"wire-format-errors",level:3},{value:"Graceful Degradation",id:"graceful-degradation",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"wire-formats",children:"Wire Formats"})}),"\n",(0,s.jsx)(n.p,{children:"The Olocus Protocol wire format system provides flexible, efficient data encoding with multiple format options and compression methods. This enables applications to choose optimal representations for their specific requirements while maintaining interoperability."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The wire format system supports ",(0,s.jsx)(n.strong,{children:"5 encoding formats"})," and ",(0,s.jsx)(n.strong,{children:"4 compression methods"}),", providing ",(0,s.jsx)(n.strong,{children:"20 possible combinations"})," for data serialization. This flexibility allows optimization for different scenarios: size, speed, debugging, or cross-platform compatibility."]}),"\n",(0,s.jsx)(n.h3,{id:"design-goals",children:"Design Goals"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficiency"}),": Minimal overhead for high-performance applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexibility"}),": Multiple encoding options for different use cases"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interoperability"}),": Cross-platform deterministic serialization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extensibility"}),": Support for future encoding formats"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),": Human-readable formats for development"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"encoding-formats",children:"Encoding Formats"}),"\n",(0,s.jsx)(n.h3,{id:"1-binary-format-default",children:"1. Binary Format (Default)"}),"\n",(0,s.jsx)(n.p,{children:"The canonical binary format provides maximum efficiency and is the protocol's native representation:"}),"\n",(0,s.jsx)(n.h4,{id:"structure-layout",children:"Structure Layout"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header (86B)    \u2502 Payload \u2502 Signature \u2502 Public Key  \u2502\n\u2502                 \u2502 (var)   \u2502 (64B)     \u2502 (32B)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h4,{id:"header-layout-86-bytes",children:"Header Layout (86 bytes)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Offset  Field          Size   Description\n------  -----          ----   -----------\n0-1     version        2B     Protocol version (little-endian)\n2-9     index          8B     Block index (little-endian)\n10-17   timestamp      8B     Unix timestamp (little-endian)\n18-49   previous       32B    Previous block hash\n50-81   payload_hash   32B    SHA-256 of payload\n82-85   payload_type   4B     Payload type ID (little-endian)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"binary-encoding-implementation",children:"Binary Encoding Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl WireFormat {\n    pub fn encode_binary(&self, block: &Block<T>) -> Result<Vec<u8>> {\n        let mut buffer = Vec::with_capacity(186 + block.payload.to_bytes().len());\n        \n        // Header (86 bytes)\n        buffer.extend_from_slice(&block.header.version.to_le_bytes());\n        buffer.extend_from_slice(&block.header.index.to_le_bytes());\n        buffer.extend_from_slice(&block.header.timestamp.to_le_bytes());\n        buffer.extend_from_slice(&block.header.previous);\n        buffer.extend_from_slice(&block.header.payload_hash);\n        buffer.extend_from_slice(&block.header.payload_type.to_le_bytes());\n        \n        // Payload\n        let payload_bytes = block.payload.to_bytes();\n        buffer.extend_from_slice(&payload_bytes);\n        \n        // Signature (64 bytes)\n        buffer.extend_from_slice(&block.signature);\n        \n        // Public key (32 bytes)\n        buffer.extend_from_slice(&block.public_key);\n        \n        Ok(buffer)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-json-format",children:"2. JSON Format"}),"\n",(0,s.jsx)(n.p,{children:"JSON provides human-readable representation ideal for debugging, web APIs, and cross-language compatibility:"}),"\n",(0,s.jsx)(n.h4,{id:"json-structure",children:"JSON Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "header": {\n    "version": 1,\n    "index": 42,\n    "timestamp": 1640995200,\n    "previous": "a1b2c3d4e5f6789a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4",\n    "payload_hash": "e5f6789a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7",\n    "payload_type": 1001\n  },\n  "payload": "SGVsbG8gV29ybGQ=",  // Base64-encoded payload\n  "signature": "304502210098e67d...",  // Hex-encoded signature\n  "public_key": "04ab5c8f9d2e..."      // Hex-encoded public key\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"json-encoding-features",children:"JSON Encoding Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hex Encoding"}),": Binary fields (hashes, signatures, keys) as hexadecimal"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Base64 Payload"}),": Arbitrary payload data as Base64"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Schema Validation"}),": JSON Schema support for validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pretty Printing"}),": Optional formatting for readability"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Serialize, Deserialize)]\nstruct JsonBlock {\n    header: JsonHeader,\n    #[serde(with = "base64")]\n    payload: Vec<u8>,\n    #[serde(with = "hex")]\n    signature: [u8; 64],\n    #[serde(with = "hex")]\n    public_key: [u8; 32],\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-messagepack-format",children:"3. MessagePack Format"}),"\n",(0,s.jsx)(n.p,{children:"MessagePack provides efficient binary serialization while maintaining structure:"}),"\n",(0,s.jsx)(n.h4,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compact"}),": 20-50% smaller than JSON"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast"}),": No text parsing overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Preservation"}),": Maintains integer vs string distinction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Schema Evolution"}),": Better support for optional fields"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Typical size comparison for 1KB payloads\nlet json_size = 1800;      // JSON with hex encoding\nlet msgpack_size = 1200;   // MessagePack binary\nlet binary_size = 1000;    // Native binary format\n\nassert!(msgpack_size < json_size);\nassert!(binary_size < msgpack_size);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"messagepack-structure",children:"MessagePack Structure"}),"\n",(0,s.jsx)(n.p,{children:"MessagePack uses a compact binary format with type tags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Header object: {\n    "version": 1 (positive fixint),\n    "index": 42 (positive fixint),\n    "timestamp": 1640995200 (uint32),\n    "previous": [32 bytes] (bin32),\n    "payload_hash": [32 bytes] (bin32),\n    "payload_type": 1001 (uint16)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-protobuf-format",children:"4. Protobuf Format"}),"\n",(0,s.jsx)(n.p,{children:"Simplified protobuf-style encoding using length-delimited fields:"}),"\n",(0,s.jsx)(n.h4,{id:"protobuf-wire-format",children:"Protobuf Wire Format"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Field 1: Header\n  tag: 1 (varint)\n  length: header_len (varint)  \n  data: header_bytes\n\nField 2: Payload\n  tag: 2 (varint)\n  length: payload_len (varint)\n  data: payload_bytes\n\nField 3: Signature  \n  tag: 3 (varint)\n  length: 64 (varint)\n  data: signature_bytes\n\nField 4: Public Key\n  tag: 4 (varint)\n  length: 32 (varint)\n  data: pubkey_bytes\n"})}),"\n",(0,s.jsx)(n.h4,{id:"cross-language-compatibility",children:"Cross-Language Compatibility"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-proto",children:"// Protocol buffer definition\nmessage OlocusBlock {\n  BlockHeader header = 1;\n  bytes payload = 2;\n  bytes signature = 3;  // 64 bytes\n  bytes public_key = 4; // 32 bytes\n}\n\nmessage BlockHeader {\n  uint32 version = 1;\n  uint64 index = 2;\n  int64 timestamp = 3;\n  bytes previous = 4;      // 32 bytes\n  bytes payload_hash = 5;  // 32 bytes\n  uint32 payload_type = 6;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-ssz-format-simple-serialize",children:"5. SSZ Format (Simple Serialize)"}),"\n",(0,s.jsx)(n.p,{children:"SSZ provides Ethereum ecosystem compatibility with deterministic serialization:"}),"\n",(0,s.jsx)(n.h4,{id:"ssz-characteristics",children:"SSZ Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fixed-length encoding"}),": Predictable size calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Merkle tree friendly"}),": Easy hash tree computation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zero-copy deserialization"}),": Direct memory mapping possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Canonical representation"}),": Same data always produces same bytes"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"ssz-compatibility",children:"SSZ Compatibility"}),"\n",(0,s.jsx)(n.p,{children:"The Olocus binary format is SSZ-compatible by design, allowing seamless integration with Ethereum tooling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// SSZ serialization matches binary format\nlet ssz_bytes = ssz::encode(&block);\nlet binary_bytes = WireFormat::binary().encode(&block)?;\nassert_eq!(ssz_bytes, binary_bytes);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"compression-methods",children:"Compression Methods"}),"\n",(0,s.jsx)(n.h3,{id:"1-no-compression-default",children:"1. No Compression (Default)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use case"}),": Low latency applications, small payloads"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Overhead"}),": Zero compression/decompression time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Size"}),": Full data transmission"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CPU"}),": Minimal processing required"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-zstd-compression",children:"2. Zstd Compression"}),"\n",(0,s.jsx)(n.p,{children:"Facebook's Zstandard provides excellent compression ratios with good performance:"}),"\n",(0,s.jsx)(n.h4,{id:"zstd-characteristics",children:"Zstd Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression"}),": 60-80% size reduction typically"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Speed"}),": Faster than gzip, slower than LZ4"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Levels"}),": Configurable compression levels 1-22"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": Efficient memory usage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Streaming"}),": Supports streaming compression"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Zstd compression configuration\npub struct ZstdConfig {\n    /// Compression level (1-22, default: 3)\n    pub level: i32,\n    \n    /// Enable long-range matching\n    pub long_range_matching: bool,\n    \n    /// Dictionary for repeated data patterns\n    pub dictionary: Option<Vec<u8>>,\n}\n\n// Optional dependency handling\n#[cfg(feature = "compression-zstd")]\nfn compress_zstd(data: &[u8], level: i32) -> Result<Vec<u8>> {\n    zstd::bulk::compress(data, level)\n        .map_err(|e| Error::CompressionError(e.to_string()))\n}\n\n#[cfg(not(feature = "compression-zstd"))]\nfn compress_zstd(_data: &[u8], _level: i32) -> Result<Vec<u8>> {\n    Err(Error::UnsupportedCompression("zstd".to_string()))\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-lz4-compression",children:"3. LZ4 Compression"}),"\n",(0,s.jsx)(n.p,{children:"LZ4 prioritizes speed over compression ratio:"}),"\n",(0,s.jsx)(n.h4,{id:"lz4-characteristics",children:"LZ4 Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Speed"}),": Fastest compression option"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression"}),": 40-60% size reduction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latency"}),": Minimal compression delay"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": Low memory requirements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always Available"}),": No optional dependencies"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn compress_lz4(data: &[u8]) -> Result<Vec<u8>> {\n    lz4_flex::compress_prepend_size(data)\n        .map_err(|e| Error::CompressionError(e.to_string()))\n}\n\nfn decompress_lz4(compressed: &[u8]) -> Result<Vec<u8>> {\n    lz4_flex::decompress_size_prepended(compressed)\n        .map_err(|e| Error::DecompressionError(e.to_string()))\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-gzip-compression",children:"4. Gzip Compression"}),"\n",(0,s.jsx)(n.p,{children:"Standard gzip compression provides wide compatibility:"}),"\n",(0,s.jsx)(n.h4,{id:"gzip-characteristics",children:"Gzip Characteristics"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compatibility"}),": Universally supported"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compression"}),": Similar to zstd level 3"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"HTTP Compatible"}),": Standard Content-Encoding"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": More CPU intensive than LZ4/zstd"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use flate2::{write::GzEncoder, read::GzDecoder, Compression};\n\nfn compress_gzip(data: &[u8], level: u32) -> Result<Vec<u8>> {\n    let mut encoder = GzEncoder::new(Vec::new(), Compression::new(level));\n    encoder.write_all(data)?;\n    encoder.finish().map_err(|e| Error::CompressionError(e.to_string()))\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"wireformat-api",children:"WireFormat API"}),"\n",(0,s.jsx)(n.h3,{id:"core-structure",children:"Core Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug, Clone, PartialEq)]\npub struct WireFormat {\n    pub encoding: EncodingFormat,\n    pub compression: CompressionMethod,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum EncodingFormat {\n    Binary,\n    Json,\n    MessagePack,\n    Protobuf,\n    SSZ,\n}\n\n#[derive(Debug, Clone, PartialEq)]  \npub enum CompressionMethod {\n    None,\n    Zstd { level: i32 },\n    LZ4,\n    Gzip { level: u32 },\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"common-presets",children:"Common Presets"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl WireFormat {\n    /// Binary format with no compression (default)\n    pub fn binary() -> Self {\n        Self::new(EncodingFormat::Binary, CompressionMethod::None)\n    }\n    \n    /// JSON format for debugging\n    pub fn json() -> Self {\n        Self::new(EncodingFormat::Json, CompressionMethod::None)\n    }\n    \n    /// MessagePack for efficient structured data\n    pub fn msgpack() -> Self {\n        Self::new(EncodingFormat::MessagePack, CompressionMethod::None)\n    }\n    \n    /// Compressed binary for storage optimization\n    pub fn compressed_binary() -> Self {\n        Self::new(EncodingFormat::Binary, CompressionMethod::Zstd { level: 3 })\n    }\n    \n    /// Compressed JSON for web APIs\n    pub fn compressed_json() -> Self {\n        Self::new(EncodingFormat::Json, CompressionMethod::Gzip { level: 6 })\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"encodingdecoding-operations",children:"Encoding/Decoding Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl WireFormat {\n    /// Encode a block using this wire format\n    pub fn encode<T: BlockPayload>(&self, block: &Block<T>) -> Result<Vec<u8>> {\n        // 1. Serialize using encoding format\n        let serialized = match self.encoding {\n            EncodingFormat::Binary => self.encode_binary(block)?,\n            EncodingFormat::Json => self.encode_json(block)?,\n            EncodingFormat::MessagePack => self.encode_msgpack(block)?,\n            EncodingFormat::Protobuf => self.encode_protobuf(block)?,\n            EncodingFormat::SSZ => self.encode_ssz(block)?,\n        };\n        \n        // 2. Apply compression\n        let compressed = match self.compression {\n            CompressionMethod::None => serialized,\n            CompressionMethod::Zstd { level } => compress_zstd(&serialized, level)?,\n            CompressionMethod::LZ4 => compress_lz4(&serialized)?,\n            CompressionMethod::Gzip { level } => compress_gzip(&serialized, level)?,\n        };\n        \n        Ok(compressed)\n    }\n    \n    /// Decode a block from wire format\n    pub fn decode<T: BlockPayload>(&self, data: &[u8]) -> Result<Block<T>> {\n        // 1. Decompress if needed\n        let decompressed = match self.compression {\n            CompressionMethod::None => data.to_vec(),\n            CompressionMethod::Zstd { .. } => decompress_zstd(data)?,\n            CompressionMethod::LZ4 => decompress_lz4(data)?,\n            CompressionMethod::Gzip { .. } => decompress_gzip(data)?,\n        };\n        \n        // 2. Deserialize using encoding format\n        match self.encoding {\n            EncodingFormat::Binary => self.decode_binary(&decompressed),\n            EncodingFormat::Json => self.decode_json(&decompressed),\n            EncodingFormat::MessagePack => self.decode_msgpack(&decompressed),\n            EncodingFormat::Protobuf => self.decode_protobuf(&decompressed),\n            EncodingFormat::SSZ => self.decode_ssz(&decompressed),\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"content-type-negotiation",children:"Content Type Negotiation"}),"\n",(0,s.jsx)(n.h3,{id:"content-type-headers",children:"Content-Type Headers"}),"\n",(0,s.jsx)(n.p,{children:"Each wire format has an associated MIME type for HTTP-style negotiation:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Format"}),(0,s.jsx)(n.th,{children:"Base Content Type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Binary"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"application/x-olocus-block"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"application/json"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MessagePack"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"application/x-msgpack"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Protobuf"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"application/x-protobuf"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SSZ"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"application/x-ssz"})})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"compression-suffixes",children:"Compression Suffixes"}),"\n",(0,s.jsx)(n.p,{children:"Compression is indicated by appending a suffix:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zstd"}),": ",(0,s.jsx)(n.code,{children:"+zstd"})," (e.g., ",(0,s.jsx)(n.code,{children:"application/x-olocus-block+zstd"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LZ4"}),": ",(0,s.jsx)(n.code,{children:"+lz4"})," (e.g., ",(0,s.jsx)(n.code,{children:"application/json+lz4"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gzip"}),": ",(0,s.jsx)(n.code,{children:"+gzip"})," (e.g., ",(0,s.jsx)(n.code,{children:"application/x-msgpack+gzip"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"content-type-parsing",children:"Content-Type Parsing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'impl WireFormat {\n    /// Parse content type string to wire format\n    pub fn from_content_type(content_type: &str) -> Result<Self> {\n        let (mime_type, compression) = if let Some(pos) = content_type.find(\'+\') {\n            let (mime, comp) = content_type.split_at(pos);\n            (mime, &comp[1..]) // Skip the \'+\'\n        } else {\n            (content_type, "")\n        };\n        \n        let encoding = match mime_type {\n            "application/x-olocus-block" => EncodingFormat::Binary,\n            "application/json" => EncodingFormat::Json,\n            "application/x-msgpack" => EncodingFormat::MessagePack,\n            "application/x-protobuf" => EncodingFormat::Protobuf,\n            "application/x-ssz" => EncodingFormat::SSZ,\n            _ => return Err(Error::UnsupportedContentType(mime_type.to_string())),\n        };\n        \n        let compression_method = match compression {\n            "" => CompressionMethod::None,\n            "zstd" => CompressionMethod::Zstd { level: 3 },\n            "lz4" => CompressionMethod::LZ4,\n            "gzip" => CompressionMethod::Gzip { level: 6 },\n            _ => return Err(Error::UnsupportedCompression(compression.to_string())),\n        };\n        \n        Ok(WireFormat::new(encoding, compression_method))\n    }\n    \n    /// Generate content type string\n    pub fn content_type(&self) -> String {\n        let mime_type = match self.encoding {\n            EncodingFormat::Binary => "application/x-olocus-block",\n            EncodingFormat::Json => "application/json",\n            EncodingFormat::MessagePack => "application/x-msgpack",\n            EncodingFormat::Protobuf => "application/x-protobuf",\n            EncodingFormat::SSZ => "application/x-ssz",\n        };\n        \n        match self.compression {\n            CompressionMethod::None => mime_type.to_string(),\n            CompressionMethod::Zstd { .. } => format!("{}+zstd", mime_type),\n            CompressionMethod::LZ4 => format!("{}+lz4", mime_type),\n            CompressionMethod::Gzip { .. } => format!("{}+gzip", mime_type),\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"http-integration-example",children:"HTTP Integration Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// HTTP client usage\nlet format = WireFormat::from_content_type("application/json+gzip")?;\nlet encoded_block = format.encode(&block)?;\n\nlet response = client\n    .post("/api/blocks")\n    .header("Content-Type", format.content_type())\n    .body(encoded_block)\n    .send()?;\n\n// HTTP server usage  \nlet content_type = request.headers()\n    .get("content-type")\n    .and_then(|h| h.to_str().ok())\n    .unwrap_or("application/x-olocus-block");\n    \nlet format = WireFormat::from_content_type(content_type)?;\nlet block: Block<MyPayload> = format.decode(request.body())?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsx)(n.h3,{id:"benchmark-results",children:"Benchmark Results"}),"\n",(0,s.jsx)(n.p,{children:"Typical performance on modern hardware with 1KB payloads:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Format + Compression"}),(0,s.jsx)(n.th,{children:"Encode (ops/sec)"}),(0,s.jsx)(n.th,{children:"Decode (ops/sec)"}),(0,s.jsx)(n.th,{children:"Size (bytes)"}),(0,s.jsx)(n.th,{children:"Use Case"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Binary + None"}),(0,s.jsx)(n.td,{children:"50,000"}),(0,s.jsx)(n.td,{children:"60,000"}),(0,s.jsx)(n.td,{children:"1,200"}),(0,s.jsx)(n.td,{children:"High-performance"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Binary + LZ4"}),(0,s.jsx)(n.td,{children:"45,000"}),(0,s.jsx)(n.td,{children:"55,000"}),(0,s.jsx)(n.td,{children:"800"}),(0,s.jsx)(n.td,{children:"Balanced"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Binary + Zstd"}),(0,s.jsx)(n.td,{children:"35,000"}),(0,s.jsx)(n.td,{children:"40,000"}),(0,s.jsx)(n.td,{children:"600"}),(0,s.jsx)(n.td,{children:"Storage"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON + None"}),(0,s.jsx)(n.td,{children:"15,000"}),(0,s.jsx)(n.td,{children:"12,000"}),(0,s.jsx)(n.td,{children:"1,800"}),(0,s.jsx)(n.td,{children:"Debugging"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON + Gzip"}),(0,s.jsx)(n.td,{children:"12,000"}),(0,s.jsx)(n.td,{children:"10,000"}),(0,s.jsx)(n.td,{children:"900"}),(0,s.jsx)(n.td,{children:"Web APIs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"MessagePack + LZ4"}),(0,s.jsx)(n.td,{children:"25,000"}),(0,s.jsx)(n.td,{children:"30,000"}),(0,s.jsx)(n.td,{children:"700"}),(0,s.jsx)(n.td,{children:"Structured data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Protobuf + None"}),(0,s.jsx)(n.td,{children:"20,000"}),(0,s.jsx)(n.td,{children:"25,000"}),(0,s.jsx)(n.td,{children:"1,100"}),(0,s.jsx)(n.td,{children:"Cross-platform"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SSZ + None"}),(0,s.jsx)(n.td,{children:"48,000"}),(0,s.jsx)(n.td,{children:"58,000"}),(0,s.jsx)(n.td,{children:"1,200"}),(0,s.jsx)(n.td,{children:"Ethereum ecosystem"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"performance-factors",children:"Performance Factors"}),"\n",(0,s.jsx)(n.h4,{id:"encoding-performance",children:"Encoding Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Binary/SSZ"}),": Direct memory serialization (fastest)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MessagePack"}),": Efficient binary format"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Protobuf"}),": Length-delimited with varint overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JSON"}),": Text parsing overhead (slowest)"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"compression-performance",children:"Compression Performance"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LZ4"}),": Fastest compression/decompression"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zstd"}),": Best compression ratio with good speed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gzip"}),": Balanced but CPU-intensive"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"None"}),": Zero overhead"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Memory-efficient streaming for large payloads\npub struct StreamingEncoder {\n    format: WireFormat,\n    buffer_size: usize,\n}\n\nimpl StreamingEncoder {\n    pub fn encode_stream<T: BlockPayload>(\n        &self, \n        block: &Block<T>, \n        writer: impl Write\n    ) -> Result<()> {\n        // Stream encoding to avoid loading entire payload in memory\n        match self.format.compression {\n            CompressionMethod::None => self.encode_direct(block, writer),\n            CompressionMethod::LZ4 => self.encode_lz4_stream(block, writer),\n            CompressionMethod::Zstd { level } => self.encode_zstd_stream(block, writer, level),\n            CompressionMethod::Gzip { level } => self.encode_gzip_stream(block, writer, level),\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"format-selection-guidelines",children:"Format Selection Guidelines"}),"\n",(0,s.jsx)(n.h3,{id:"decision-matrix",children:"Decision Matrix"}),"\n",(0,s.jsx)(n.p,{children:"Choose the optimal format based on your requirements:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Priority"}),(0,s.jsx)(n.th,{children:"Recommended Format"}),(0,s.jsx)(n.th,{children:"Rationale"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Speed"})}),(0,s.jsx)(n.td,{children:"Binary + None"}),(0,s.jsx)(n.td,{children:"Zero serialization overhead"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Size"})}),(0,s.jsx)(n.td,{children:"Binary + Zstd"}),(0,s.jsx)(n.td,{children:"Maximum compression efficiency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Debug"})}),(0,s.jsx)(n.td,{children:"JSON + None"}),(0,s.jsx)(n.td,{children:"Human-readable format"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Web"})}),(0,s.jsx)(n.td,{children:"JSON + Gzip"}),(0,s.jsx)(n.td,{children:"HTTP-compatible compression"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Cross-platform"})}),(0,s.jsx)(n.td,{children:"MessagePack + LZ4"}),(0,s.jsx)(n.td,{children:"Efficient structured data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Ethereum"})}),(0,s.jsx)(n.td,{children:"SSZ + None"}),(0,s.jsx)(n.td,{children:"Ecosystem compatibility"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Mobile"})}),(0,s.jsx)(n.td,{children:"Binary + LZ4"}),(0,s.jsx)(n.td,{children:"Fast with reasonable compression"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IoT"})}),(0,s.jsx)(n.td,{children:"Binary + None"}),(0,s.jsx)(n.td,{children:"Minimal processing overhead"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"use-case-examples",children:"Use Case Examples"}),"\n",(0,s.jsx)(n.h4,{id:"high-frequency-trading",children:"High-Frequency Trading"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Prioritize speed over size\nlet format = WireFormat::binary(); // No compression overhead\nlet encoded = format.encode(&trade_block)?;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"archival-storage",children:"Archival Storage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Prioritize size over speed\nlet format = WireFormat::new(\n    EncodingFormat::Binary, \n    CompressionMethod::Zstd { level: 19 }\n);\nlet compressed = format.encode(&historical_block)?;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"web-api",children:"Web API"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Balance readability and efficiency\nlet format = WireFormat::new(\n    EncodingFormat::Json,\n    CompressionMethod::Gzip { level: 6 }\n);\nlet response_body = format.encode(&block)?;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"iot-sensor-network",children:"IoT Sensor Network"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Minimize CPU and battery usage\nlet format = WireFormat::binary(); // No compression processing\nlet sensor_data = format.encode(&sensor_block)?;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"version-compatibility",children:"Version Compatibility"}),"\n",(0,s.jsx)(n.h3,{id:"format-evolution",children:"Format Evolution"}),"\n",(0,s.jsx)(n.p,{children:"Wire formats maintain backward compatibility through versioning:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct FormatVersion {\n    /// Format version identifier\n    pub version: u16,\n    \n    /// Supported encoding formats\n    pub encodings: Vec<EncodingFormat>,\n    \n    /// Supported compression methods  \n    pub compressions: Vec<CompressionMethod>,\n    \n    /// Compatibility rules\n    pub compatibility: CompatibilityRules,\n}\n\n/// Version 1.0 format support\npub const FORMAT_V1: FormatVersion = FormatVersion {\n    version: 1,\n    encodings: vec![\n        EncodingFormat::Binary,\n        EncodingFormat::Json,\n        EncodingFormat::MessagePack,\n    ],\n    compressions: vec![\n        CompressionMethod::None,\n        CompressionMethod::LZ4,\n        CompressionMethod::Gzip { level: 6 },\n    ],\n    compatibility: CompatibilityRules::default(),\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"migration-support",children:"Migration Support"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct FormatMigration {\n    /// Convert from old format to new format\n    pub fn migrate(\n        &self,\n        data: &[u8],\n        from_format: WireFormat,\n        to_format: WireFormat,\n    ) -> Result<Vec<u8>> {\n        // 1. Decode using old format\n        let block: Block<GenericPayload> = from_format.decode(data)?;\n        \n        // 2. Apply any necessary transformations\n        let migrated_block = self.transform_block(block)?;\n        \n        // 3. Encode using new format\n        to_format.encode(&migrated_block)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"feature-detection",children:"Feature Detection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Detect supported formats from peer\npub fn negotiate_format(\n    our_formats: &[WireFormat],\n    peer_formats: &[WireFormat],\n) -> Option<WireFormat> {\n    // Find common formats, prioritize by efficiency\n    for our_format in our_formats {\n        if peer_formats.contains(our_format) {\n            return Some(our_format.clone());\n        }\n    }\n    None\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"wire-format-errors",children:"Wire Format Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum WireFormatError {\n    #[error("Unsupported encoding format: {0}")]\n    UnsupportedEncoding(String),\n    \n    #[error("Unsupported compression method: {0}")]\n    UnsupportedCompression(String),\n    \n    #[error("Invalid content type: {0}")]\n    InvalidContentType(String),\n    \n    #[error("Serialization error: {0}")]\n    SerializationError(String),\n    \n    #[error("Compression error: {0}")]\n    CompressionError(String),\n    \n    #[error("Malformed data: {0}")]\n    MalformedData(String),\n    \n    #[error("Version incompatibility: expected {expected}, got {actual}")]\n    VersionMismatch { expected: u16, actual: u16 },\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"graceful-degradation",children:"Graceful Degradation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'pub struct FormatFallback {\n    /// Preferred formats in order of preference\n    pub preferences: Vec<WireFormat>,\n    \n    /// Minimum acceptable format\n    pub minimum: WireFormat,\n}\n\nimpl FormatFallback {\n    pub fn try_encode<T: BlockPayload>(&self, block: &Block<T>) -> Result<Vec<u8>> {\n        for format in &self.preferences {\n            match format.encode(block) {\n                Ok(encoded) => return Ok(encoded),\n                Err(e) => {\n                    log::warn!("Format {:?} failed: {}", format, e);\n                    continue;\n                }\n            }\n        }\n        \n        // Fall back to minimum format\n        self.minimum.encode(block)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The wire format system provides a robust foundation for data serialization in the Olocus Protocol, balancing efficiency, flexibility, and compatibility across diverse application requirements."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>a});var i=r(6540);const s={},o=i.createContext(s);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);