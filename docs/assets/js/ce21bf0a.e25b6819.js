"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[7925],{4709:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/downgrade-protection","title":"Downgrade Protection","description":"Downgrade protection is a critical security feature in Olocus Protocol that prevents attackers from forcing the use of weaker cryptographic algorithms or older protocol versions. The protocol implements seven complementary layers of protection to defend against sophisticated downgrade attacks.","source":"@site/docs/concepts/downgrade-protection.md","sourceDirName":"concepts","slug":"/concepts/downgrade-protection","permalink":"/docs/concepts/downgrade-protection","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/downgrade-protection.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"downgrade-protection","title":"Downgrade Protection","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Algorithm Negotiation","permalink":"/docs/concepts/algorithm-negotiation"},"next":{"title":"Protocol Specification","permalink":"/docs/architecture/protocol-specification"}}');var t=r(4848),s=r(8453);const o={id:"downgrade-protection",title:"Downgrade Protection",sidebar_position:1},l="Downgrade Protection",a={},c=[{value:"What Are Downgrade Attacks?",id:"what-are-downgrade-attacks",level:2},{value:"The Seven Layers of Protection",id:"the-seven-layers-of-protection",level:2},{value:"Layer 1: Protocol Version Checking",id:"layer-1-protocol-version-checking",level:3},{value:"Layer 2: Signed Algorithm Preferences",id:"layer-2-signed-algorithm-preferences",level:3},{value:"Layer 3: Strict Preference Ordering",id:"layer-3-strict-preference-ordering",level:3},{value:"Layer 4: Negotiation Commitment",id:"layer-4-negotiation-commitment",level:3},{value:"Layer 5: Minimum Security Requirements",id:"layer-5-minimum-security-requirements",level:3},{value:"Layer 6: Forbidden Algorithm Lists",id:"layer-6-forbidden-algorithm-lists",level:3},{value:"Layer 7: Handshake Transcript Binding",id:"layer-7-handshake-transcript-binding",level:3},{value:"Attack Scenarios and Defenses",id:"attack-scenarios-and-defenses",level:2},{value:"Scenario 1: Algorithm Substitution Attack",id:"scenario-1-algorithm-substitution-attack",level:3},{value:"Scenario 2: Protocol Version Rollback",id:"scenario-2-protocol-version-rollback",level:3},{value:"Scenario 3: Selective Algorithm Hiding",id:"scenario-3-selective-algorithm-hiding",level:3},{value:"Scenario 4: Replay Attack",id:"scenario-4-replay-attack",level:3},{value:"Scenario 5: Policy Bypass",id:"scenario-5-policy-bypass",level:3},{value:"Implementation Guidelines",id:"implementation-guidelines",level:2},{value:"Proper Configuration",id:"proper-configuration",level:3},{value:"Validation Process",id:"validation-process",level:3},{value:"Monitoring and Alerting",id:"monitoring-and-alerting",level:3},{value:"Testing Downgrade Protection",id:"testing-downgrade-protection",level:2},{value:"Attack Simulation",id:"attack-simulation",level:3},{value:"Penetration Testing",id:"penetration-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"For Developers",id:"for-developers",level:3},{value:"For Administrators",id:"for-administrators",level:3},{value:"For Security Teams",id:"for-security-teams",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"downgrade-protection",children:"Downgrade Protection"})}),"\n",(0,t.jsx)(n.p,{children:"Downgrade protection is a critical security feature in Olocus Protocol that prevents attackers from forcing the use of weaker cryptographic algorithms or older protocol versions. The protocol implements seven complementary layers of protection to defend against sophisticated downgrade attacks."}),"\n",(0,t.jsx)(n.h2,{id:"what-are-downgrade-attacks",children:"What Are Downgrade Attacks?"}),"\n",(0,t.jsx)(n.p,{children:"A downgrade attack occurs when an adversary manipulates the algorithm negotiation process to force peers to use weaker cryptographic algorithms than they would normally choose. This can happen through:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Man-in-the-middle attacks"}),": Intercepting and modifying negotiation messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Active network attackers"}),": Selectively dropping messages for stronger algorithms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Protocol manipulation"}),": Exploiting weaknesses in negotiation logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay attacks"}),": Re-using old negotiation messages with weaker algorithms"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"the-seven-layers-of-protection",children:"The Seven Layers of Protection"}),"\n",(0,t.jsx)(n.p,{children:"Olocus Protocol implements a defense-in-depth approach with seven independent protection mechanisms:"}),"\n",(0,t.jsx)(n.h3,{id:"layer-1-protocol-version-checking",children:"Layer 1: Protocol Version Checking"}),"\n",(0,t.jsx)(n.p,{children:"The first line of defense enforces minimum protocol version requirements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct AlgorithmPreferences {\n    pub protocol_version: u16,        // Current version\n    pub min_protocol_version: u16,    // Minimum acceptable\n    pub max_protocol_version: u16,    // Maximum supported\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each peer specifies minimum acceptable protocol version"}),"\n",(0,t.jsx)(n.li,{children:"Connections are rejected if peer version is too old"}),"\n",(0,t.jsx)(n.li,{children:"Prevents rollback to vulnerable protocol versions"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"if peer_preferences.protocol_version < our_min_protocol_version {\n    return Err(Error::ProtocolVersionTooOld);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"layer-2-signed-algorithm-preferences",children:"Layer 2: Signed Algorithm Preferences"}),"\n",(0,t.jsx)(n.p,{children:"Algorithm preferences are cryptographically signed to detect tampering:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct SignedAlgorithmPreferences {\n    pub preferences: AlgorithmPreferences,\n    pub signature: Vec<u8>,          // Ed25519 signature\n    pub signer_key: Vec<u8>,         // Public key\n    pub timestamp: i64,              // When signed\n    pub nonce: Vec<u8>,              // Replay protection\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Preferences are signed with Ed25519 before transmission"}),"\n",(0,t.jsx)(n.li,{children:"Recipients verify signatures before processing"}),"\n",(0,t.jsx)(n.li,{children:"Tampered preferences are rejected immediately"}),"\n",(0,t.jsx)(n.li,{children:"Prevents modification of algorithm lists in transit"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Security Properties:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integrity"}),": Signatures detect any modification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Authenticity"}),": Signatures prove the sender's identity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-repudiation"}),": Signers cannot deny their preferences"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"layer-3-strict-preference-ordering",children:"Layer 3: Strict Preference Ordering"}),"\n",(0,t.jsx)(n.p,{children:"The initiator's algorithm preference order is authoritative:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Initiator's preferences take precedence\nlet selected_algorithm = find_best_common_algorithm(\n    &initiator_preferences.signature_algorithms,  // Order matters\n    &responder_preferences.signature_algorithms   // Support check only\n)?;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initiator ranks algorithms in order of preference (strongest first)"}),"\n",(0,t.jsx)(n.li,{children:"Selection chooses first algorithm in initiator's list that responder supports"}),"\n",(0,t.jsx)(n.li,{children:"Prevents responder from forcing a weaker algorithm"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example Scenario:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Initiator prefers: ",(0,t.jsx)(n.code,{children:"[Dilithium3, Ed25519, Ed448]"})]}),"\n",(0,t.jsxs)(n.li,{children:["Responder supports: ",(0,t.jsx)(n.code,{children:"[Ed448, Ed25519]"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Selected"}),": ",(0,t.jsx)(n.code,{children:"Ed25519"})," (first in initiator's list that responder supports)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"NOT"}),": ",(0,t.jsx)(n.code,{children:"Ed448"})," (would be responder manipulation)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"layer-4-negotiation-commitment",children:"Layer 4: Negotiation Commitment"}),"\n",(0,t.jsx)(n.p,{children:"All offered algorithms are cryptographically committed in a transcript:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct NegotiationTranscript {\n    pub initiator_offered: Vec<AlgorithmId>,    // All algorithms offered\n    pub responder_offered: Vec<AlgorithmId>,    \n    pub selected_algorithms: SelectedAlgorithms,\n    pub commitment_hash: [u8; 32],              // SHA-256 of above\n    pub timestamp: i64,\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Complete algorithm lists are hashed and committed"}),"\n",(0,t.jsx)(n.li,{children:"Transcript must be included in subsequent handshake messages"}),"\n",(0,t.jsx)(n.li,{children:"Prevents selective algorithm hiding or modification"}),"\n",(0,t.jsx)(n.li,{children:"Creates auditable record of what was offered"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Commitment Process:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Hash all offered algorithms from both parties"}),"\n",(0,t.jsx)(n.li,{children:"Include selected algorithms and timestamp"}),"\n",(0,t.jsx)(n.li,{children:"Store commitment hash for handshake verification"}),"\n",(0,t.jsx)(n.li,{children:"Reject handshakes that don't include matching transcript"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"layer-5-minimum-security-requirements",children:"Layer 5: Minimum Security Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Security policies enforce baseline algorithm strength:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct SecurityRequirements {\n    pub min_security_level: SecurityLevel,      // e.g., Level128\n    pub require_post_quantum: bool,\n    pub forbidden_algorithms: HashSet<AlgorithmId>,\n    pub required_algorithms: Vec<AlgorithmId>,\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Algorithms below minimum security level are automatically rejected"}),"\n",(0,t.jsx)(n.li,{children:"Organizations can mandate post-quantum algorithms"}),"\n",(0,t.jsx)(n.li,{children:"Known-broken algorithms are explicitly forbidden"}),"\n",(0,t.jsx)(n.li,{children:"Critical algorithms can be marked as required"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example Policy:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let policy = SecurityRequirements {\n    min_security_level: SecurityLevel::Level128,\n    require_post_quantum: false,\n    forbidden_algorithms: [\n        AlgorithmId::Md5,     // Cryptographically broken\n        AlgorithmId::Sha1,    // Collision attacks exist\n    ].into(),\n    required_algorithms: vec![\n        AlgorithmId::Ed25519, // Must support Ed25519\n    ],\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"layer-6-forbidden-algorithm-lists",children:"Layer 6: Forbidden Algorithm Lists"}),"\n",(0,t.jsx)(n.p,{children:"Explicitly blocked algorithms cannot be negotiated:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"impl AlgorithmStatus {\n    Broken,                    // MUST NOT use\n    Deprecated,               // SHOULD NOT use\n    Deprecating { sunset_date }, // WARNING: will be deprecated\n    Acceptable,               // OK to use\n    Recommended,              // Preferred choice\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Algorithms marked as ",(0,t.jsx)(n.code,{children:"Broken"})," are automatically rejected"]}),"\n",(0,t.jsx)(n.li,{children:"Deprecated algorithms require explicit policy override"}),"\n",(0,t.jsx)(n.li,{children:"Deprecating algorithms trigger warnings"}),"\n",(0,t.jsx)(n.li,{children:"Dynamic algorithm status based on security research"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Automatic Blocking:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"if algorithm_metadata.status == AlgorithmStatus::Broken {\n    return Err(Error::ForbiddenAlgorithm(algorithm));\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"layer-7-handshake-transcript-binding",children:"Layer 7: Handshake Transcript Binding"}),"\n",(0,t.jsx)(n.p,{children:"The negotiation transcript MUST be included in the cryptographic handshake:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct HandshakeMessage {\n    // ... other fields\n    pub negotiation_transcript: NegotiationTranscript,\n    pub transcript_signature: Signature,\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Protection Mechanism:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Negotiation transcript is cryptographically bound to handshake"}),"\n",(0,t.jsx)(n.li,{children:"Any modification to the negotiation invalidates the handshake"}),"\n",(0,t.jsx)(n.li,{children:"Provides end-to-end integrity for the entire negotiation process"}),"\n",(0,t.jsx)(n.li,{children:"Creates immutable audit trail"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Verification Process:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Extract transcript from handshake message"}),"\n",(0,t.jsx)(n.li,{children:"Verify transcript hash matches negotiated algorithms"}),"\n",(0,t.jsx)(n.li,{children:"Confirm transcript signature is valid"}),"\n",(0,t.jsx)(n.li,{children:"Reject handshake if transcript doesn't match negotiation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"attack-scenarios-and-defenses",children:"Attack Scenarios and Defenses"}),"\n",(0,t.jsx)(n.h3,{id:"scenario-1-algorithm-substitution-attack",children:"Scenario 1: Algorithm Substitution Attack"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attack:"})," Attacker modifies algorithm preferences in transit to force weaker algorithms."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Defense:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 2"}),": Signature verification detects modification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 4"}),": Negotiation commitment prevents substitution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 7"}),": Handshake binding ensures end-to-end integrity"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"scenario-2-protocol-version-rollback",children:"Scenario 2: Protocol Version Rollback"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attack:"})," Attacker forces use of older protocol version with known vulnerabilities."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Defense:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 1"}),": Minimum version requirements reject old protocols"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 5"}),": Security policies enforce version minimums"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"scenario-3-selective-algorithm-hiding",children:"Scenario 3: Selective Algorithm Hiding"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attack:"})," Attacker selectively blocks stronger algorithms to force weaker choices."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Defense:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 3"}),": Strict ordering prevents manipulation of preference lists"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 4"}),": Commitment includes all offered algorithms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 6"}),": Forbidden lists block known-weak algorithms"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"scenario-4-replay-attack",children:"Scenario 4: Replay Attack"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attack:"})," Attacker replays old negotiation with deprecated algorithms."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Defense:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 2"}),": Timestamp and nonce prevent replay"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 6"}),": Algorithm status blocking prevents deprecated algorithms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 7"}),": Fresh handshake transcript required"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"scenario-5-policy-bypass",children:"Scenario 5: Policy Bypass"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Attack:"})," Attacker tries to bypass organizational security policies."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Defense:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 5"}),": Minimum security requirements are enforced client-side"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Layer 6"}),": Forbidden algorithm lists cannot be overridden"]}),"\n",(0,t.jsx)(n.li,{children:"Local policy enforcement prevents bypass"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-guidelines",children:"Implementation Guidelines"}),"\n",(0,t.jsx)(n.h3,{id:"proper-configuration",children:"Proper Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Example secure configuration\nlet preferences = AlgorithmPreferences {\n    // Strong algorithms first\n    signature_algorithms: vec![\n        AlgorithmId::Dilithium3,    // Post-quantum\n        AlgorithmId::Ed25519,       // Classical strong\n    ],\n    \n    // Set conservative minimums\n    min_security_level: SecurityLevel::Level128,\n    allow_deprecated: false,\n    \n    // Prevent version rollback\n    protocol_version: 2,\n    min_protocol_version: 2,\n    max_protocol_version: 3,\n};\n\n// Strong security requirements\nlet requirements = SecurityRequirements {\n    min_security_level: SecurityLevel::Level128,\n    require_post_quantum: false,  // Set true when ready\n    forbidden_algorithms: [\n        AlgorithmId::Md5,\n        AlgorithmId::Sha1,\n        AlgorithmId::Rsa1024,      // Too weak\n    ].into(),\n    required_algorithms: vec![\n        AlgorithmId::Ed25519,      // Must support\n    ],\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"validation-process",children:"Validation Process"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"fn validate_negotiation(\n    initiator_prefs: &SignedAlgorithmPreferences,\n    responder_prefs: &SignedAlgorithmPreferences,\n    requirements: &SecurityRequirements,\n) -> Result<()> {\n    // Layer 1: Check protocol versions\n    if initiator_prefs.preferences.protocol_version < requirements.min_protocol_version {\n        return Err(Error::ProtocolVersionTooOld);\n    }\n    \n    // Layer 2: Verify signatures\n    verify_preferences_signature(initiator_prefs)?;\n    verify_preferences_signature(responder_prefs)?;\n    \n    // Layer 3: Use initiator's ordering (automatic in selection)\n    \n    // Layer 4: Generate commitment transcript\n    let transcript = generate_negotiation_transcript(initiator_prefs, responder_prefs)?;\n    \n    // Layer 5: Apply security requirements\n    validate_security_requirements(&transcript.selected_algorithms, requirements)?;\n    \n    // Layer 6: Check forbidden algorithms\n    validate_forbidden_algorithms(&transcript.selected_algorithms, requirements)?;\n    \n    // Layer 7: Store transcript for handshake binding\n    store_transcript_for_handshake(transcript)?;\n    \n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"monitoring-and-alerting",children:"Monitoring and Alerting"}),"\n",(0,t.jsx)(n.p,{children:"Organizations should monitor for downgrade attempts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Log all negotiation attempts\nfn log_negotiation_attempt(\n    peer_id: &PeerId,\n    offered_algorithms: &[AlgorithmId],\n    selected_algorithms: &SelectedAlgorithms,\n) {\n    info!("Negotiation with {}: offered={:?}, selected={:?}", \n          peer_id, offered_algorithms, selected_algorithms);\n    \n    // Alert on suspicious patterns\n    if contains_deprecated_algorithms(offered_algorithms) {\n        warn!("Peer {} offered deprecated algorithms: {:?}", \n              peer_id, deprecated_algorithms);\n    }\n    \n    if security_level(&selected_algorithms) < SecurityLevel::Level128 {\n        error!("Negotiation resulted in weak algorithms: {:?}", \n               selected_algorithms);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"testing-downgrade-protection",children:"Testing Downgrade Protection"}),"\n",(0,t.jsx)(n.h3,{id:"attack-simulation",children:"Attack Simulation"}),"\n",(0,t.jsx)(n.p,{children:"The protocol includes comprehensive tests simulating various attack scenarios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[test]\nfn test_algorithm_substitution_attack() {\n    let mut preferences = create_test_preferences();\n    \n    // Simulate attacker modifying preferences\n    preferences.signature_algorithms = vec![AlgorithmId::WeakAlgorithm];\n    \n    // Should be detected by signature verification\n    let result = negotiate_algorithms(&preferences, &responder_prefs, &requirements);\n    assert_eq!(result.unwrap_err(), Error::InvalidSignature);\n}\n\n#[test]\nfn test_version_rollback_attack() {\n    let mut preferences = create_test_preferences();\n    preferences.protocol_version = 1;  // Try to force old version\n    \n    let result = negotiate_algorithms(&preferences, &responder_prefs, &requirements);\n    assert_eq!(result.unwrap_err(), Error::ProtocolVersionTooOld);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"penetration-testing",children:"Penetration Testing"}),"\n",(0,t.jsx)(n.p,{children:"Regular security testing should include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Protocol fuzzing"}),": Test with malformed negotiation messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Man-in-the-middle simulation"}),": Verify protection against active attackers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Policy bypass attempts"}),": Ensure security requirements are enforced"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timing attacks"}),": Verify constant-time negotiation processing"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"for-developers",children:"For Developers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Always verify signatures"})," before processing preferences"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use strong default preferences"})," with post-quantum algorithms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set conservative minimums"})," for security levels and protocol versions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Log all negotiations"})," for security monitoring"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test downgrade scenarios"})," regularly"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-administrators",children:"For Administrators"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Define organizational policies"})," with appropriate security requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor negotiation patterns"})," for suspicious activity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep algorithm status updated"})," based on current security research"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plan post-quantum migration"})," with hybrid algorithm support"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Regular security audits"})," of negotiation configurations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-security-teams",children:"For Security Teams"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Review algorithm metadata"})," regularly for new vulnerabilities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Update forbidden lists"})," as algorithms are broken"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor for policy violations"})," in production systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test downgrade resistance"})," as part of security assessments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plan incident response"})," for cryptographic vulnerabilities"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,t.jsx)(n.p,{children:"The downgrade protection system is designed for evolution:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic algorithm updates"}),": Real-time updates to algorithm status"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero-knowledge proofs"}),": Prove negotiation integrity without revealing preferences"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Formal verification"}),": Mathematical proofs of downgrade resistance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Machine learning detection"}),": AI-powered detection of unusual negotiation patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Quantum-safe commitment schemes"}),": Post-quantum secure transcript binding"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);