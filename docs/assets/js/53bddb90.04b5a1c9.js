"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[4528],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},9845:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"extensions/security/post-quantum","title":"Post-Quantum Cryptography","description":"The PQC extension provides post-quantum cryptographic algorithms and migration strategies to protect against quantum computing threats while maintaining interoperability with classical systems.","source":"@site/docs/extensions/security/post-quantum.md","sourceDirName":"extensions/security","slug":"/extensions/security/post-quantum","permalink":"/docs/extensions/security/post-quantum","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/security/post-quantum.md","tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":5,"frontMatter":{"id":"post-quantum","title":"Post-Quantum Cryptography","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Keystore Management","permalink":"/docs/extensions/security/keystore"},"next":{"title":"Techniques","permalink":"/docs/extensions/privacy/techniques"}}');var a=i(4848),r=i(8453);const s={id:"post-quantum",title:"Post-Quantum Cryptography",sidebar_position:5},l="Post-Quantum Cryptography",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Dilithium Digital Signatures",id:"dilithium-digital-signatures",level:2},{value:"Dilithium Implementation",id:"dilithium-implementation",level:3},{value:"FALCON Signatures",id:"falcon-signatures",level:3},{value:"ML-KEM Key Encapsulation",id:"ml-kem-key-encapsulation",level:2},{value:"ML-KEM Implementation",id:"ml-kem-implementation",level:3},{value:"Hybrid Cryptography",id:"hybrid-cryptography",level:2},{value:"Hybrid Signatures",id:"hybrid-signatures",level:3},{value:"Hybrid Key Exchange",id:"hybrid-key-exchange",level:3},{value:"Migration Strategies",id:"migration-strategies",level:2},{value:"Gradual Migration Framework",id:"gradual-migration-framework",level:3},{value:"Algorithm Negotiation",id:"algorithm-negotiation",level:2},{value:"Capability-Based Negotiation",id:"capability-based-negotiation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Performance Benchmarking",id:"performance-benchmarking",level:3},{value:"Testing &amp; Integration",id:"testing--integration",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"post-quantum-cryptography",children:"Post-Quantum Cryptography"})}),"\n",(0,a.jsx)(n.p,{children:"The PQC extension provides post-quantum cryptographic algorithms and migration strategies to protect against quantum computing threats while maintaining interoperability with classical systems."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"The Post-Quantum Cryptography extension implements NIST-standardized algorithms and provides comprehensive migration support:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Signatures"}),": Dilithium (lattice-based), FALCON (lattice-based)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Key Exchange"}),": ML-KEM/Kyber (lattice-based)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Hybrid Modes"}),": Classical + PQC combinations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Migration"}),": Gradual transition strategies"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Agility"}),": Algorithm negotiation and flexibility"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Optimized implementations and benchmarking"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::*;\n\n// Configure post-quantum cryptography\nlet pqc_config = PQCConfig {\n    mode: PQCMode::Hybrid {\n        classical: ClassicalAlgorithm::Ed25519,\n        post_quantum: PQAlgorithm::Dilithium3,\n        signature_format: HybridFormat::Concatenated,\n    },\n    migration_policy: MigrationPolicy {\n        phase: MigrationPhase::HybridTransition,\n        fallback_to_classical: true,\n        require_pq_support: false,\n    },\n    performance_profile: PerformanceProfile::Balanced,\n};\n\nlet pqc_manager = PQCManager::new(pqc_config)?;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"dilithium-digital-signatures",children:"Dilithium Digital Signatures"}),"\n",(0,a.jsx)(n.p,{children:"Dilithium is NIST's primary post-quantum digital signature standard (FIPS 204):"}),"\n",(0,a.jsx)(n.h3,{id:"dilithium-implementation",children:"Dilithium Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::signature::dilithium::*;\nuse crystal_dilithium::{Dilithium3, Keypair, Signature};\n\npub struct DilithiumSigner {\n    variant: DilithiumVariant,\n    keypair: Option<DilithiumKeypair>,\n}\n\n#[derive(Debug, Clone)]\npub enum DilithiumVariant {\n    Dilithium2,  // ~128-bit security, smaller keys/signatures\n    Dilithium3,  // ~192-bit security, recommended for most uses\n    Dilithium5,  // ~256-bit security, maximum security\n}\n\n#[derive(Debug, Clone)]\npub struct DilithiumKeypair {\n    pub public_key: Vec<u8>,     // 1312 bytes (Dilithium3)\n    pub private_key: Vec<u8>,    // 2560 bytes (Dilithium3)\n    pub variant: DilithiumVariant,\n}\n\nimpl PQSignatureAlgorithm for DilithiumSigner {\n    type Keypair = DilithiumKeypair;\n    type Signature = DilithiumSignature;\n    \n    fn generate_keypair(&mut self, variant: DilithiumVariant) -> Result<DilithiumKeypair> {\n        let keypair = match variant {\n            DilithiumVariant::Dilithium2 => {\n                let (public, private) = crystal_dilithium::dilithium2::keypair();\n                DilithiumKeypair {\n                    public_key: public.as_bytes().to_vec(),\n                    private_key: private.as_bytes().to_vec(),\n                    variant,\n                }\n            },\n            DilithiumVariant::Dilithium3 => {\n                let (public, private) = crystal_dilithium::dilithium3::keypair();\n                DilithiumKeypair {\n                    public_key: public.as_bytes().to_vec(),\n                    private_key: private.as_bytes().to_vec(),\n                    variant,\n                }\n            },\n            DilithiumVariant::Dilithium5 => {\n                let (public, private) = crystal_dilithium::dilithium5::keypair();\n                DilithiumKeypair {\n                    public_key: public.as_bytes().to_vec(),\n                    private_key: private.as_bytes().to_vec(),\n                    variant,\n                }\n            }\n        };\n        \n        self.keypair = Some(keypair.clone());\n        Ok(keypair)\n    }\n    \n    fn sign(&self, message: &[u8]) -> Result<DilithiumSignature> {\n        let keypair = self.keypair.as_ref()\n            .ok_or(PQCError::NoKeypairGenerated)?;\n            \n        let signature_bytes = match keypair.variant {\n            DilithiumVariant::Dilithium2 => {\n                let private_key = crystal_dilithium::dilithium2::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let signature = crystal_dilithium::dilithium2::sign(message, &private_key);\n                signature.as_bytes().to_vec()\n            },\n            DilithiumVariant::Dilithium3 => {\n                let private_key = crystal_dilithium::dilithium3::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let signature = crystal_dilithium::dilithium3::sign(message, &private_key);\n                signature.as_bytes().to_vec()\n            },\n            DilithiumVariant::Dilithium5 => {\n                let private_key = crystal_dilithium::dilithium5::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let signature = crystal_dilithium::dilithium5::sign(message, &private_key);\n                signature.as_bytes().to_vec()\n            }\n        };\n        \n        Ok(DilithiumSignature {\n            signature: signature_bytes,\n            variant: keypair.variant.clone(),\n            algorithm_id: AlgorithmId::Dilithium(keypair.variant.clone()),\n        })\n    }\n    \n    fn verify(&self, message: &[u8], signature: &DilithiumSignature, public_key: &[u8]) -> Result<bool> {\n        match signature.variant {\n            DilithiumVariant::Dilithium2 => {\n                let pk = crystal_dilithium::dilithium2::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let sig = crystal_dilithium::dilithium2::Signature::from_bytes(&signature.signature)\n                    .map_err(|e| PQCError::InvalidSignature(e.to_string()))?;\n                    \n                Ok(crystal_dilithium::dilithium2::verify(message, &sig, &pk))\n            },\n            DilithiumVariant::Dilithium3 => {\n                let pk = crystal_dilithium::dilithium3::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let sig = crystal_dilithium::dilithium3::Signature::from_bytes(&signature.signature)\n                    .map_err(|e| PQCError::InvalidSignature(e.to_string()))?;\n                    \n                Ok(crystal_dilithium::dilithium3::verify(message, &sig, &pk))\n            },\n            DilithiumVariant::Dilithium5 => {\n                let pk = crystal_dilithium::dilithium5::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let sig = crystal_dilithium::dilithium5::Signature::from_bytes(&signature.signature)\n                    .map_err(|e| PQCError::InvalidSignature(e.to_string()))?;\n                    \n                Ok(crystal_dilithium::dilithium5::verify(message, &sig, &pk))\n            }\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"falcon-signatures",children:"FALCON Signatures"}),"\n",(0,a.jsx)(n.p,{children:"FALCON provides more compact signatures than Dilithium:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::signature::falcon::*;\n\npub struct FalconSigner {\n    variant: FalconVariant,\n    keypair: Option<FalconKeypair>,\n}\n\n#[derive(Debug, Clone)]\npub enum FalconVariant {\n    Falcon512,   // ~128-bit security, ~1280 byte signatures\n    Falcon1024,  // ~256-bit security, ~2560 byte signatures\n}\n\nimpl PQSignatureAlgorithm for FalconSigner {\n    type Keypair = FalconKeypair;\n    type Signature = FalconSignature;\n    \n    fn generate_keypair(&mut self, variant: FalconVariant) -> Result<FalconKeypair> {\n        let (public_key, private_key) = match variant {\n            FalconVariant::Falcon512 => {\n                let (pk, sk) = falcon::falcon512::keypair(&mut rand::thread_rng());\n                (pk.as_bytes().to_vec(), sk.as_bytes().to_vec())\n            },\n            FalconVariant::Falcon1024 => {\n                let (pk, sk) = falcon::falcon1024::keypair(&mut rand::thread_rng());\n                (pk.as_bytes().to_vec(), sk.as_bytes().to_vec())\n            }\n        };\n        \n        let keypair = FalconKeypair {\n            public_key,\n            private_key,\n            variant: variant.clone(),\n        };\n        \n        self.keypair = Some(keypair.clone());\n        Ok(keypair)\n    }\n    \n    fn sign(&self, message: &[u8]) -> Result<FalconSignature> {\n        let keypair = self.keypair.as_ref()\n            .ok_or(PQCError::NoKeypairGenerated)?;\n            \n        let signature_bytes = match keypair.variant {\n            FalconVariant::Falcon512 => {\n                let private_key = falcon::falcon512::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let signature = falcon::falcon512::sign(message, &private_key, &mut rand::thread_rng());\n                signature.as_bytes().to_vec()\n            },\n            FalconVariant::Falcon1024 => {\n                let private_key = falcon::falcon1024::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let signature = falcon::falcon1024::sign(message, &private_key, &mut rand::thread_rng());\n                signature.as_bytes().to_vec()\n            }\n        };\n        \n        Ok(FalconSignature {\n            signature: signature_bytes,\n            variant: keypair.variant.clone(),\n            algorithm_id: AlgorithmId::Falcon(keypair.variant.clone()),\n        })\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ml-kem-key-encapsulation",children:"ML-KEM Key Encapsulation"}),"\n",(0,a.jsx)(n.p,{children:"ML-KEM (Module Lattice Key Encapsulation Mechanism), formerly Kyber, provides post-quantum key exchange:"}),"\n",(0,a.jsx)(n.h3,{id:"ml-kem-implementation",children:"ML-KEM Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::kem::mlkem::*;\nuse kyber::{Kyber512, Kyber768, Kyber1024};\n\npub struct MLKEMEncapsulator {\n    variant: MLKEMVariant,\n    keypair: Option<MLKEMKeypair>,\n}\n\n#[derive(Debug, Clone)]\npub enum MLKEMVariant {\n    MLKEM512,    // ~128-bit security\n    MLKEM768,    // ~192-bit security (recommended)\n    MLKEM1024,   // ~256-bit security\n}\n\n#[derive(Debug, Clone)]\npub struct MLKEMKeypair {\n    pub public_key: Vec<u8>,\n    pub private_key: Vec<u8>,\n    pub variant: MLKEMVariant,\n}\n\nimpl PQKEMAlgorithm for MLKEMEncapsulator {\n    type Keypair = MLKEMKeypair;\n    type Ciphertext = MLKEMCiphertext;\n    type SharedSecret = [u8; 32];  // 256-bit shared secret\n    \n    fn generate_keypair(&mut self, variant: MLKEMVariant) -> Result<MLKEMKeypair> {\n        let (public_key, private_key) = match variant {\n            MLKEMVariant::MLKEM512 => {\n                let (pk, sk) = kyber::kyber512::keypair(&mut rand::thread_rng());\n                (pk.as_bytes().to_vec(), sk.as_bytes().to_vec())\n            },\n            MLKEMVariant::MLKEM768 => {\n                let (pk, sk) = kyber::kyber768::keypair(&mut rand::thread_rng());\n                (pk.as_bytes().to_vec(), sk.as_bytes().to_vec())\n            },\n            MLKEMVariant::MLKEM1024 => {\n                let (pk, sk) = kyber::kyber1024::keypair(&mut rand::thread_rng());\n                (pk.as_bytes().to_vec(), sk.as_bytes().to_vec())\n            }\n        };\n        \n        let keypair = MLKEMKeypair {\n            public_key,\n            private_key,\n            variant: variant.clone(),\n        };\n        \n        self.keypair = Some(keypair.clone());\n        Ok(keypair)\n    }\n    \n    fn encapsulate(&self, public_key: &[u8]) -> Result<(Self::Ciphertext, Self::SharedSecret)> {\n        let keypair = self.keypair.as_ref()\n            .ok_or(PQCError::NoKeypairGenerated)?;\n            \n        match keypair.variant {\n            MLKEMVariant::MLKEM512 => {\n                let pk = kyber::kyber512::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let (ciphertext, shared_secret) = kyber::kyber512::encapsulate(&pk, &mut rand::thread_rng());\n                \n                Ok((\n                    MLKEMCiphertext {\n                        ciphertext: ciphertext.as_bytes().to_vec(),\n                        variant: keypair.variant.clone(),\n                    },\n                    shared_secret.as_bytes().try_into().unwrap()\n                ))\n            },\n            MLKEMVariant::MLKEM768 => {\n                let pk = kyber::kyber768::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let (ciphertext, shared_secret) = kyber::kyber768::encapsulate(&pk, &mut rand::thread_rng());\n                \n                Ok((\n                    MLKEMCiphertext {\n                        ciphertext: ciphertext.as_bytes().to_vec(),\n                        variant: keypair.variant.clone(),\n                    },\n                    shared_secret.as_bytes().try_into().unwrap()\n                ))\n            },\n            MLKEMVariant::MLKEM1024 => {\n                let pk = kyber::kyber1024::PublicKey::from_bytes(public_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let (ciphertext, shared_secret) = kyber::kyber1024::encapsulate(&pk, &mut rand::thread_rng());\n                \n                Ok((\n                    MLKEMCiphertext {\n                        ciphertext: ciphertext.as_bytes().to_vec(),\n                        variant: keypair.variant.clone(),\n                    },\n                    shared_secret.as_bytes().try_into().unwrap()\n                ))\n            }\n        }\n    }\n    \n    fn decapsulate(&self, ciphertext: &Self::Ciphertext) -> Result<Self::SharedSecret> {\n        let keypair = self.keypair.as_ref()\n            .ok_or(PQCError::NoKeypairGenerated)?;\n            \n        match ciphertext.variant {\n            MLKEMVariant::MLKEM512 => {\n                let private_key = kyber::kyber512::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let ct = kyber::kyber512::Ciphertext::from_bytes(&ciphertext.ciphertext)\n                    .map_err(|e| PQCError::InvalidCiphertext(e.to_string()))?;\n                    \n                let shared_secret = kyber::kyber512::decapsulate(&ct, &private_key);\n                Ok(shared_secret.as_bytes().try_into().unwrap())\n            },\n            MLKEMVariant::MLKEM768 => {\n                let private_key = kyber::kyber768::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let ct = kyber::kyber768::Ciphertext::from_bytes(&ciphertext.ciphertext)\n                    .map_err(|e| PQCError::InvalidCiphertext(e.to_string()))?;\n                    \n                let shared_secret = kyber::kyber768::decapsulate(&ct, &private_key);\n                Ok(shared_secret.as_bytes().try_into().unwrap())\n            },\n            MLKEMVariant::MLKEM1024 => {\n                let private_key = kyber::kyber1024::PrivateKey::from_bytes(&keypair.private_key)\n                    .map_err(|e| PQCError::InvalidKey(e.to_string()))?;\n                let ct = kyber::kyber1024::Ciphertext::from_bytes(&ciphertext.ciphertext)\n                    .map_err(|e| PQCError::InvalidCiphertext(e.to_string()))?;\n                    \n                let shared_secret = kyber::kyber1024::decapsulate(&ct, &private_key);\n                Ok(shared_secret.as_bytes().try_into().unwrap())\n            }\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"hybrid-cryptography",children:"Hybrid Cryptography"}),"\n",(0,a.jsx)(n.p,{children:"Hybrid approaches combine classical and post-quantum algorithms for security and backwards compatibility:"}),"\n",(0,a.jsx)(n.h3,{id:"hybrid-signatures",children:"Hybrid Signatures"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::hybrid::signature::*;\n\npub struct HybridSignatureManager {\n    classical_signer: Ed25519Signer,\n    pq_signer: DilithiumSigner,\n    format: HybridFormat,\n}\n\n#[derive(Debug, Clone)]\npub enum HybridFormat {\n    Concatenated,    // classical_sig || pq_sig\n    Structured,      // ASN.1 structure with both signatures\n    Nested,          // Sign(classical_sig || message) with PQ\n}\n\n#[derive(Debug, Clone)]\npub struct HybridSignature {\n    pub classical_signature: Vec<u8>,\n    pub pq_signature: Vec<u8>,\n    pub format: HybridFormat,\n    pub classical_algorithm: ClassicalAlgorithm,\n    pub pq_algorithm: PQAlgorithm,\n}\n\nimpl HybridSignatureManager {\n    pub fn sign(&self, message: &[u8]) -> Result<HybridSignature> {\n        // Sign with classical algorithm\n        let classical_sig = self.classical_signer.sign(message)?;\n        \n        // Sign with post-quantum algorithm\n        let pq_sig = match self.format {\n            HybridFormat::Concatenated | HybridFormat::Structured => {\n                // Independent signatures\n                self.pq_signer.sign(message)?\n            },\n            HybridFormat::Nested => {\n                // Sign the classical signature + message\n                let combined_data = [&classical_sig, message].concat();\n                self.pq_signer.sign(&combined_data)?\n            }\n        };\n        \n        Ok(HybridSignature {\n            classical_signature: classical_sig,\n            pq_signature: pq_sig.signature,\n            format: self.format.clone(),\n            classical_algorithm: ClassicalAlgorithm::Ed25519,\n            pq_algorithm: PQAlgorithm::Dilithium3,\n        })\n    }\n    \n    pub fn verify(\n        &self,\n        message: &[u8],\n        signature: &HybridSignature,\n        classical_pk: &[u8],\n        pq_pk: &[u8]\n    ) -> Result<bool> {\n        // Verify classical signature\n        let classical_valid = self.classical_signer.verify(\n            message,\n            &signature.classical_signature,\n            classical_pk\n        )?;\n        \n        // Verify post-quantum signature\n        let pq_valid = match signature.format {\n            HybridFormat::Concatenated | HybridFormat::Structured => {\n                // Independent verification\n                let pq_sig = DilithiumSignature {\n                    signature: signature.pq_signature.clone(),\n                    variant: DilithiumVariant::Dilithium3,\n                    algorithm_id: AlgorithmId::Dilithium(DilithiumVariant::Dilithium3),\n                };\n                self.pq_signer.verify(message, &pq_sig, pq_pk)?\n            },\n            HybridFormat::Nested => {\n                // Verify against classical signature + message\n                let combined_data = [&signature.classical_signature, message].concat();\n                let pq_sig = DilithiumSignature {\n                    signature: signature.pq_signature.clone(),\n                    variant: DilithiumVariant::Dilithium3,\n                    algorithm_id: AlgorithmId::Dilithium(DilithiumVariant::Dilithium3),\n                };\n                self.pq_signer.verify(&combined_data, &pq_sig, pq_pk)?\n            }\n        };\n        \n        // Both signatures must be valid\n        Ok(classical_valid && pq_valid)\n    }\n    \n    pub fn serialize(&self, signature: &HybridSignature) -> Result<Vec<u8>> {\n        match signature.format {\n            HybridFormat::Concatenated => {\n                // Simple concatenation: classical_len (4) || classical_sig || pq_sig\n                let mut serialized = Vec::new();\n                serialized.extend_from_slice(&(signature.classical_signature.len() as u32).to_be_bytes());\n                serialized.extend_from_slice(&signature.classical_signature);\n                serialized.extend_from_slice(&signature.pq_signature);\n                Ok(serialized)\n            },\n            HybridFormat::Structured => {\n                // ASN.1 DER encoding\n                self.serialize_asn1(signature)\n            },\n            HybridFormat::Nested => {\n                // Only PQ signature (contains classical signature)\n                Ok(signature.pq_signature.clone())\n            }\n        }\n    }\n    \n    fn serialize_asn1(&self, signature: &HybridSignature) -> Result<Vec<u8>> {\n        use yasna::construct_der;\n        \n        let der = construct_der(|writer| {\n            writer.write_sequence(|writer| {\n                // Classical algorithm OID\n                writer.next().write_oid(&signature.classical_algorithm.oid());\n                // Classical signature\n                writer.next().write_bytes(&signature.classical_signature);\n                // PQ algorithm OID  \n                writer.next().write_oid(&signature.pq_algorithm.oid());\n                // PQ signature\n                writer.next().write_bytes(&signature.pq_signature);\n            })\n        });\n        \n        Ok(der)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"hybrid-key-exchange",children:"Hybrid Key Exchange"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_pqc::hybrid::kem::*;\n\npub struct HybridKEM {\n    classical_kem: X25519KEM,\n    pq_kem: MLKEMEncapsulator,\n    combiner: KeyCombiner,\n}\n\n#[derive(Debug, Clone)]\npub enum KeyCombiner {\n    Concatenate,     // classical_secret || pq_secret\n    XOR,             // classical_secret \u2295 pq_secret (same length required)\n    HKDF,            // HKDF(classical_secret || pq_secret)\n    KDF1,            // Standard KDF1\n}\n\nimpl HybridKEM {\n    pub fn encapsulate(&self, classical_pk: &[u8], pq_pk: &[u8]) -> Result<(HybridCiphertext, [u8; 32])> {\n        // Classical key encapsulation\n        let (classical_ct, classical_secret) = self.classical_kem.encapsulate(classical_pk)?;\n        \n        // Post-quantum key encapsulation\n        let (pq_ct, pq_secret) = self.pq_kem.encapsulate(pq_pk)?;\n        \n        // Combine shared secrets\n        let combined_secret = self.combine_secrets(&classical_secret, &pq_secret)?;\n        \n        Ok((\n            HybridCiphertext {\n                classical_ciphertext: classical_ct,\n                pq_ciphertext: pq_ct,\n            },\n            combined_secret\n        ))\n    }\n    \n    pub fn decapsulate(&self, hybrid_ct: &HybridCiphertext) -> Result<[u8; 32]> {\n        // Classical decapsulation\n        let classical_secret = self.classical_kem.decapsulate(&hybrid_ct.classical_ciphertext)?;\n        \n        // Post-quantum decapsulation\n        let pq_secret = self.pq_kem.decapsulate(&hybrid_ct.pq_ciphertext)?;\n        \n        // Combine shared secrets\n        self.combine_secrets(&classical_secret, &pq_secret)\n    }\n    \n    fn combine_secrets(&self, classical: &[u8], pq: &[u8]) -> Result<[u8; 32]> {\n        match self.combiner {\n            KeyCombiner::Concatenate => {\n                let combined = [classical, pq].concat();\n                let hash = sha256::digest(&combined);\n                Ok(hash.into())\n            },\n            KeyCombiner::XOR => {\n                if classical.len() != 32 || pq.len() != 32 {\n                    return Err(PQCError::InvalidSecretLength);\n                }\n                \n                let mut result = [0u8; 32];\n                for i in 0..32 {\n                    result[i] = classical[i] ^ pq[i];\n                }\n                Ok(result)\n            },\n            KeyCombiner::HKDF => {\n                let salt = b"olocus-hybrid-kdf";\n                let info = b"hybrid-shared-secret";\n                \n                let prk = hkdf::Hkdf::<sha2::Sha256>::new(Some(salt), &[classical, pq].concat());\n                let mut okm = [0u8; 32];\n                prk.expand(info, &mut okm)\n                    .map_err(|e| PQCError::KDFError(e.to_string()))?;\n                Ok(okm)\n            },\n            KeyCombiner::KDF1 => {\n                // Implement KDF1 per IEEE 1363-2000\n                self.kdf1(&[classical, pq].concat(), 32)\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"migration-strategies",children:"Migration Strategies"}),"\n",(0,a.jsx)(n.h3,{id:"gradual-migration-framework",children:"Gradual Migration Framework"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::migration::*;\n\npub struct PQMigrationManager {\n    current_phase: MigrationPhase,\n    migration_policy: MigrationPolicy,\n    capability_detector: CapabilityDetector,\n    fallback_manager: FallbackManager,\n}\n\n#[derive(Debug, Clone)]\npub enum MigrationPhase {\n    ClassicalOnly,               // Traditional algorithms only\n    HybridIntroduction,         // Hybrid available but optional\n    HybridTransition,           // Hybrid preferred, classical fallback\n    HybridMandatory,            // Hybrid required for new connections\n    PostQuantumOnly,            // Pure PQ algorithms\n}\n\n#[derive(Debug, Clone)]\npub struct MigrationPolicy {\n    pub phase: MigrationPhase,\n    pub transition_timeline: TransitionTimeline,\n    pub fallback_to_classical: bool,\n    pub require_pq_support: bool,\n    pub migration_triggers: Vec<MigrationTrigger>,\n}\n\n#[derive(Debug, Clone)]\npub enum MigrationTrigger {\n    TimeBasedSchedule(SystemTime),      // Migrate at specific time\n    SecurityLevelChange,                 // When threat level changes\n    PeerCapabilityDetected,             // When peer supports PQ\n    ComplianceRequirement,              // Regulatory requirement\n    PerformanceThreshold(f64),          // When PQ performance acceptable\n}\n\nimpl PQMigrationManager {\n    pub async fn negotiate_algorithms(\n        &self,\n        peer_id: &str,\n        local_capabilities: &PQCapabilities,\n        peer_capabilities: &PQCapabilities\n    ) -> Result<NegotiatedAlgorithms> {\n        \n        // Check current migration phase requirements\n        let phase_requirements = self.get_phase_requirements();\n        \n        // Find compatible algorithms\n        let compatible_signatures = self.find_compatible_signatures(\n            local_capabilities,\n            peer_capabilities,\n            &phase_requirements\n        )?;\n        \n        let compatible_kems = self.find_compatible_kems(\n            local_capabilities,\n            peer_capabilities,\n            &phase_requirements\n        )?;\n        \n        // Select optimal algorithms based on policy\n        let selected_signature = self.select_optimal_signature(&compatible_signatures)?;\n        let selected_kem = self.select_optimal_kem(&compatible_kems)?;\n        \n        Ok(NegotiatedAlgorithms {\n            signature: selected_signature,\n            kem: selected_kem,\n            hybrid_mode: self.determine_hybrid_mode(&phase_requirements),\n            fallback_available: self.migration_policy.fallback_to_classical,\n        })\n    }\n    \n    fn find_compatible_signatures(\n        &self,\n        local: &PQCapabilities,\n        peer: &PQCapabilities,\n        requirements: &PhaseRequirements\n    ) -> Result<Vec<SignatureAlgorithm>> {\n        let mut compatible = Vec::new();\n        \n        match self.current_phase {\n            MigrationPhase::ClassicalOnly => {\n                // Only classical algorithms\n                for alg in &local.classical_signatures {\n                    if peer.classical_signatures.contains(alg) {\n                        compatible.push(SignatureAlgorithm::Classical(*alg));\n                    }\n                }\n            },\n            MigrationPhase::HybridIntroduction | MigrationPhase::HybridTransition => {\n                // Prefer hybrid, fall back to classical\n                for classical in &local.classical_signatures {\n                    for pq in &local.pq_signatures {\n                        if peer.classical_signatures.contains(classical) &&\n                           peer.pq_signatures.contains(pq) {\n                            compatible.push(SignatureAlgorithm::Hybrid {\n                                classical: *classical,\n                                post_quantum: *pq,\n                            });\n                        }\n                    }\n                }\n                \n                // Add classical fallbacks if policy allows\n                if self.migration_policy.fallback_to_classical {\n                    for alg in &local.classical_signatures {\n                        if peer.classical_signatures.contains(alg) {\n                            compatible.push(SignatureAlgorithm::Classical(*alg));\n                        }\n                    }\n                }\n            },\n            MigrationPhase::HybridMandatory => {\n                // Only hybrid algorithms\n                for classical in &local.classical_signatures {\n                    for pq in &local.pq_signatures {\n                        if peer.classical_signatures.contains(classical) &&\n                           peer.pq_signatures.contains(pq) {\n                            compatible.push(SignatureAlgorithm::Hybrid {\n                                classical: *classical,\n                                post_quantum: *pq,\n                            });\n                        }\n                    }\n                }\n            },\n            MigrationPhase::PostQuantumOnly => {\n                // Only post-quantum algorithms\n                for alg in &local.pq_signatures {\n                    if peer.pq_signatures.contains(alg) {\n                        compatible.push(SignatureAlgorithm::PostQuantum(*alg));\n                    }\n                }\n            }\n        }\n        \n        if compatible.is_empty() {\n            return Err(PQCError::NoCompatibleAlgorithms);\n        }\n        \n        Ok(compatible)\n    }\n    \n    pub async fn schedule_migration_phase_transition(&mut self, target_phase: MigrationPhase, transition_time: SystemTime) -> Result<()> {\n        // Validate transition is allowed\n        self.validate_phase_transition(&self.current_phase, &target_phase)?;\n        \n        // Schedule the transition\n        let migration_task = MigrationTask {\n            task_id: Uuid::new_v4().to_string(),\n            current_phase: self.current_phase.clone(),\n            target_phase: target_phase.clone(),\n            scheduled_time: transition_time,\n            preparation_tasks: self.generate_preparation_tasks(&target_phase)?,\n        };\n        \n        self.schedule_migration_task(migration_task).await?;\n        \n        Ok(())\n    }\n    \n    fn validate_phase_transition(&self, current: &MigrationPhase, target: &MigrationPhase) -> Result<()> {\n        use MigrationPhase::*;\n        \n        let valid_transition = match (current, target) {\n            (ClassicalOnly, HybridIntroduction) => true,\n            (HybridIntroduction, HybridTransition) => true,\n            (HybridTransition, HybridMandatory) => true,\n            (HybridMandatory, PostQuantumOnly) => true,\n            // Allow backwards transitions for emergency rollback\n            (HybridIntroduction, ClassicalOnly) => true,\n            (HybridTransition, HybridIntroduction) => true,\n            (HybridMandatory, HybridTransition) => true,\n            (PostQuantumOnly, HybridMandatory) => true,\n            _ => false,\n        };\n        \n        if !valid_transition {\n            return Err(PQCError::InvalidPhaseTransition {\n                current: current.clone(),\n                target: target.clone(),\n            });\n        }\n        \n        Ok(())\n    }\n    \n    fn generate_preparation_tasks(&self, target_phase: &MigrationPhase) -> Result<Vec<PreparationTask>> {\n        let mut tasks = Vec::new();\n        \n        match target_phase {\n            MigrationPhase::HybridIntroduction => {\n                tasks.push(PreparationTask::GenerateHybridKeypairs);\n                tasks.push(PreparationTask::UpdateCapabilityAdvertisement);\n                tasks.push(PreparationTask::ConfigureFallbackPolicies);\n            },\n            MigrationPhase::HybridTransition => {\n                tasks.push(PreparationTask::PromoteHybridAlgorithms);\n                tasks.push(PreparationTask::DeprecateClassicalOnlyMode);\n                tasks.push(PreparationTask::UpdateSecurityPolicies);\n            },\n            MigrationPhase::HybridMandatory => {\n                tasks.push(PreparationTask::RequireHybridSupport);\n                tasks.push(PreparationTask::DisableClassicalFallback);\n                tasks.push(PreparationTask::AuditConnections);\n            },\n            MigrationPhase::PostQuantumOnly => {\n                tasks.push(PreparationTask::GeneratePostQuantumKeypairs);\n                tasks.push(PreparationTask::MigrateExistingKeys);\n                tasks.push(PreparationTask::DisableClassicalAlgorithms);\n            },\n            _ => {}\n        }\n        \n        Ok(tasks)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"algorithm-negotiation",children:"Algorithm Negotiation"}),"\n",(0,a.jsx)(n.h3,{id:"capability-based-negotiation",children:"Capability-Based Negotiation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_pqc::negotiation::*;\n\npub struct PQNegotiator {\n    local_capabilities: PQCapabilities,\n    algorithm_preferences: AlgorithmPreferences,\n    security_requirements: SecurityRequirements,\n}\n\n#[derive(Debug, Clone)]\npub struct PQCapabilities {\n    pub classical_signatures: Vec<ClassicalSignature>,\n    pub pq_signatures: Vec<PQSignature>,\n    pub classical_kems: Vec<ClassicalKEM>,\n    pub pq_kems: Vec<PQKEM>,\n    pub hybrid_support: bool,\n    pub performance_profiles: Vec<PerformanceProfile>,\n}\n\n#[derive(Debug, Clone)]\npub struct AlgorithmPreferences {\n    pub signature_preference_order: Vec<SignatureAlgorithmId>,\n    pub kem_preference_order: Vec<KEMAlgorithmId>,\n    pub security_level_priority: SecurityLevelPriority,\n    pub performance_priority: PerformancePriority,\n}\n\nimpl PQNegotiator {\n    pub fn negotiate_signature_algorithm(\n        &self,\n        peer_capabilities: &PQCapabilities,\n        context: &NegotiationContext\n    ) -> Result<SignatureAlgorithmChoice> {\n        \n        // Filter algorithms based on security requirements\n        let mut candidates = self.filter_by_security_requirements(\n            &self.local_capabilities.get_all_signature_algorithms(),\n            peer_capabilities\n        )?;\n        \n        // Apply context-specific filters\n        candidates = self.apply_context_filters(candidates, context)?;\n        \n        // Score algorithms based on preferences\n        let scored_candidates: Vec<_> = candidates.into_iter()\n            .map(|alg| (alg.clone(), self.score_signature_algorithm(&alg, context)))\n            .collect();\n            \n        // Sort by score (highest first)\n        let mut sorted_candidates = scored_candidates;\n        sorted_candidates.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));\n        \n        // Select best algorithm\n        let selected_algorithm = sorted_candidates.into_iter()\n            .next()\n            .ok_or(PQCError::NoSuitableAlgorithm)?\n            .0;\n            \n        Ok(SignatureAlgorithmChoice {\n            algorithm: selected_algorithm,\n            rationale: self.generate_selection_rationale(&selected_algorithm, context),\n            fallback_algorithms: self.generate_fallback_list(peer_capabilities)?,\n        })\n    }\n    \n    fn score_signature_algorithm(&self, algorithm: &SignatureAlgorithmId, context: &NegotiationContext) -> f64 {\n        let mut score = 0.0;\n        \n        // Security level scoring\n        let security_score = match algorithm.security_level() {\n            SecurityLevel::Level128 => 1.0,\n            SecurityLevel::Level192 => 1.5,\n            SecurityLevel::Level256 => 2.0,\n            SecurityLevel::PQLevel3 => 2.5,\n            SecurityLevel::PQLevel5 => 3.0,\n        };\n        \n        score += security_score * self.algorithm_preferences.security_level_priority.weight();\n        \n        // Performance scoring\n        let performance_score = self.estimate_performance_score(algorithm, context);\n        score += performance_score * self.algorithm_preferences.performance_priority.weight();\n        \n        // Preference order scoring\n        let preference_score = self.calculate_preference_score(algorithm);\n        score += preference_score;\n        \n        // Future-proofing scoring\n        let future_proof_score = match algorithm {\n            SignatureAlgorithmId::Hybrid { .. } => 1.0,  // Good for transition\n            SignatureAlgorithmId::PostQuantum(_) => 1.5, // Best for future\n            SignatureAlgorithmId::Classical(_) => 0.5,   // Legacy\n        };\n        score += future_proof_score * 0.3;\n        \n        score\n    }\n    \n    fn estimate_performance_score(&self, algorithm: &SignatureAlgorithmId, context: &NegotiationContext) -> f64 {\n        // Get performance characteristics\n        let characteristics = algorithm.get_performance_characteristics();\n        \n        let mut performance_score = 0.0;\n        \n        // Key generation performance\n        performance_score += self.score_operation_time(\n            characteristics.keygen_time,\n            context.keygen_frequency\n        );\n        \n        // Signing performance\n        performance_score += self.score_operation_time(\n            characteristics.sign_time,\n            context.signing_frequency\n        ) * 2.0; // Weight signing more heavily\n        \n        // Verification performance\n        performance_score += self.score_operation_time(\n            characteristics.verify_time,\n            context.verification_frequency\n        ) * 1.5; // Weight verification highly\n        \n        // Size considerations\n        let size_penalty = self.calculate_size_penalty(\n            characteristics.signature_size,\n            context.bandwidth_constraints\n        );\n        performance_score -= size_penalty;\n        \n        performance_score.max(0.0)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"performance-benchmarking",children:"Performance Benchmarking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_pqc::benchmark::*;\n\npub struct PQBenchmarkSuite {\n    algorithms: Vec<Box<dyn PQAlgorithm>>,\n    test_data_sizes: Vec<usize>,\n    iterations: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct BenchmarkResults {\n    pub algorithm: AlgorithmId,\n    pub keygen_time: Duration,\n    pub keygen_stddev: Duration,\n    pub sign_time: Duration,\n    pub sign_stddev: Duration,\n    pub verify_time: Duration,\n    pub verify_stddev: Duration,\n    pub key_size: usize,\n    pub signature_size: usize,\n    pub throughput: BenchmarkThroughput,\n}\n\n#[derive(Debug, Clone)]\npub struct BenchmarkThroughput {\n    pub signings_per_second: f64,\n    pub verifications_per_second: f64,\n    pub bytes_per_second_signing: f64,\n    pub bytes_per_second_verification: f64,\n}\n\nimpl PQBenchmarkSuite {\n    pub async fn run_comprehensive_benchmark(&self) -> Result<Vec<BenchmarkResults>> {\n        let mut all_results = Vec::new();\n        \n        for algorithm in &self.algorithms {\n            let results = self.benchmark_algorithm(algorithm.as_ref()).await?;\n            all_results.push(results);\n        }\n        \n        // Sort by overall performance score\n        all_results.sort_by(|a, b| {\n            let score_a = self.calculate_overall_score(a);\n            let score_b = self.calculate_overall_score(b);\n            score_b.partial_cmp(&score_a).unwrap_or(std::cmp::Ordering::Equal)\n        });\n        \n        Ok(all_results)\n    }\n    \n    async fn benchmark_algorithm(&self, algorithm: &dyn PQAlgorithm) -> Result<BenchmarkResults> {\n        let mut keygen_times = Vec::new();\n        let mut sign_times = Vec::new();\n        let mut verify_times = Vec::new();\n        \n        let test_message = b"Hello, post-quantum world!";\n        \n        // Benchmark key generation\n        for _ in 0..self.iterations {\n            let start = Instant::now();\n            let keypair = algorithm.generate_keypair().await?;\n            let duration = start.elapsed();\n            keygen_times.push(duration);\n            \n            // Benchmark signing\n            let start = Instant::now();\n            let signature = algorithm.sign(test_message, &keypair).await?;\n            let sign_duration = start.elapsed();\n            sign_times.push(sign_duration);\n            \n            // Benchmark verification\n            let start = Instant::now();\n            let is_valid = algorithm.verify(test_message, &signature, &keypair.public_key).await?;\n            let verify_duration = start.elapsed();\n            verify_times.push(verify_duration);\n            \n            assert!(is_valid);\n        }\n        \n        // Calculate statistics\n        let keygen_stats = self.calculate_time_statistics(&keygen_times);\n        let sign_stats = self.calculate_time_statistics(&sign_times);\n        let verify_stats = self.calculate_time_statistics(&verify_times);\n        \n        // Measure sizes\n        let keypair = algorithm.generate_keypair().await?;\n        let signature = algorithm.sign(test_message, &keypair).await?;\n        \n        let key_size = keypair.public_key.len() + keypair.private_key.len();\n        let signature_size = signature.len();\n        \n        // Calculate throughput\n        let throughput = self.calculate_throughput(&sign_times, &verify_times, test_message.len());\n        \n        Ok(BenchmarkResults {\n            algorithm: algorithm.algorithm_id(),\n            keygen_time: keygen_stats.mean,\n            keygen_stddev: keygen_stats.stddev,\n            sign_time: sign_stats.mean,\n            sign_stddev: sign_stats.stddev,\n            verify_time: verify_stats.mean,\n            verify_stddev: verify_stats.stddev,\n            key_size,\n            signature_size,\n            throughput,\n        })\n    }\n    \n    fn calculate_throughput(&self, sign_times: &[Duration], verify_times: &[Duration], message_size: usize) -> BenchmarkThroughput {\n        let avg_sign_time = sign_times.iter().sum::<Duration>() / sign_times.len() as u32;\n        let avg_verify_time = verify_times.iter().sum::<Duration>() / verify_times.len() as u32;\n        \n        let signings_per_second = if avg_sign_time.as_nanos() > 0 {\n            1_000_000_000.0 / avg_sign_time.as_nanos() as f64\n        } else {\n            f64::INFINITY\n        };\n        \n        let verifications_per_second = if avg_verify_time.as_nanos() > 0 {\n            1_000_000_000.0 / avg_verify_time.as_nanos() as f64\n        } else {\n            f64::INFINITY\n        };\n        \n        BenchmarkThroughput {\n            signings_per_second,\n            verifications_per_second,\n            bytes_per_second_signing: signings_per_second * message_size as f64,\n            bytes_per_second_verification: verifications_per_second * message_size as f64,\n        }\n    }\n    \n    fn calculate_overall_score(&self, results: &BenchmarkResults) -> f64 {\n        // Weighted score considering multiple factors\n        let speed_score = 1000.0 / results.sign_time.as_millis() as f64;  // Higher is better\n        let size_score = 1000.0 / results.signature_size as f64;          // Smaller is better\n        let throughput_score = results.throughput.signings_per_second / 1000.0; // Normalize\n        \n        // Weighted combination\n        speed_score * 0.4 + size_score * 0.3 + throughput_score * 0.3\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"testing--integration",children:"Testing & Integration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod pqc_tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_dilithium_signature_roundtrip() {\n        let mut signer = DilithiumSigner::new(DilithiumVariant::Dilithium3);\n        let keypair = signer.generate_keypair(DilithiumVariant::Dilithium3).unwrap();\n        \n        let message = b"Test message for Dilithium signature";\n        let signature = signer.sign(message).unwrap();\n        \n        let is_valid = signer.verify(message, &signature, &keypair.public_key).unwrap();\n        assert!(is_valid);\n        \n        // Test with wrong message\n        let wrong_message = b"Wrong message";\n        let is_invalid = signer.verify(wrong_message, &signature, &keypair.public_key).unwrap();\n        assert!(!is_invalid);\n    }\n    \n    #[tokio::test]\n    async fn test_mlkem_key_encapsulation() {\n        let mut kem = MLKEMEncapsulator::new(MLKEMVariant::MLKEM768);\n        let keypair = kem.generate_keypair(MLKEMVariant::MLKEM768).unwrap();\n        \n        // Encapsulate\n        let (ciphertext, shared_secret1) = kem.encapsulate(&keypair.public_key).unwrap();\n        \n        // Decapsulate\n        let shared_secret2 = kem.decapsulate(&ciphertext).unwrap();\n        \n        // Secrets should match\n        assert_eq!(shared_secret1, shared_secret2);\n    }\n    \n    #[tokio::test]\n    async fn test_hybrid_signature() {\n        let classical_signer = Ed25519Signer::new();\n        let pq_signer = DilithiumSigner::new(DilithiumVariant::Dilithium3);\n        \n        let hybrid_manager = HybridSignatureManager::new(\n            classical_signer,\n            pq_signer,\n            HybridFormat::Concatenated\n        );\n        \n        let message = b"Hybrid signature test message";\n        let signature = hybrid_manager.sign(message).unwrap();\n        \n        // Generate keypairs for verification\n        let classical_keypair = Ed25519Keypair::generate();\n        let pq_keypair = DilithiumKeypair::generate(DilithiumVariant::Dilithium3);\n        \n        let is_valid = hybrid_manager.verify(\n            message,\n            &signature,\n            &classical_keypair.public_key,\n            &pq_keypair.public_key\n        ).unwrap();\n        \n        assert!(is_valid);\n    }\n    \n    #[tokio::test]\n    async fn test_migration_phase_transition() {\n        let mut migration_manager = PQMigrationManager::new(MigrationPhase::ClassicalOnly);\n        \n        // Test valid transition\n        let result = migration_manager.schedule_migration_phase_transition(\n            MigrationPhase::HybridIntroduction,\n            SystemTime::now() + Duration::from_secs(3600)\n        ).await;\n        \n        assert!(result.is_ok());\n        \n        // Test invalid transition\n        let invalid_result = migration_manager.schedule_migration_phase_transition(\n            MigrationPhase::PostQuantumOnly, // Skip intermediate phases\n            SystemTime::now() + Duration::from_secs(7200)\n        ).await;\n        \n        assert!(invalid_result.is_err());\n    }\n    \n    #[tokio::test]\n    async fn test_algorithm_negotiation() {\n        let local_capabilities = PQCapabilities {\n            classical_signatures: vec![ClassicalSignature::Ed25519, ClassicalSignature::ECDSA_P256],\n            pq_signatures: vec![PQSignature::Dilithium3, PQSignature::Falcon512],\n            classical_kems: vec![ClassicalKEM::X25519],\n            pq_kems: vec![PQKEM::MLKEM768],\n            hybrid_support: true,\n            performance_profiles: vec![PerformanceProfile::Balanced],\n        };\n        \n        let peer_capabilities = PQCapabilities {\n            classical_signatures: vec![ClassicalSignature::Ed25519],\n            pq_signatures: vec![PQSignature::Dilithium3],\n            classical_kems: vec![ClassicalKEM::X25519],\n            pq_kems: vec![PQKEM::MLKEM768],\n            hybrid_support: true,\n            performance_profiles: vec![PerformanceProfile::HighSecurity],\n        };\n        \n        let migration_manager = PQMigrationManager::new(MigrationPhase::HybridTransition);\n        \n        let negotiated = migration_manager.negotiate_algorithms(\n            "test_peer",\n            &local_capabilities,\n            &peer_capabilities\n        ).await.unwrap();\n        \n        // Should negotiate hybrid algorithms in hybrid transition phase\n        match negotiated.signature {\n            SignatureAlgorithm::Hybrid { classical, post_quantum } => {\n                assert_eq!(classical, ClassicalSignature::Ed25519);\n                assert_eq!(post_quantum, PQSignature::Dilithium3);\n            },\n            _ => panic!("Expected hybrid signature algorithm"),\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/extensions/security/trust-networks",children:"Trust Networks"})," - PQ-secured trust relationships"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/extensions/security/hsm-integration",children:"HSM Integration"})," - Hardware-backed PQ operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/extensions/security/keystore",children:"Keystore"})," - PQ key lifecycle management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/extensions/security/device-integrity",children:"Device Integrity"})," - PQ-enabled device attestation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/architecture/formal-verification",children:"Formal Verification"})," - PQ protocol verification"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);