"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[4851],{3779:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"concepts/cryptographic-primitives","title":"Cryptographic Primitives","description":"Olocus Protocol uses carefully selected cryptographic primitives that prioritize security, performance, and interoperability. The core protocol employs a minimal cryptographic suite called \\"Suite-2024-01\\" which provides strong security guarantees while maintaining simplicity.","source":"@site/docs/concepts/cryptographic-primitives.md","sourceDirName":"concepts","slug":"/concepts/cryptographic-primitives","permalink":"/docs/concepts/cryptographic-primitives","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/cryptographic-primitives.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"cryptographic-primitives","title":"Cryptographic Primitives","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Universal Measurement Foundation","permalink":"/docs/concepts/measurements"},"next":{"title":"Wire Format","permalink":"/docs/concepts/wire-format"}}');var r=n(4848),t=n(8453);const l={id:"cryptographic-primitives",title:"Cryptographic Primitives",sidebar_position:1},c="Cryptographic Primitives",a={},o=[{value:"Current Cryptographic Suite (Suite-2024-01)",id:"current-cryptographic-suite-suite-2024-01",level:2},{value:"Why These Choices?",id:"why-these-choices",level:3},{value:"CryptoSuite Implementation",id:"cryptosuite-implementation",level:2},{value:"Suite Identifier",id:"suite-identifier",level:3},{value:"Key Generation",id:"key-generation",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Hash Operations",id:"hash-operations",level:2},{value:"Hash Properties",id:"hash-properties",level:3},{value:"Signature Operations",id:"signature-operations",level:2},{value:"Signature Properties",id:"signature-properties",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Algorithm Agility",id:"algorithm-agility",level:3},{value:"Post-Quantum Readiness",id:"post-quantum-readiness",level:3},{value:"Side-Channel Resistance",id:"side-channel-resistance",level:3},{value:"Implementation Notes",id:"implementation-notes",level:2},{value:"Library Dependencies",id:"library-dependencies",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Memory Requirements",id:"memory-requirements",level:3},{value:"Validation and Testing",id:"validation-and-testing",level:2},{value:"Test Vectors",id:"test-vectors",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"cryptographic-primitives",children:"Cryptographic Primitives"})}),"\n",(0,r.jsx)(i.p,{children:'Olocus Protocol uses carefully selected cryptographic primitives that prioritize security, performance, and interoperability. The core protocol employs a minimal cryptographic suite called "Suite-2024-01" which provides strong security guarantees while maintaining simplicity.'}),"\n",(0,r.jsx)(i.h2,{id:"current-cryptographic-suite-suite-2024-01",children:"Current Cryptographic Suite (Suite-2024-01)"}),"\n",(0,r.jsx)(i.p,{children:"The default cryptographic suite includes:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Digital Signatures"}),": Ed25519 (using Curve25519)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Cryptographic Hashing"}),": SHA-256"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Key Exchange"}),": X25519 (for future extensions)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Symmetric Encryption"}),": AES-256-GCM (for future extensions)"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"why-these-choices",children:"Why These Choices?"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Ed25519 Signatures"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Fast verification and signing"}),"\n",(0,r.jsx)(i.li,{children:"Small signature size (64 bytes)"}),"\n",(0,r.jsx)(i.li,{children:"Resistant to side-channel attacks"}),"\n",(0,r.jsx)(i.li,{children:"No malleability issues"}),"\n",(0,r.jsx)(i.li,{children:"Deterministic signatures"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"SHA-256 Hashing"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Well-studied and widely trusted"}),"\n",(0,r.jsx)(i.li,{children:"Good performance characteristics"}),"\n",(0,r.jsx)(i.li,{children:"256-bit security level"}),"\n",(0,r.jsx)(i.li,{children:"No known practical attacks"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Future-Ready Design"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Post-quantum algorithms ready for integration"}),"\n",(0,r.jsx)(i.li,{children:"Extensible suite identifier system"}),"\n",(0,r.jsx)(i.li,{children:"Algorithm negotiation support"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"cryptosuite-implementation",children:"CryptoSuite Implementation"}),"\n",(0,r.jsx)(i.p,{children:"The protocol uses an enum-based approach for algorithm selection:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"pub enum CryptoSuite {\n    /// Default suite: Ed25519 + SHA-256\n    #[default]\n    Default,\n    // Future suites can be added here:\n    // PostQuantum,\n    // Legacy,\n}\n"})}),"\n",(0,r.jsx)(i.h3,{id:"suite-identifier",children:"Suite Identifier"}),"\n",(0,r.jsx)(i.p,{children:"Each cryptographic suite has a unique identifier:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Suite-2024-01"}),": Ed25519 signatures + SHA-256 hashing"]}),"\n",(0,r.jsx)(i.li,{children:"Future suites will have different identifiers (e.g., Suite-2025-01 for post-quantum)"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"key-generation",children:"Key Generation"}),"\n",(0,r.jsx)(i.p,{children:"Keys are generated using cryptographically secure random number generation:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:"use rand::rngs::OsRng;\nuse rand::RngCore;\n\n// Generate Ed25519 signing key\nlet mut csprng = OsRng;\nlet mut bytes = [0u8; 32];\ncsprng.fill_bytes(&mut bytes);\nlet signing_key = SigningKey::from_bytes(&bytes);\n"})}),"\n",(0,r.jsx)(i.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Private Keys"}),": 32 bytes (Ed25519 seed)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Public Keys"}),": 32 bytes (compressed curve point)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Signatures"}),": 64 bytes (R || s format)"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"hash-operations",children:"Hash Operations"}),"\n",(0,r.jsx)(i.p,{children:"All hashing uses SHA-256 with consistent output format:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:'// Hash arbitrary data\nlet data = b"hello world";\nlet hash = crypto_suite.hash(data); // Returns Hash([u8; 32])\n'})}),"\n",(0,r.jsx)(i.h3,{id:"hash-properties",children:"Hash Properties"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Output Size"}),": 256 bits (32 bytes)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Security Level"}),": ~128-bit security"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Performance"}),": Optimized implementations available"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deterministic"}),": Same input always produces same output"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"signature-operations",children:"Signature Operations"}),"\n",(0,r.jsx)(i.p,{children:"Ed25519 provides deterministic signatures with strong security properties:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:'// Sign a message\nlet message = b"block header data";\nlet signature = crypto_suite.sign(&signing_key, message);\n\n// Verify signature\nlet is_valid = crypto_suite.verify(&public_key, message, &signature);\n'})}),"\n",(0,r.jsx)(i.h3,{id:"signature-properties",children:"Signature Properties"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Deterministic"}),": Same message + key = same signature"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Non-malleable"}),": Cannot modify signatures"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Fast Verification"}),": Batch verification possible"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Small Size"}),": 64 bytes per signature"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(i.h3,{id:"algorithm-agility",children:"Algorithm Agility"}),"\n",(0,r.jsx)(i.p,{children:"The protocol is designed to evolve its cryptographic algorithms:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Suite Versioning"}),": Each suite has a unique identifier"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Backward Compatibility"}),": Older suites remain supported"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Migration Path"}),": Clear upgrade procedures"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Negotiation"}),": Peers can agree on common algorithms"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"post-quantum-readiness",children:"Post-Quantum Readiness"}),"\n",(0,r.jsx)(i.p,{children:"Future cryptographic suites will include post-quantum algorithms:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Dilithium"}),": Post-quantum signatures"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"ML-KEM/Kyber"}),": Post-quantum key exchange"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Hybrid Mode"}),": Classical + post-quantum combinations"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"side-channel-resistance",children:"Side-Channel Resistance"}),"\n",(0,r.jsx)(i.p,{children:"Ed25519 was specifically chosen for its resistance to timing and other side-channel attacks:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Constant-Time Operations"}),": No secret-dependent branches"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Complete Formulas"}),": No exceptional cases"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Safe-by-Design"}),": Difficult to implement incorrectly"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"implementation-notes",children:"Implementation Notes"}),"\n",(0,r.jsx)(i.h3,{id:"library-dependencies",children:"Library Dependencies"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"ed25519-dalek"}),": Ed25519 signature implementation"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"sha2"}),": SHA-256 hashing implementation"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"rand"}),": Cryptographically secure random number generation"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(i.p,{children:"Typical performance on modern hardware:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Key Generation"}),": ~50,000 keys/second"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Signing"}),": ~15,000 signatures/second"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Verification"}),": ~5,000 verifications/second"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Hashing"}),": ~100 MB/second (SHA-256)"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"memory-requirements",children:"Memory Requirements"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Key Storage"}),": 32 bytes per private key"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Signature Storage"}),": 64 bytes per signature"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Hash Storage"}),": 32 bytes per hash"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Working Memory"}),": <1KB for operations"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"validation-and-testing",children:"Validation and Testing"}),"\n",(0,r.jsx)(i.p,{children:"All cryptographic operations include comprehensive validation:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-rust",children:'// Verify suite compatibility\nassert!(crypto_suite.verify_suite("Suite-2024-01"));\n\n// Test key generation\nlet key = crypto_suite.generate_key();\nlet pubkey = key.verifying_key();\n\n// Test signing round-trip\nlet message = b"test message";\nlet signature = crypto_suite.sign(&key, message);\nassert!(crypto_suite.verify(&pubkey, message, &signature).is_ok());\n'})}),"\n",(0,r.jsx)(i.h3,{id:"test-vectors",children:"Test Vectors"}),"\n",(0,r.jsx)(i.p,{children:"The implementation includes standard test vectors to ensure compatibility:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Ed25519 RFC 8032 test vectors"}),"\n",(0,r.jsx)(i.li,{children:"SHA-256 FIPS 180-4 test vectors"}),"\n",(0,r.jsx)(i.li,{children:"Cross-platform deterministic output tests"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>c});var s=n(6540);const r={},t=s.createContext(r);function l(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);