"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[7520],{8047:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api/cryptographic-operations","title":"Cryptographic Operations","description":"This API reference covers all cryptographic operations available in Olocus Protocol, including key generation, signing, verification, hashing, and encryption. All operations use the CryptoSuite abstraction for algorithm agility.","source":"@site/docs/api/cryptographic-operations.md","sourceDirName":"api","slug":"/api/cryptographic-operations","permalink":"/docs/api/cryptographic-operations","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/api/cryptographic-operations.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"cryptographic-operations","title":"Cryptographic Operations","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Block Operations API","permalink":"/docs/api/block-operations"},"next":{"title":"Measurement API","permalink":"/docs/api/measurement-api"}}');var r=i(4848),t=i(8453);const a={id:"cryptographic-operations",title:"Cryptographic Operations",sidebar_position:1},l="Cryptographic Operations",o={},c=[{value:"Core Types",id:"core-types",level:2},{value:"CryptoSuite",id:"cryptosuite",level:3},{value:"Hash Type",id:"hash-type",level:3},{value:"Key Operations",id:"key-operations",level:2},{value:"Key Generation",id:"key-generation",level:3},{value:"Public Key Derivation",id:"public-key-derivation",level:3},{value:"Hash Operations",id:"hash-operations",level:2},{value:"Basic Hashing",id:"basic-hashing",level:3},{value:"Hash Properties",id:"hash-properties",level:3},{value:"Signature Operations",id:"signature-operations",level:2},{value:"Signing Messages",id:"signing-messages",level:3},{value:"Signature Verification",id:"signature-verification",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Basic Cryptographic Workflow",id:"basic-cryptographic-workflow",level:3},{value:"Block Signing Example",id:"block-signing-example",level:3},{value:"Algorithm Compatibility",id:"algorithm-compatibility",level:2},{value:"Suite Information",id:"suite-information",level:3},{value:"Cross-Platform Compatibility",id:"cross-platform-compatibility",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Errors",id:"common-errors",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Typical Performance (Modern Hardware)",id:"typical-performance-modern-hardware",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Testing Utilities",id:"testing-utilities",level:2},{value:"Test Vectors",id:"test-vectors",level:3},{value:"Migration and Upgrades",id:"migration-and-upgrades",level:2},{value:"Future Cryptographic Suites",id:"future-cryptographic-suites",level:3},{value:"Upgrade Strategy",id:"upgrade-strategy",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"cryptographic-operations",children:"Cryptographic Operations"})}),"\n",(0,r.jsx)(n.p,{children:"This API reference covers all cryptographic operations available in Olocus Protocol, including key generation, signing, verification, hashing, and encryption. All operations use the CryptoSuite abstraction for algorithm agility."}),"\n",(0,r.jsx)(n.h2,{id:"core-types",children:"Core Types"}),"\n",(0,r.jsx)(n.h3,{id:"cryptosuite",children:"CryptoSuite"}),"\n",(0,r.jsx)(n.p,{children:"The main entry point for all cryptographic operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub enum CryptoSuite {\n    #[default]\n    Default,  // Ed25519 + SHA-256\n    // Future: PostQuantum, Legacy, etc.\n}\n\nimpl CryptoSuite {\n    pub fn identifier(&self) -> &'static str;\n    pub fn from_identifier(id: &str) -> Option<Self>;\n    pub fn hash_algorithm(&self) -> &'static str;\n    pub fn signature_algorithm(&self) -> &'static str;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hash-type",children:"Hash Type"}),"\n",(0,r.jsx)(n.p,{children:"Type-safe wrapper for hash outputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct Hash(pub [u8; 32]);\n\nimpl Hash {\n    pub fn as_bytes(&self) -> &[u8; 32];\n    pub fn from_bytes(bytes: [u8; 32]) -> Self;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-operations",children:"Key Operations"}),"\n",(0,r.jsx)(n.h3,{id:"key-generation",children:"Key Generation"}),"\n",(0,r.jsx)(n.p,{children:"Generate cryptographically secure Ed25519 keys:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Using CryptoSuite (recommended)\nlet suite = CryptoSuite::default();\nlet signing_key = suite.generate_key();\n\n// Using convenience function\nlet signing_key = olocus_core::crypto::generate_key();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"SigningKey"}),": 32-byte Ed25519 private key"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Security Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses OS random number generator (",(0,r.jsx)(n.code,{children:"OsRng"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Suitable for production use"}),"\n",(0,r.jsx)(n.li,{children:"Keys are generated fresh each time"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"public-key-derivation",children:"Public Key Derivation"}),"\n",(0,r.jsx)(n.p,{children:"Derive public key from private key:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let signing_key = suite.generate_key();\nlet verifying_key = signing_key.verifying_key();\n\n// Public key bytes\nlet pubkey_bytes: [u8; 32] = *verifying_key.as_bytes();\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VerifyingKey"}),": Ed25519 public key"]}),"\n",(0,r.jsx)(n.li,{children:"Key bytes are 32 bytes (compressed curve point)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"hash-operations",children:"Hash Operations"}),"\n",(0,r.jsx)(n.h3,{id:"basic-hashing",children:"Basic Hashing"}),"\n",(0,r.jsx)(n.p,{children:"Compute SHA-256 hash of arbitrary data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Using CryptoSuite\nlet suite = CryptoSuite::default();\nlet data = b"hello world";\nlet hash = suite.hash(data);  // Returns Hash([u8; 32])\n\n// Using convenience function\nlet hash_bytes = olocus_core::crypto::hash(data);  // Returns [u8; 32]\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"data: &[u8]"})," - Arbitrary input data"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Hash"})," - Type-safe 32-byte SHA-256 output"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"hash-properties",children:"Hash Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let hash = suite.hash(b"test data");\n\n// Convert to different formats\nlet bytes: [u8; 32] = hash.into();\nlet slice: &[u8] = hash.as_ref();\nlet hash_copy = Hash::from(bytes);\n\n// Hashing is deterministic\nassert_eq!(suite.hash(b"test"), suite.hash(b"test"));\n'})}),"\n",(0,r.jsx)(n.h2,{id:"signature-operations",children:"Signature Operations"}),"\n",(0,r.jsx)(n.h3,{id:"signing-messages",children:"Signing Messages"}),"\n",(0,r.jsx)(n.p,{children:"Create Ed25519 signatures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let suite = CryptoSuite::default();\nlet signing_key = suite.generate_key();\nlet message = b"block header data";\n\nlet signature = suite.sign(&signing_key, message);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signing_key: &SigningKey"})," - Private key for signing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"message: &[u8]"})," - Data to sign"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Signature"})," - 64-byte Ed25519 signature"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Properties:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Deterministic: same key + message = same signature"}),"\n",(0,r.jsx)(n.li,{children:"Non-malleable: signatures cannot be modified"}),"\n",(0,r.jsx)(n.li,{children:"Fast signing: ~15,000 operations/second"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"signature-verification",children:"Signature Verification"}),"\n",(0,r.jsx)(n.p,{children:"Verify Ed25519 signatures:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let verifying_key = signing_key.verifying_key();\nlet is_valid = suite.verify(&verifying_key, message, &signature);\n\nmatch is_valid {\n    Ok(()) => println!("Signature valid"),\n    Err(Error::InvalidSignature) => println!("Signature invalid"),\n    Err(e) => println!("Other error: {}", e),\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"verifying_key: &VerifyingKey"})," - Public key for verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"message: &[u8]"})," - Original signed data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"signature: &Signature"})," - Signature to verify"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Result<()>"})," - Ok if valid, Error::InvalidSignature if invalid"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Performance:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast verification: ~5,000 operations/second"}),"\n",(0,r.jsx)(n.li,{children:"Constant-time operation (timing attack resistant)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.h3,{id:"basic-cryptographic-workflow",children:"Basic Cryptographic Workflow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::crypto::{CryptoSuite, generate_key, hash};\n\nfn example_workflow() -> Result<(), Box<dyn std::error::Error>> {\n    // Initialize crypto suite\n    let suite = CryptoSuite::default();\n    println!("Using suite: {}", suite.identifier());\n    \n    // Generate keys\n    let signing_key = suite.generate_key();\n    let verifying_key = signing_key.verifying_key();\n    \n    // Create some data to sign\n    let data = b"Hello, Olocus Protocol!";\n    \n    // Hash the data\n    let data_hash = suite.hash(data);\n    println!("Data hash: {:02x?}", data_hash.as_bytes());\n    \n    // Sign the hash\n    let signature = suite.sign(&signing_key, data);\n    println!("Signature: {} bytes", signature.to_bytes().len());\n    \n    // Verify the signature\n    suite.verify(&verifying_key, data, &signature)?;\n    println!("Signature verified successfully!");\n    \n    // Test that modified data fails verification\n    let modified_data = b"Hello, Modified Data!";\n    let verify_result = suite.verify(&verifying_key, modified_data, &signature);\n    assert!(verify_result.is_err());\n    println!("Modified data correctly failed verification");\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"block-signing-example",children:"Block Signing Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, EmptyPayload, CryptoSuite};\n\nfn sign_block_example() -> Result<(), Box<dyn std::error::Error>> {\n    let suite = CryptoSuite::default();\n    let signing_key = suite.generate_key();\n    \n    // Create a genesis block\n    let payload = EmptyPayload;\n    let timestamp = 1640995200; // Example timestamp\n    let block = Block::genesis(payload, &signing_key, timestamp);\n    \n    // Verify the block was signed correctly\n    block.verify()?;\n    println!("Block signature verified!");\n    \n    // Access block components\n    println!("Block index: {}", block.header.index);\n    println!("Block timestamp: {}", block.header.timestamp);\n    println!("Payload type: {}", block.header.payload_type);\n    println!("Public key: {:02x?}", block.public_key.as_bytes());\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"algorithm-compatibility",children:"Algorithm Compatibility"}),"\n",(0,r.jsx)(n.h3,{id:"suite-information",children:"Suite Information"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'let suite = CryptoSuite::default();\n\n// Get algorithm names\nprintln!("Hash algorithm: {}", suite.hash_algorithm());      // "SHA-256"\nprintln!("Signature algorithm: {}", suite.signature_algorithm()); // "Ed25519"\n\n// Check suite compatibility\nassert!(olocus_core::crypto::verify_suite("Suite-2024-01"));\nassert!(!olocus_core::crypto::verify_suite("Unknown-Suite"));\n\n// Suite constants\nassert_eq!(suite.identifier(), olocus_core::crypto::SUITE_2024_01);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"cross-platform-compatibility",children:"Cross-Platform Compatibility"}),"\n",(0,r.jsx)(n.p,{children:"All cryptographic operations produce identical results across platforms:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// These will be identical on all platforms\nlet key = suite.generate_key();\nlet hash1 = suite.hash(b"test data");\nlet hash2 = suite.hash(b"test data");\nassert_eq!(hash1, hash2);\n\n// Deterministic signatures\nlet sig1 = suite.sign(&key, b"message");\nlet sig2 = suite.sign(&key, b"message");\nassert_eq!(sig1, sig2);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.h3,{id:"common-errors",children:"Common Errors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::Error;\n\n// Signature verification errors\nmatch suite.verify(&public_key, message, &signature) {\n    Ok(()) => println!("Valid signature"),\n    Err(Error::InvalidSignature) => println!("Signature verification failed"),\n    Err(e) => println!("Unexpected error: {}", e),\n}\n\n// Suite compatibility errors\nmatch CryptoSuite::from_identifier("Unknown-Suite-2025") {\n    Some(suite) => println!("Suite supported"),\n    None => println!("Suite not supported"),\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always verify signatures"})," before trusting signed data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle errors gracefully"})," - invalid signatures are expected in adversarial environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate random sources"})," - CryptoSuite uses OS randomness automatically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Store keys securely"})," - private keys should never be logged or transmitted"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate inputs"})," - check key and signature lengths before processing"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.h3,{id:"typical-performance-modern-hardware",children:"Typical Performance (Modern Hardware)"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation"}),(0,r.jsx)(n.th,{children:"Speed"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Key Generation"}),(0,r.jsx)(n.td,{children:"50,000/sec"}),(0,r.jsx)(n.td,{children:"Uses OS random source"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SHA-256 Hash"}),(0,r.jsx)(n.td,{children:"100 MB/sec"}),(0,r.jsx)(n.td,{children:"Optimized implementations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Ed25519 Sign"}),(0,r.jsx)(n.td,{children:"15,000/sec"}),(0,r.jsx)(n.td,{children:"Deterministic signatures"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Ed25519 Verify"}),(0,r.jsx)(n.td,{children:"5,000/sec"}),(0,r.jsx)(n.td,{children:"Constant-time verification"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Hash Creation"}),(0,r.jsx)(n.td,{children:"<1\u03bcs"}),(0,r.jsx)(n.td,{children:"Type conversion overhead"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Component"}),(0,r.jsx)(n.th,{children:"Size"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Private Key"}),(0,r.jsx)(n.td,{children:"32 bytes"}),(0,r.jsx)(n.td,{children:"Ed25519 seed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Public Key"}),(0,r.jsx)(n.td,{children:"32 bytes"}),(0,r.jsx)(n.td,{children:"Compressed curve point"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Signature"}),(0,r.jsx)(n.td,{children:"64 bytes"}),(0,r.jsx)(n.td,{children:"R + s components"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Hash"}),(0,r.jsx)(n.td,{children:"32 bytes"}),(0,r.jsx)(n.td,{children:"SHA-256 output"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Working Memory"}),(0,r.jsx)(n.td,{children:"<1KB"}),(0,r.jsx)(n.td,{children:"Temporary calculations"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsx)(n.p,{children:"All cryptographic operations are thread-safe:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::thread;\n\nlet suite = Arc::new(CryptoSuite::default());\nlet handles: Vec<_> = (0..4).map(|i| {\n    let suite = Arc::clone(&suite);\n    thread::spawn(move || {\n        let data = format!("thread {}", i);\n        let hash = suite.hash(data.as_bytes());\n        println!("Thread {} hash: {:02x?}", i, hash.as_bytes());\n    })\n}).collect();\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-utilities",children:"Testing Utilities"}),"\n",(0,r.jsx)(n.h3,{id:"test-vectors",children:"Test Vectors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_known_vectors() {\n        let suite = CryptoSuite::default();\n        \n        // Known hash test vector\n        let input = b"abc";\n        let expected = hex::decode("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad")?;\n        let actual = suite.hash(input);\n        assert_eq!(actual.as_bytes(), &expected[..]);\n    }\n    \n    #[test]\n    fn test_sign_verify_roundtrip() {\n        let suite = CryptoSuite::default();\n        let key = suite.generate_key();\n        let pubkey = key.verifying_key();\n        \n        let message = b"test message";\n        let signature = suite.sign(&key, message);\n        \n        assert!(suite.verify(&pubkey, message, &signature).is_ok());\n        \n        // Wrong message should fail\n        let wrong_message = b"wrong message";\n        assert!(suite.verify(&pubkey, wrong_message, &signature).is_err());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"migration-and-upgrades",children:"Migration and Upgrades"}),"\n",(0,r.jsx)(n.h3,{id:"future-cryptographic-suites",children:"Future Cryptographic Suites"}),"\n",(0,r.jsx)(n.p,{children:"When new suites are added, the API remains backward compatible:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Future example - not yet implemented\nlet quantum_suite = CryptoSuite::PostQuantum;  // Dilithium + BLAKE3\nlet hybrid_suite = CryptoSuite::Hybrid;        // Classical + PQ\n\n// API remains the same\nlet key = quantum_suite.generate_key();\nlet hash = quantum_suite.hash(data);\nlet signature = quantum_suite.sign(&key, data);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"upgrade-strategy",children:"Upgrade Strategy"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add new suite variants"})," to the enum"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement trait methods"})," for new algorithms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update metadata"})," with algorithm information"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintain backward compatibility"})," for existing suites"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provide migration tools"})," for key/signature format changes"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);