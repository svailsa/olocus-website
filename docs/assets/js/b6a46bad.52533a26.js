"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[1899],{6968:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"integration/ios","title":"iOS Integration","description":"Integrate Olocus Protocol into iOS applications using Swift or Objective-C through the C FFI interface. This guide covers native iOS features including Secure Enclave, App Attestation, and Core Location integration.","source":"@site/docs/integration/ios.md","sourceDirName":"integration","slug":"/integration/ios","permalink":"/docs/integration/ios","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/integration/ios.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"ios","title":"iOS Integration","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Platform Integration Overview","permalink":"/docs/integration/platform-overview"},"next":{"title":"Android Integration","permalink":"/docs/integration/android"}}');var r=t(4848),i=t(8453);const o={id:"ios",title:"iOS Integration",sidebar_position:1},s="iOS Integration",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Installation",id:"installation",level:2},{value:"Option 1: Pre-built Framework",id:"option-1-pre-built-framework",level:3},{value:"Option 2: Build from Source",id:"option-2-build-from-source",level:3},{value:"Swift Integration",id:"swift-integration",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Key Management with Secure Enclave",id:"key-management-with-secure-enclave",level:3},{value:"App Attestation Integration",id:"app-attestation-integration",level:3},{value:"Location Integration",id:"location-integration",level:3},{value:"Wire Format Integration",id:"wire-format-integration",level:3},{value:"Objective-C Integration",id:"objective-c-integration",level:2},{value:"Wrapper Class",id:"wrapper-class",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Threading",id:"threading",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Security",id:"security",level:3},{value:"Performance",id:"performance",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Tips",id:"debug-tips",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ios-integration",children:"iOS Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Integrate Olocus Protocol into iOS applications using Swift or Objective-C through the C FFI interface. This guide covers native iOS features including Secure Enclave, App Attestation, and Core Location integration."}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Xcode 14.0 or later"}),"\n",(0,r.jsx)(n.li,{children:"iOS 13.0+ deployment target"}),"\n",(0,r.jsx)(n.li,{children:"Swift 5.5+ or Objective-C"}),"\n",(0,r.jsx)(n.li,{children:"Rust toolchain for building the library"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.h3,{id:"option-1-pre-built-framework",children:"Option 1: Pre-built Framework"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Download the pre-built ",(0,r.jsx)(n.code,{children:"OlocusFFI.xcframework"})," from releases"]}),"\n",(0,r.jsx)(n.li,{children:"Drag into your Xcode project"}),"\n",(0,r.jsx)(n.li,{children:'Add to your target\'s "Frameworks, Libraries, and Embedded Content"'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"option-2-build-from-source",children:"Option 2: Build from Source"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Install Rust targets\nrustup target add aarch64-apple-ios\nrustup target add x86_64-apple-ios\nrustup target add aarch64-apple-ios-sim\n\n# Build universal library\ncd olocus-protocol\ncargo build -p olocus-ffi --release --target aarch64-apple-ios\ncargo build -p olocus-ffi --release --target x86_64-apple-ios\ncargo build -p olocus-ffi --release --target aarch64-apple-ios-sim\n\n# Create XCFramework\nxcodebuild -create-xcframework \\\n  -library target/aarch64-apple-ios/release/libolocus_ffi.a \\\n  -headers extensions/olocus-ffi/include/ \\\n  -library target/x86_64-apple-ios/release/libolocus_ffi.a \\\n  -headers extensions/olocus-ffi/include/ \\\n  -library target/aarch64-apple-ios-sim/release/libolocus_ffi.a \\\n  -headers extensions/olocus-ffi/include/ \\\n  -output OlocusFFI.xcframework\n"})}),"\n",(0,r.jsx)(n.h2,{id:"swift-integration",children:"Swift Integration"}),"\n",(0,r.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'import Foundation\nimport OlocusFFI\n\nclass OlocusManager {\n    private var isInitialized = false\n    \n    init() {\n        setupOlocus()\n    }\n    \n    deinit {\n        if isInitialized {\n            olocus_shutdown()\n        }\n    }\n    \n    private func setupOlocus() {\n        let config = olocus_config_create()\n        defer { olocus_config_destroy(config) }\n        \n        // Configure for iOS\n        olocus_config_set_platform_ios(config, true)\n        olocus_config_set_keychain_enabled(config, true)\n        \n        let result = olocus_init_with_config(config)\n        guard result == 0 else {\n            fatalError("Failed to initialize Olocus: \\(getLastError())")\n        }\n        \n        isInitialized = true\n    }\n    \n    private func getLastError() -> String {\n        guard let cMessage = olocus_get_last_error_message() else {\n            return "Unknown error"\n        }\n        defer { olocus_free_string(UnsafeMutablePointer(mutating: cMessage)) }\n        return String(cString: cMessage)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-management-with-secure-enclave",children:"Key Management with Secure Enclave"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'import CryptoKit\nimport LocalAuthentication\n\nclass SecureKeyManager {\n    private let keychainService = "com.yourapp.olocus"\n    private let keyTag = "olocus-signing-key"\n    \n    // Generate key in Secure Enclave\n    func generateSecureKey() throws -> Data {\n        let access = SecAccessControlCreateWithFlags(\n            kCFAllocatorDefault,\n            kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            [.privateKeyUsage, .biometryAny],\n            nil\n        )!\n        \n        let attributes: [String: Any] = [\n            kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,\n            kSecAttrKeySizeInBits as String: 256,\n            kSecAttrTokenID as String: kSecAttrTokenIDSecureEnclave,\n            kSecPrivateKeyAttrs as String: [\n                kSecAttrIsPermanent as String: true,\n                kSecAttrApplicationTag as String: keyTag.data(using: .utf8)!,\n                kSecAttrAccessControl as String: access\n            ]\n        ]\n        \n        var error: Unmanaged<CFError>?\n        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {\n            throw error!.takeRetainedValue() as Error\n        }\n        \n        // Convert to Ed25519 format for Olocus\n        return try convertToEd25519(secureEnclaveKey: privateKey)\n    }\n    \n    // Load existing key from Keychain\n    func loadExistingKey() throws -> Data? {\n        let query: [String: Any] = [\n            kSecClass as String: kSecClassKey,\n            kSecAttrApplicationTag as String: keyTag.data(using: .utf8)!,\n            kSecReturnRef as String: true,\n            kSecMatchLimit as String: kSecMatchLimitOne\n        ]\n        \n        var result: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &result)\n        \n        guard status == errSecSuccess else {\n            if status == errSecItemNotFound {\n                return nil\n            }\n            throw KeychainError.loadFailed(status)\n        }\n        \n        let privateKey = result as! SecKey\n        return try convertToEd25519(secureEnclaveKey: privateKey)\n    }\n    \n    // Sign with biometric authentication\n    func signWithBiometrics(data: Data) async throws -> Data {\n        let context = LAContext()\n        let reason = "Sign Olocus block with biometric authentication"\n        \n        try await context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason)\n        \n        // Load key and sign\n        guard let keyData = try loadExistingKey() else {\n            throw KeychainError.keyNotFound\n        }\n        \n        return try signData(data, with: keyData)\n    }\n    \n    private func convertToEd25519(secureEnclaveKey: SecKey) throws -> Data {\n        // Convert Secure Enclave P-256 key to Ed25519 format\n        // Implementation depends on your key derivation strategy\n        // This is a simplified example\n        guard let keyData = SecKeyCopyExternalRepresentation(secureEnclaveKey, nil) as Data? else {\n            throw KeychainError.conversionFailed\n        }\n        \n        // Derive Ed25519 key using HKDF\n        var derivedKey = Data(count: 32)\n        derivedKey.withUnsafeMutableBytes { buffer in\n            keyData.withUnsafeBytes { keyBytes in\n                let salt = "olocus-ed25519".data(using: .utf8)!\n                let info = "key-derivation".data(using: .utf8)!\n                \n                salt.withUnsafeBytes { saltBytes in\n                    info.withUnsafeBytes { infoBytes in\n                        olocus_hkdf_derive(\n                            keyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            keyData.count,\n                            saltBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            salt.count,\n                            infoBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            info.count,\n                            buffer.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            32\n                        )\n                    }\n                }\n            }\n        }\n        \n        return derivedKey\n    }\n    \n    private func signData(_ data: Data, with key: Data) throws -> Data {\n        var signature = Data(count: 64)\n        \n        let keypair = key.withUnsafeBytes { keyBytes in\n            olocus_keypair_from_bytes(keyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self))\n        }\n        defer { olocus_keypair_destroy(keypair) }\n        \n        signature.withUnsafeMutableBytes { sigBytes in\n            data.withUnsafeBytes { dataBytes in\n                olocus_sign(\n                    keypair,\n                    dataBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                    data.count,\n                    sigBytes.baseAddress?.assumingMemoryBound(to: UInt8.self)\n                )\n            }\n        }\n        \n        return signature\n    }\n}\n\nenum KeychainError: Error {\n    case loadFailed(OSStatus)\n    case keyNotFound\n    case conversionFailed\n    case signatureFailed\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"app-attestation-integration",children:"App Attestation Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:"import DeviceCheck\n\nclass AppAttestationManager {\n    private let appAttest = DCAppAttestService.shared\n    \n    func generateAttestationBlock() async throws -> OlocusBlock {\n        // Check if App Attest is supported\n        guard appAttest.isSupported else {\n            throw AttestationError.notSupported\n        }\n        \n        // Generate key\n        let keyId = try await appAttest.generateKey()\n        \n        // Create challenge\n        let challenge = generateChallenge()\n        \n        // Get attestation\n        let attestation = try await appAttest.attestKey(keyId, clientDataHash: challenge)\n        \n        // Create Olocus block with attestation payload\n        let payload = AttestationPayload(\n            keyId: keyId,\n            attestation: attestation,\n            challenge: challenge,\n            bundleId: Bundle.main.bundleIdentifier!,\n            timestamp: Date().timeIntervalSince1970\n        )\n        \n        return try createBlockWithPayload(payload)\n    }\n    \n    func assertWithCounter(keyId: String, counter: UInt32) async throws -> Data {\n        let clientData = AssertionClientData(\n            challenge: generateChallenge(),\n            counter: counter,\n            bundleId: Bundle.main.bundleIdentifier!\n        )\n        \n        let clientDataHash = SHA256.hash(data: try JSONEncoder().encode(clientData))\n        let assertion = try await appAttest.generateAssertion(keyId, clientDataHash: Data(clientDataHash))\n        \n        return assertion\n    }\n    \n    private func generateChallenge() -> Data {\n        var challenge = Data(count: 32)\n        challenge.withUnsafeMutableBytes { buffer in\n            olocus_random_bytes(\n                buffer.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                32\n            )\n        }\n        return challenge\n    }\n    \n    private func createBlockWithPayload(_ payload: AttestationPayload) throws -> OlocusBlock {\n        let payloadData = try JSONEncoder().encode(payload)\n        \n        // Use secure key for signing\n        let keyManager = SecureKeyManager()\n        let signingKey = try keyManager.loadExistingKey() ?? keyManager.generateSecureKey()\n        \n        let block = payloadData.withUnsafeBytes { payloadBytes in\n            signingKey.withUnsafeBytes { keyBytes in\n                olocus_block_create_genesis(\n                    Int64(Date().timeIntervalSince1970),\n                    payloadBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                    payloadData.count,\n                    0x0104, // App Attestation payload type\n                    keyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self)\n                )\n            }\n        }\n        \n        guard block != nil else {\n            throw AttestationError.blockCreationFailed\n        }\n        \n        return OlocusBlock(cBlock: block!)\n    }\n}\n\nstruct AttestationPayload: Codable {\n    let keyId: String\n    let attestation: Data\n    let challenge: Data\n    let bundleId: String\n    let timestamp: TimeInterval\n}\n\nstruct AssertionClientData: Codable {\n    let challenge: Data\n    let counter: UInt32\n    let bundleId: String\n}\n\nenum AttestationError: Error {\n    case notSupported\n    case blockCreationFailed\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"location-integration",children:"Location Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'import CoreLocation\nimport MapKit\n\nclass LocationChainManager: NSObject, CLLocationManagerDelegate {\n    private let locationManager = CLLocationManager()\n    private let olocusManager = OlocusManager()\n    private var chain: OpaquePointer?\n    \n    override init() {\n        super.init()\n        setupLocationManager()\n        setupChain()\n    }\n    \n    deinit {\n        if let chain = chain {\n            olocus_chain_destroy(chain)\n        }\n    }\n    \n    private func setupLocationManager() {\n        locationManager.delegate = self\n        locationManager.desiredAccuracy = kCLLocationAccuracyBest\n        locationManager.requestWhenInUseAuthorization()\n    }\n    \n    private func setupChain() {\n        chain = olocus_chain_create()\n    }\n    \n    func startLocationTracking() {\n        guard CLLocationManager.locationServicesEnabled() else {\n            print("Location services not enabled")\n            return\n        }\n        \n        locationManager.startUpdatingLocation()\n        locationManager.startMonitoringSignificantLocationChanges()\n    }\n    \n    // MARK: - CLLocationManagerDelegate\n    \n    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n        for location in locations {\n            addLocationBlock(location)\n        }\n    }\n    \n    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {\n        print("Location error: \\(error.localizedDescription)")\n    }\n    \n    private func addLocationBlock(_ location: CLLocation) {\n        let payload = LocationPayload(\n            latitude: location.coordinate.latitude,\n            longitude: location.coordinate.longitude,\n            altitude: location.altitude,\n            horizontalAccuracy: location.horizontalAccuracy,\n            verticalAccuracy: location.verticalAccuracy,\n            course: location.course,\n            speed: location.speed,\n            timestamp: location.timestamp.timeIntervalSince1970\n        )\n        \n        do {\n            let block = try createLocationBlock(payload)\n            addBlockToChain(block)\n        } catch {\n            print("Failed to create location block: \\(error)")\n        }\n    }\n    \n    private func createLocationBlock(_ payload: LocationPayload) throws -> OpaquePointer {\n        let payloadData = try JSONEncoder().encode(payload)\n        let keyManager = SecureKeyManager()\n        let signingKey = try keyManager.loadExistingKey() ?? keyManager.generateSecureKey()\n        \n        // Get previous block hash if chain exists\n        var prevHash = Data(count: 32)\n        let chainLength = olocus_chain_get_length(chain)\n        \n        if chainLength > 0 {\n            let lastBlock = olocus_chain_get_last_block(chain)\n            prevHash.withUnsafeMutableBytes { hashBytes in\n                olocus_block_get_hash(\n                    lastBlock,\n                    hashBytes.baseAddress?.assumingMemoryBound(to: UInt8.self)\n                )\n            }\n        }\n        \n        let block = payloadData.withUnsafeBytes { payloadBytes in\n            signingKey.withUnsafeBytes { keyBytes in\n                prevHash.withUnsafeBytes { hashBytes in\n                    if chainLength == 0 {\n                        // Genesis block\n                        return olocus_block_create_genesis(\n                            Int64(payload.timestamp),\n                            payloadBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            payloadData.count,\n                            0x0200, // Location payload type\n                            keyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self)\n                        )\n                    } else {\n                        // Regular block\n                        return olocus_block_create(\n                            chainLength,\n                            Int64(payload.timestamp),\n                            hashBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            payloadBytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                            payloadData.count,\n                            0x0200, // Location payload type\n                            keyBytes.baseAddress?.assumingMemoryBound(to: UInt8.self)\n                        )\n                    }\n                }\n            }\n        }\n        \n        guard block != nil else {\n            throw LocationError.blockCreationFailed\n        }\n        \n        return block!\n    }\n    \n    private func addBlockToChain(_ block: OpaquePointer) {\n        let result = olocus_chain_add_block(chain, block)\n        if result != 0 {\n            let error = String(cString: olocus_get_last_error_message()!)\n            print("Failed to add block to chain: \\(error)")\n            olocus_free_string(UnsafeMutablePointer(mutating: olocus_get_last_error_message()!))\n        }\n        \n        // Clean up block (chain takes ownership)\n        // olocus_block_destroy(block) // Don\'t call this if chain owns the block\n    }\n    \n    func exportChain() -> Data? {\n        guard let chain = chain else { return nil }\n        \n        let wireFormat = olocus_wire_format_json()\n        let buffer = olocus_chain_to_wire_format(chain, wireFormat)\n        defer { olocus_byte_buffer_free(UnsafeMutablePointer(mutating: &buffer)) }\n        \n        return Data(bytes: buffer.data, count: buffer.len)\n    }\n}\n\nstruct LocationPayload: Codable {\n    let latitude: CLLocationDegrees\n    let longitude: CLLocationDegrees\n    let altitude: CLLocationDistance\n    let horizontalAccuracy: CLLocationAccuracy\n    let verticalAccuracy: CLLocationAccuracy\n    let course: CLLocationDirection\n    let speed: CLLocationSpeed\n    let timestamp: TimeInterval\n}\n\nenum LocationError: Error {\n    case blockCreationFailed\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"wire-format-integration",children:"Wire Format Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'class WireFormatManager {\n    // Create different wire formats\n    func createJSONFormat() -> FFIWireFormat {\n        return olocus_wire_format_json()\n    }\n    \n    func createCompressedFormat() -> FFIWireFormat {\n        return olocus_wire_format_new(\n            FFIEncodingFormat_Json,\n            FFICompressionMethod_Zstd\n        )\n    }\n    \n    func createMessagePackFormat() -> FFIWireFormat {\n        return olocus_wire_format_msgpack()\n    }\n    \n    // Serialize block to different formats\n    func serializeBlock(_ block: OpaquePointer, format: FFIWireFormat) -> Data? {\n        let buffer = olocus_block_to_wire_format(block, format)\n        defer { olocus_byte_buffer_free(UnsafeMutablePointer(mutating: &buffer)) }\n        \n        guard buffer.data != nil else { return nil }\n        return Data(bytes: buffer.data, count: buffer.len)\n    }\n    \n    // Deserialize block from data\n    func deserializeBlock(_ data: Data, format: FFIWireFormat) -> OpaquePointer? {\n        return data.withUnsafeBytes { bytes in\n            olocus_block_from_wire_format(\n                bytes.baseAddress?.assumingMemoryBound(to: UInt8.self),\n                data.count,\n                format\n            )\n        }\n    }\n    \n    // Get content type for HTTP headers\n    func getContentType(_ format: FFIWireFormat) -> String {\n        guard let cString = olocus_wire_format_content_type(format) else {\n            return "application/octet-stream"\n        }\n        defer { olocus_free_string(UnsafeMutablePointer(mutating: cString)) }\n        return String(cString: cString)\n    }\n    \n    // Parse content type to create format\n    func formatFromContentType(_ contentType: String) -> FFIWireFormat? {\n        var format = FFIWireFormat()\n        let result = contentType.withCString { cString in\n            olocus_wire_format_from_content_type(cString, &format)\n        }\n        \n        return result == 0 ? format : nil\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"objective-c-integration",children:"Objective-C Integration"}),"\n",(0,r.jsx)(n.h3,{id:"wrapper-class",children:"Wrapper Class"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-objc",children:'// OlocusManager.h\n#import <Foundation/Foundation.h>\n#import "olocus_ffi.h"\n\nNS_ASSUME_NONNULL_BEGIN\n\n@interface OlocusManager : NSObject\n\n@property (nonatomic, readonly, getter=isInitialized) BOOL initialized;\n\n- (instancetype)init;\n- (BOOL)initializeWithError:(NSError **)error;\n- (void)shutdown;\n\n- (NSData * _Nullable)generateKeyPair;\n- (NSData * _Nullable)createGenesisBlockWithPayload:(NSData *)payload\n                                         payloadType:(uint32_t)payloadType\n                                          signingKey:(NSData *)signingKey\n                                               error:(NSError **)error;\n\n- (BOOL)verifyBlock:(FFIBlock *)block error:(NSError **)error;\n- (NSString *)lastErrorMessage;\n\n@end\n\nNS_ASSUME_NONNULL_END\n\n// OlocusManager.m\n#import "OlocusManager.h"\n\nstatic NSString * const OlocusErrorDomain = @"OlocusErrorDomain";\n\n@implementation OlocusManager\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _initialized = NO;\n    }\n    return self;\n}\n\n- (void)dealloc {\n    if (_initialized) {\n        olocus_shutdown();\n    }\n}\n\n- (BOOL)initializeWithError:(NSError **)error {\n    if (_initialized) {\n        return YES;\n    }\n    \n    FFIConfig *config = olocus_config_create();\n    olocus_config_set_platform_ios(config, true);\n    olocus_config_set_keychain_enabled(config, true);\n    \n    int result = olocus_init_with_config(config);\n    olocus_config_destroy(config);\n    \n    if (result != 0) {\n        if (error) {\n            NSString *message = [self lastErrorMessage];\n            *error = [NSError errorWithDomain:OlocusErrorDomain\n                                         code:result\n                                     userInfo:@{NSLocalizedDescriptionKey: message}];\n        }\n        return NO;\n    }\n    \n    _initialized = YES;\n    return YES;\n}\n\n- (void)shutdown {\n    if (_initialized) {\n        olocus_shutdown();\n        _initialized = NO;\n    }\n}\n\n- (NSData *)generateKeyPair {\n    FFIKeyPair *keypair = olocus_keypair_generate();\n    if (!keypair) {\n        return nil;\n    }\n    \n    uint8_t privateKey[32];\n    olocus_keypair_get_private_key(keypair, privateKey);\n    \n    NSData *keyData = [NSData dataWithBytes:privateKey length:32];\n    \n    // Securely clear the key\n    memset_s(privateKey, 32, 0, 32);\n    olocus_keypair_destroy(keypair);\n    \n    return keyData;\n}\n\n- (NSData *)createGenesisBlockWithPayload:(NSData *)payload\n                              payloadType:(uint32_t)payloadType\n                               signingKey:(NSData *)signingKey\n                                    error:(NSError **)error {\n    \n    if (signingKey.length != 32) {\n        if (error) {\n            *error = [NSError errorWithDomain:OlocusErrorDomain\n                                         code:104  // InvalidArgument\n                                     userInfo:@{NSLocalizedDescriptionKey: @"Signing key must be 32 bytes"}];\n        }\n        return nil;\n    }\n    \n    int64_t timestamp = (int64_t)[[NSDate date] timeIntervalSince1970];\n    \n    FFIBlock *block = olocus_block_create_genesis(\n        timestamp,\n        payload.bytes,\n        payload.length,\n        payloadType,\n        signingKey.bytes\n    );\n    \n    if (!block) {\n        if (error) {\n            NSString *message = [self lastErrorMessage];\n            *error = [NSError errorWithDomain:OlocusErrorDomain\n                                         code:108  // OperationFailed\n                                     userInfo:@{NSLocalizedDescriptionKey: message}];\n        }\n        return nil;\n    }\n    \n    // Serialize to data\n    FFIWireFormat format = olocus_wire_format_binary();\n    FFIByteBuffer buffer = olocus_block_to_wire_format(block, format);\n    \n    NSData *blockData = [NSData dataWithBytes:buffer.data length:buffer.len];\n    \n    olocus_byte_buffer_free(&buffer);\n    olocus_block_destroy(block);\n    \n    return blockData;\n}\n\n- (BOOL)verifyBlock:(FFIBlock *)block error:(NSError **)error {\n    int result = olocus_block_verify(block);\n    \n    if (result != 0) {\n        if (error) {\n            NSString *message = [self lastErrorMessage];\n            *error = [NSError errorWithDomain:OlocusErrorDomain\n                                         code:result\n                                     userInfo:@{NSLocalizedDescriptionKey: message}];\n        }\n        return NO;\n    }\n    \n    return YES;\n}\n\n- (NSString *)lastErrorMessage {\n    const char *cMessage = olocus_get_last_error_message();\n    if (!cMessage) {\n        return @"Unknown error";\n    }\n    \n    NSString *message = [NSString stringWithUTF8String:cMessage];\n    olocus_free_string((char *)cMessage);\n    return message;\n}\n\n@end\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"threading",children:"Threading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'class ThreadSafeOlocusManager {\n    private let queue = DispatchQueue(label: "com.yourapp.olocus", qos: .utility)\n    private var chain: OpaquePointer?\n    private let chainLock = NSLock()\n    \n    func addBlockAsync(_ block: OpaquePointer, completion: @escaping (Result<Void, Error>) -> Void) {\n        queue.async { [weak self] in\n            guard let self = self else { return }\n            \n            self.chainLock.lock()\n            defer { self.chainLock.unlock() }\n            \n            let result = olocus_chain_add_block(self.chain, block)\n            \n            DispatchQueue.main.async {\n                if result == 0 {\n                    completion(.success(()))\n                } else {\n                    let error = String(cString: olocus_get_last_error_message()!)\n                    completion(.failure(OlocusError.operationFailed(error)))\n                }\n            }\n        }\n    }\n    \n    func getChainLengthAsync(completion: @escaping (Int) -> Void) {\n        queue.async { [weak self] in\n            guard let self = self else { return }\n            \n            self.chainLock.lock()\n            let length = Int(olocus_chain_get_length(self.chain))\n            self.chainLock.unlock()\n            \n            DispatchQueue.main.async {\n                completion(length)\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:"class MemoryOptimizedManager {\n    // Use autoreleasepool for batch operations\n    func processManyBlocks(_ payloads: [Data]) {\n        autoreleasepool {\n            for payload in payloads {\n                autoreleasepool {\n                    processBlock(payload)\n                }\n            }\n        }\n    }\n    \n    // Reuse buffers\n    private var reuseBuffer = Data(count: 1024)\n    \n    func processBlock(_ payload: Data) {\n        // Reuse buffer if possible\n        if reuseBuffer.count < payload.count {\n            reuseBuffer = Data(count: payload.count * 2)\n        }\n        \n        // Process...\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'import XCTest\n@testable import YourApp\n\nclass OlocusTests: XCTestCase {\n    var manager: OlocusManager!\n    \n    override func setUp() {\n        super.setUp()\n        manager = OlocusManager()\n    }\n    \n    override func tearDown() {\n        manager = nil\n        super.tearDown()\n    }\n    \n    func testInitialization() {\n        XCTAssertTrue(manager.isInitialized)\n    }\n    \n    func testKeyGeneration() {\n        let keyData = manager.generateKeyPair()\n        XCTAssertNotNil(keyData)\n        XCTAssertEqual(keyData?.count, 32)\n    }\n    \n    func testBlockCreation() {\n        let payload = "Test payload".data(using: .utf8)!\n        let keyData = manager.generateKeyPair()!\n        \n        let blockData = manager.createGenesisBlock(\n            payload: payload,\n            payloadType: 0,\n            signingKey: keyData\n        )\n        \n        XCTAssertNotNil(blockData)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-swift",children:'class LocationIntegrationTests: XCTestCase {\n    func testLocationBlockCreation() {\n        let locationManager = LocationChainManager()\n        \n        let expectation = self.expectation(description: "Location block created")\n        \n        // Simulate location update\n        let location = CLLocation(\n            coordinate: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),\n            altitude: 100.0,\n            horizontalAccuracy: 5.0,\n            verticalAccuracy: 10.0,\n            timestamp: Date()\n        )\n        \n        locationManager.addLocationBlock(location) { result in\n            switch result {\n            case .success:\n                expectation.fulfill()\n            case .failure(let error):\n                XCTFail("Failed to create location block: \\(error)")\n            }\n        }\n        \n        waitForExpectations(timeout: 10.0)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always use Secure Enclave"})," for key storage when available"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement biometric authentication"})," for critical operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate all inputs"})," before passing to FFI functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use App Attestation"})," for integrity verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clear sensitive memory"})," after use"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use background queues"})," for heavy operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper locking"})," for thread safety"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reuse buffers"})," where possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use autoreleasepool"})," for batch operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profile memory usage"})," regularly"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always check return codes"})," from FFI functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provide meaningful error messages"})," to users"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Log errors"})," for debugging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement retry logic"})," for transient failures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle network errors"})," gracefully"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Library not found"}),": Ensure XCFramework is properly embedded"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keychain access denied"}),": Check entitlements and permissions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"App Attest unavailable"}),": Verify device support and configuration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Location access denied"}),": Request appropriate permissions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory leaks"}),": Use Instruments to profile and fix"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"debug-tips",children:"Debug Tips"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enable debug logging"})," in development builds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use breakpoints"})," in Swift/Objective-C code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check error messages"})," from FFI functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate inputs"})," before FFI calls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test on different devices"})," and iOS versions"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(6540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);