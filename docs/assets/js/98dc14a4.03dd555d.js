"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5107],{5419:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/privacy/zero-knowledge","title":"Zero Knowledge","description":"The Privacy extension provides zero-knowledge proof implementations for privacy-preserving attestations and verifications without revealing sensitive information.","source":"@site/docs/extensions/privacy/zero-knowledge.md","sourceDirName":"extensions/privacy","slug":"/extensions/privacy/zero-knowledge","permalink":"/docs/extensions/privacy/zero-knowledge","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/privacy/zero-knowledge.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"zero-knowledge","title":"Zero Knowledge","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Threshold Signatures","permalink":"/docs/extensions/privacy/threshold-signatures"},"next":{"title":"Storage Backends","permalink":"/docs/extensions/infrastructure/storage"}}');var r=t(4848),o=t(8453);const s={id:"zero-knowledge",title:"Zero Knowledge",sidebar_position:1},a="Zero Knowledge Proofs",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Zero-Knowledge Proof Primitives",id:"zero-knowledge-proof-primitives",level:2},{value:"Core ZKP Types",id:"core-zkp-types",level:3},{value:"Sigma Protocols",id:"sigma-protocols",level:3},{value:"Location Privacy Proofs",id:"location-privacy-proofs",level:2},{value:"Geographic Region Proofs",id:"geographic-region-proofs",level:3},{value:"Temporal Privacy Proofs",id:"temporal-privacy-proofs",level:3},{value:"Range Proofs",id:"range-proofs",level:2},{value:"Bulletproofs Implementation",id:"bulletproofs-implementation",level:3},{value:"Set Membership Proofs",id:"set-membership-proofs",level:3},{value:"Anonymous Credentials",id:"anonymous-credentials",level:2},{value:"BBS+ Signatures",id:"bbs-signatures",level:3},{value:"Nullifiers and Anti-Replay",id:"nullifiers-and-anti-replay",level:2},{value:"Nullifier Generation",id:"nullifier-generation",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Privacy-Preserving Location Attestation",id:"privacy-preserving-location-attestation",level:3},{value:"Anonymous Credential Presentation",id:"anonymous-credential-presentation",level:3},{value:"Performance &amp; Security Considerations",id:"performance--security-considerations",level:2},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Security Properties",id:"security-properties",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"zero-knowledge-proofs",children:"Zero Knowledge Proofs"})}),"\n",(0,r.jsx)(n.p,{children:"The Privacy extension provides zero-knowledge proof implementations for privacy-preserving attestations and verifications without revealing sensitive information."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Zero-knowledge proofs enable proving knowledge of information without revealing the information itself. The Olocus Protocol integrates ZKP techniques for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Privacy-Preserving Attestations"}),": Prove location presence without revealing exact coordinates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Anonymous Credentials"}),": Verify claims without revealing identity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Range Proofs"}),": Prove values are within ranges without revealing exact values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set Membership"}),": Prove membership in groups without revealing which group"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Threshold Proofs"}),": Prove aggregate properties without revealing individual contributions"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::*;\nuse olocus_core::measure::*;\n\n// Create a ZK proof that you were at a location without revealing the exact coordinates\nlet location_proof = LocationZKProof::new()\n    .location_within_radius(\n        center: Coordinate::new(37.7749, -122.4194), // San Francisco\n        radius: 1000.0, // 1km radius\n        actual_location: private_location,\n        witness: location_witness\n    )\n    .generate()?;\n\n// Verify the proof without learning the actual location\nlet is_valid = location_proof.verify(&public_parameters)?;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"zero-knowledge-proof-primitives",children:"Zero-Knowledge Proof Primitives"}),"\n",(0,r.jsx)(n.h3,{id:"core-zkp-types",children:"Core ZKP Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::primitives::*;\n\n#[derive(Debug, Clone)]\npub struct ZKProof {\n    pub proof_type: ZKProofType,\n    pub commitment: Commitment,\n    pub challenge: Challenge,\n    pub response: Response,\n    pub public_parameters: PublicParameters,\n    pub nullifier: Option<Nullifier>,  // Prevents double-spending/double-use\n}\n\n#[derive(Debug, Clone)]\npub enum ZKProofType {\n    LocationPresence {\n        region: GeographicRegion,\n        time_window: TimeWindow,\n    },\n    RangeProof {\n        range: (i64, i64),           // (min, max) values\n        bit_length: usize,           // Bit length of the value\n    },\n    SetMembership {\n        set_size: usize,\n        merkle_depth: usize,\n    },\n    ThresholdProof {\n        threshold: u64,\n        participant_count: usize,\n    },\n    AnonymousCredential {\n        credential_schema: CredentialSchema,\n        revealed_attributes: Vec<AttributeIndex>,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct Commitment {\n    pub value: Vec<u8>,              // Pedersen or other commitment\n    pub randomness_commitment: Vec<u8>, // Commitment to randomness\n}\n\n#[derive(Debug, Clone)]\npub struct Challenge {\n    pub value: Vec<u8>,              // Fiat-Shamir challenge\n    pub transcript_hash: Vec<u8>,    // Hash of all previous messages\n}\n\n#[derive(Debug, Clone)]  \npub struct Response {\n    pub value_response: Vec<u8>,     // Response for committed value\n    pub randomness_response: Vec<u8>, // Response for randomness\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sigma-protocols",children:"Sigma Protocols"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_privacy::zkp::sigma::*;\n\npub trait SigmaProtocol {\n    type Statement;\n    type Witness;\n    type Commitment;\n    type Challenge;\n    type Response;\n    \n    fn commit(&self, witness: &Self::Witness) -> (Self::Commitment, CommitmentSecret);\n    fn challenge(&self, statement: &Self::Statement, commitment: &Self::Commitment) -> Self::Challenge;\n    fn respond(&self, challenge: &Self::Challenge, witness: &Self::Witness, secret: &CommitmentSecret) -> Self::Response;\n    fn verify(&self, statement: &Self::Statement, commitment: &Self::Commitment, challenge: &Self::Challenge, response: &Self::Response) -> bool;\n}\n\n// Schnorr proof of knowledge of discrete log\npub struct SchnorrProof {\n    base: GroupElement,\n    generator: GroupElement,\n}\n\nimpl SigmaProtocol for SchnorrProof {\n    type Statement = GroupElement;  // y = g^x\n    type Witness = Scalar;          // x\n    type Commitment = GroupElement; // r = g^v\n    type Challenge = Scalar;        // c\n    type Response = Scalar;         // z = v + cx\n    \n    fn commit(&self, witness: &Self::Witness) -> (Self::Commitment, CommitmentSecret) {\n        let v = Scalar::random();\n        let r = self.generator * v;\n        (r, CommitmentSecret::Scalar(v))\n    }\n    \n    fn challenge(&self, statement: &Self::Statement, commitment: &Self::Commitment) -> Self::Challenge {\n        // Fiat-Shamir transform\n        let mut hasher = Sha256::new();\n        hasher.update(&self.generator.to_bytes());\n        hasher.update(&statement.to_bytes());\n        hasher.update(&commitment.to_bytes());\n        \n        Scalar::from_hash(hasher.finalize().as_slice())\n    }\n    \n    fn respond(&self, challenge: &Self::Challenge, witness: &Self::Witness, secret: &CommitmentSecret) -> Self::Response {\n        let v = match secret {\n            CommitmentSecret::Scalar(v) => v,\n            _ => panic!("Invalid commitment secret type"),\n        };\n        \n        // z = v + cx\n        v + (challenge * witness)\n    }\n    \n    fn verify(&self, statement: &Self::Statement, commitment: &Self::Commitment, challenge: &Self::Challenge, response: &Self::Response) -> bool {\n        // Check that g^z = r * y^c\n        let left = self.generator * response;\n        let right = commitment + (statement * challenge);\n        left == right\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"location-privacy-proofs",children:"Location Privacy Proofs"}),"\n",(0,r.jsx)(n.h3,{id:"geographic-region-proofs",children:"Geographic Region Proofs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::location::*;\n\npub struct LocationZKProof {\n    proof_system: ProofSystem,\n    public_parameters: LocationPublicParameters,\n}\n\n#[derive(Debug, Clone)]\npub struct LocationPublicParameters {\n    pub region_commitment_key: CommitmentKey,\n    pub coordinate_range: CoordinateRange,\n    pub precision_bits: usize,          // Fixed-point precision\n    pub proof_security_level: usize,    // Security parameter\n}\n\n#[derive(Debug, Clone)]\npub enum GeographicRegion {\n    Circle {\n        center: Coordinate,\n        radius: f64,                    // meters\n    },\n    Rectangle {\n        northwest: Coordinate,\n        southeast: Coordinate,\n    },\n    Polygon {\n        vertices: Vec<Coordinate>,\n    },\n    PostalCode {\n        code: String,\n        precision: PostalCodePrecision, // ZIP, ZIP+4, etc.\n    },\n}\n\nimpl LocationZKProof {\n    pub fn prove_presence_in_region(\n        &self,\n        actual_location: &Coordinate,\n        region: &GeographicRegion,\n        time_window: &TimeWindow,\n        witness: &LocationWitness\n    ) -> Result<ZKProof> {\n        match region {\n            GeographicRegion::Circle { center, radius } => {\n                self.prove_within_circle(actual_location, center, *radius, witness)\n            },\n            GeographicRegion::Rectangle { northwest, southeast } => {\n                self.prove_within_rectangle(actual_location, northwest, southeast, witness)\n            },\n            GeographicRegion::Polygon { vertices } => {\n                self.prove_within_polygon(actual_location, vertices, witness)\n            },\n            GeographicRegion::PostalCode { code, precision } => {\n                self.prove_within_postal_code(actual_location, code, *precision, witness)\n            }\n        }\n    }\n    \n    fn prove_within_circle(\n        &self,\n        location: &Coordinate,\n        center: &Coordinate,\n        radius: f64,\n        witness: &LocationWitness\n    ) -> Result<ZKProof> {\n        // Convert to fixed-point coordinates\n        let loc_x = location.latitude;\n        let loc_y = location.longitude;\n        let center_x = center.latitude;\n        let center_y = center.longitude;\n        \n        // Calculate distance squared in fixed-point arithmetic\n        let dx = loc_x - center_x;\n        let dy = loc_y - center_y;\n        let distance_sq = dx * dx + dy * dy;\n        \n        // Convert radius to fixed-point distance squared\n        let radius_fixed = (radius * 10_000_000.0) as i64; // Convert to fixed-point meters\n        let radius_sq = radius_fixed * radius_fixed;\n        \n        // Prove that distance_sq <= radius_sq using range proof\n        let range_proof = RangeProof::new(\n            distance_sq as u64,\n            0,\n            radius_sq as u64,\n            64, // bit length\n            witness\n        )?;\n        \n        Ok(ZKProof {\n            proof_type: ZKProofType::LocationPresence {\n                region: GeographicRegion::Circle {\n                    center: center.clone(),\n                    radius,\n                },\n                time_window: witness.time_window.clone(),\n            },\n            commitment: range_proof.commitment,\n            challenge: range_proof.challenge,\n            response: range_proof.response,\n            public_parameters: self.public_parameters.clone().into(),\n            nullifier: Some(witness.generate_nullifier()?),\n        })\n    }\n    \n    fn prove_within_polygon(\n        &self,\n        location: &Coordinate,\n        vertices: &[Coordinate],\n        witness: &LocationWitness\n    ) -> Result<ZKProof> {\n        // Use point-in-polygon algorithm with ZK constraints\n        // Ray casting algorithm adapted for zero-knowledge proofs\n        \n        let point = (location.latitude, location.longitude);\n        let mut inside_constraints = Vec::new();\n        \n        for i in 0..vertices.len() {\n            let j = (i + 1) % vertices.len();\n            let vi = (vertices[i].latitude, vertices[i].longitude);\n            let vj = (vertices[j].latitude, vertices[j].longitude);\n            \n            // Create constraint for ray intersection\n            let intersection_constraint = self.create_ray_intersection_constraint(\n                &point, &vi, &vj\n            )?;\n            \n            inside_constraints.push(intersection_constraint);\n        }\n        \n        // Prove that odd number of intersections (point inside polygon)\n        let parity_proof = ParityProof::new(&inside_constraints, witness)?;\n        \n        Ok(ZKProof {\n            proof_type: ZKProofType::LocationPresence {\n                region: GeographicRegion::Polygon {\n                    vertices: vertices.to_vec(),\n                },\n                time_window: witness.time_window.clone(),\n            },\n            commitment: parity_proof.commitment,\n            challenge: parity_proof.challenge,\n            response: parity_proof.response,\n            public_parameters: self.public_parameters.clone().into(),\n            nullifier: Some(witness.generate_nullifier()?),\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"temporal-privacy-proofs",children:"Temporal Privacy Proofs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::temporal::*;\n\npub struct TemporalZKProof {\n    proof_system: ProofSystem,\n}\n\n#[derive(Debug, Clone)]\npub struct TimeWindow {\n    pub start: SystemTime,\n    pub end: SystemTime,\n    pub granularity: TemporalGranularity,\n}\n\n#[derive(Debug, Clone)]\npub enum TemporalGranularity {\n    Second,\n    Minute,\n    Hour,\n    Day,\n    Week,\n    Month,\n}\n\nimpl TemporalZKProof {\n    pub fn prove_time_within_window(\n        &self,\n        actual_time: SystemTime,\n        window: &TimeWindow,\n        witness: &TemporalWitness\n    ) -> Result<ZKProof> {\n        // Convert times to appropriate granularity\n        let start_ts = self.time_to_granular_timestamp(window.start, window.granularity);\n        let end_ts = self.time_to_granular_timestamp(window.end, window.granularity);\n        let actual_ts = self.time_to_granular_timestamp(actual_time, window.granularity);\n        \n        // Prove start_ts <= actual_ts <= end_ts using range proof\n        let range_proof = RangeProof::prove_in_range(\n            actual_ts,\n            start_ts,\n            end_ts,\n            64, // timestamp bit length\n            witness\n        )?;\n        \n        Ok(ZKProof {\n            proof_type: ZKProofType::LocationPresence {\n                region: GeographicRegion::Circle {\n                    center: witness.dummy_location, // Hidden actual region\n                    radius: 0.0,\n                },\n                time_window: window.clone(),\n            },\n            commitment: range_proof.commitment,\n            challenge: range_proof.challenge,\n            response: range_proof.response,\n            public_parameters: self.temporal_params.clone().into(),\n            nullifier: Some(witness.generate_temporal_nullifier()?),\n        })\n    }\n    \n    fn time_to_granular_timestamp(&self, time: SystemTime, granularity: TemporalGranularity) -> u64 {\n        let duration = time.duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default();\n        let seconds = duration.as_secs();\n        \n        match granularity {\n            TemporalGranularity::Second => seconds,\n            TemporalGranularity::Minute => seconds / 60,\n            TemporalGranularity::Hour => seconds / 3600,\n            TemporalGranularity::Day => seconds / 86400,\n            TemporalGranularity::Week => seconds / 604800,\n            TemporalGranularity::Month => seconds / 2629746, // Average month\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"range-proofs",children:"Range Proofs"}),"\n",(0,r.jsx)(n.h3,{id:"bulletproofs-implementation",children:"Bulletproofs Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_privacy::zkp::bulletproofs::*;\n\npub struct BulletproofRangeProof {\n    generators: BulletproofGenerators,\n    pc_gens: PedersenGens,\n}\n\nimpl BulletproofRangeProof {\n    pub fn prove_value_in_range(\n        &self,\n        value: u64,\n        min: u64,\n        max: u64,\n        bit_length: usize,\n        blinding: Scalar\n    ) -> Result<(Commitment, RangeProof)> {\n        // Adjust value to be relative to minimum\n        let adjusted_value = value - min;\n        let range_size = max - min + 1;\n        \n        // Ensure the range fits in the specified bit length\n        if range_size > (1 << bit_length) {\n            return Err(ZKError::RangeTooLarge {\n                range_size,\n                max_size: 1 << bit_length,\n            });\n        }\n        \n        // Create Pedersen commitment: C = value * G + blinding * H\n        let commitment = self.pc_gens.commit(Scalar::from(adjusted_value), blinding);\n        \n        // Generate bulletproof\n        let mut transcript = Transcript::new(b"olocus-range-proof");\n        \n        let (proof, _) = RangeProof::prove_single(\n            &self.generators,\n            &mut transcript,\n            adjusted_value,\n            &blinding,\n            bit_length,\n        ).map_err(|e| ZKError::ProofGenerationFailed(e.to_string()))?;\n        \n        Ok((commitment, proof))\n    }\n    \n    pub fn verify_range_proof(\n        &self,\n        commitment: &Commitment,\n        proof: &RangeProof,\n        min: u64,\n        max: u64,\n        bit_length: usize\n    ) -> Result<bool> {\n        let range_size = max - min + 1;\n        \n        if range_size > (1 << bit_length) {\n            return Ok(false);\n        }\n        \n        let mut transcript = Transcript::new(b"olocus-range-proof");\n        \n        proof.verify_single(\n            &self.generators,\n            &mut transcript,\n            commitment,\n            bit_length,\n        ).map_err(|e| ZKError::VerificationFailed(e.to_string()))?;\n        \n        Ok(true)\n    }\n    \n    // Batch range proofs for efficiency\n    pub fn prove_multiple_ranges(\n        &self,\n        values: &[u64],\n        ranges: &[(u64, u64)], // (min, max) pairs\n        bit_length: usize,\n        blindings: &[Scalar]\n    ) -> Result<(Vec<Commitment>, RangeProof)> {\n        if values.len() != ranges.len() || values.len() != blindings.len() {\n            return Err(ZKError::InvalidInputLengths);\n        }\n        \n        let mut adjusted_values = Vec::new();\n        let mut commitments = Vec::new();\n        \n        for (i, &value) in values.iter().enumerate() {\n            let (min, max) = ranges[i];\n            let adjusted_value = value - min;\n            adjusted_values.push(adjusted_value);\n            \n            let commitment = self.pc_gens.commit(Scalar::from(adjusted_value), blindings[i]);\n            commitments.push(commitment);\n        }\n        \n        let mut transcript = Transcript::new(b"olocus-batch-range-proof");\n        \n        let (proof, _) = RangeProof::prove_multiple(\n            &self.generators,\n            &mut transcript,\n            &adjusted_values,\n            blindings,\n            bit_length,\n        ).map_err(|e| ZKError::ProofGenerationFailed(e.to_string()))?;\n        \n        Ok((commitments, proof))\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"set-membership-proofs",children:"Set Membership Proofs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::set_membership::*;\n\npub struct SetMembershipProof {\n    merkle_depth: usize,\n    hasher: PoseidonHasher, // ZK-friendly hash function\n}\n\nimpl SetMembershipProof {\n    pub fn prove_membership(\n        &self,\n        element: &[u8],\n        set_merkle_root: &[u8],\n        merkle_path: &MerklePath,\n        witness: &SetWitness\n    ) -> Result<ZKProof> {\n        // Hash the element\n        let element_hash = self.hasher.hash(element);\n        \n        // Prove that we can reconstruct the merkle root from element and path\n        let mut current_hash = element_hash;\n        let mut path_constraints = Vec::new();\n        \n        for (i, sibling) in merkle_path.siblings.iter().enumerate() {\n            let is_right = merkle_path.directions[i];\n            \n            // Create constraint: if is_right then hash(sibling, current) else hash(current, sibling)\n            let constraint = MerkleConstraint {\n                left: if is_right { sibling.clone() } else { current_hash.clone() },\n                right: if is_right { current_hash.clone() } else { sibling.clone() },\n                output: self.hasher.hash(&[&current_hash, sibling].concat()),\n                direction_bit: is_right,\n            };\n            \n            path_constraints.push(constraint);\n            current_hash = constraint.output.clone();\n        }\n        \n        // Final constraint: current_hash == merkle_root\n        if current_hash != *set_merkle_root {\n            return Err(ZKError::InvalidMembershipProof);\n        }\n        \n        // Generate ZK proof for all constraints\n        let circuit = MembershipCircuit::new(path_constraints, witness);\n        let proof = circuit.generate_proof()?;\n        \n        Ok(ZKProof {\n            proof_type: ZKProofType::SetMembership {\n                set_size: 1 << self.merkle_depth,\n                merkle_depth: self.merkle_depth,\n            },\n            commitment: proof.commitment,\n            challenge: proof.challenge,\n            response: proof.response,\n            public_parameters: PublicParameters::SetMembership {\n                merkle_root: set_merkle_root.to_vec(),\n                set_size: 1 << self.merkle_depth,\n            },\n            nullifier: Some(witness.generate_nullifier(element)?),\n        })\n    }\n    \n    pub fn prove_non_membership(\n        &self,\n        element: &[u8],\n        set_merkle_root: &[u8],\n        non_membership_witness: &NonMembershipWitness\n    ) -> Result<ZKProof> {\n        // For non-membership, prove that all paths in the tree don't lead to the element\n        // This is more complex and typically done using accumulated hash sets\n        \n        let element_hash = self.hasher.hash(element);\n        let accumulated_hash = non_membership_witness.accumulated_hash.clone();\n        \n        // Prove that element_hash is not in the accumulator\n        let non_inclusion_proof = AccumulatorNonInclusionProof::new(\n            element_hash,\n            accumulated_hash,\n            non_membership_witness\n        )?;\n        \n        Ok(ZKProof {\n            proof_type: ZKProofType::SetMembership {\n                set_size: 1 << self.merkle_depth,\n                merkle_depth: self.merkle_depth,\n            },\n            commitment: non_inclusion_proof.commitment,\n            challenge: non_inclusion_proof.challenge,\n            response: non_inclusion_proof.response,\n            public_parameters: PublicParameters::SetNonMembership {\n                accumulated_hash,\n                set_size: 1 << self.merkle_depth,\n            },\n            nullifier: None, // No nullifier for non-membership\n        })\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MerklePath {\n    pub siblings: Vec<Vec<u8>>,\n    pub directions: Vec<bool>,    // true = right, false = left\n}\n\n#[derive(Debug, Clone)]\npub struct MerkleConstraint {\n    pub left: Vec<u8>,\n    pub right: Vec<u8>,\n    pub output: Vec<u8>,\n    pub direction_bit: bool,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"anonymous-credentials",children:"Anonymous Credentials"}),"\n",(0,r.jsx)(n.h3,{id:"bbs-signatures",children:"BBS+ Signatures"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::bbs_plus::*;\n\npub struct BBSPlusCredentialSystem {\n    public_key: BBSPublicKey,\n    secret_key: Option<BBSSecretKey>, // Only issuer has this\n    generators: Vec<GroupElement>,\n}\n\n#[derive(Debug, Clone)]\npub struct AnonymousCredential {\n    pub signature: BBSSignature,\n    pub attributes: Vec<CredentialAttribute>,\n    pub issuer_public_key: BBSPublicKey,\n    pub schema: CredentialSchema,\n}\n\n#[derive(Debug, Clone)]\npub struct CredentialAttribute {\n    pub name: String,\n    pub value: AttributeValue,\n    pub revealed: bool,              // Whether to reveal in proof\n}\n\n#[derive(Debug, Clone)]\npub enum AttributeValue {\n    String(String),\n    Integer(i64),\n    Boolean(bool),\n    Timestamp(SystemTime),\n    Location(Coordinate),\n    Hash(Vec<u8>),\n}\n\nimpl BBSPlusCredentialSystem {\n    pub fn issue_credential(\n        &self,\n        attributes: &[CredentialAttribute],\n        secret_key: &BBSSecretKey\n    ) -> Result<AnonymousCredential> {\n        // Convert attributes to field elements\n        let attribute_messages: Result<Vec<FieldElement>, _> = attributes.iter()\n            .map(|attr| self.attribute_to_field_element(&attr.value))\n            .collect();\n        \n        let messages = attribute_messages?;\n        \n        // Generate BBS+ signature\n        let signature = self.sign_messages(&messages, secret_key)?;\n        \n        Ok(AnonymousCredential {\n            signature,\n            attributes: attributes.to_vec(),\n            issuer_public_key: self.public_key.clone(),\n            schema: CredentialSchema::from_attributes(attributes),\n        })\n    }\n    \n    pub fn create_selective_disclosure_proof(\n        &self,\n        credential: &AnonymousCredential,\n        revealed_indices: &[usize],\n        proof_request: &ProofRequest\n    ) -> Result<SelectiveDisclosureProof> {\n        \n        // Split attributes into revealed and hidden\n        let mut revealed_messages = Vec::new();\n        let mut hidden_messages = Vec::new();\n        let mut revealed_indices_set = revealed_indices.iter().collect::<std::collections::HashSet<_>>();\n        \n        for (i, attr) in credential.attributes.iter().enumerate() {\n            let message = self.attribute_to_field_element(&attr.value)?;\n            \n            if revealed_indices_set.contains(&i) {\n                revealed_messages.push((i, message));\n            } else {\n                hidden_messages.push((i, message));\n            }\n        }\n        \n        // Create proof of knowledge for hidden attributes\n        let pok = self.create_proof_of_knowledge(\n            &credential.signature,\n            &revealed_messages,\n            &hidden_messages,\n            proof_request\n        )?;\n        \n        Ok(SelectiveDisclosureProof {\n            revealed_attributes: revealed_messages.into_iter()\n                .map(|(i, _)| (i, credential.attributes[i].clone()))\n                .collect(),\n            proof_of_knowledge: pok,\n            issuer_public_key: credential.issuer_public_key.clone(),\n            schema: credential.schema.clone(),\n        })\n    }\n    \n    fn create_proof_of_knowledge(\n        &self,\n        signature: &BBSSignature,\n        revealed: &[(usize, FieldElement)],\n        hidden: &[(usize, FieldElement)],\n        proof_request: &ProofRequest\n    ) -> Result<ProofOfKnowledge> {\n        // Randomize the signature to prevent linking\n        let (randomized_signature, randomness) = self.randomize_signature(signature)?;\n        \n        // Create Schnorr proof for each hidden attribute\n        let mut attribute_proofs = Vec::new();\n        \n        for (index, message) in hidden {\n            // Check if this attribute has any constraints in the proof request\n            if let Some(constraints) = proof_request.constraints.get(index) {\n                for constraint in constraints {\n                    match constraint {\n                        AttributeConstraint::Range { min, max } => {\n                            // Create range proof for this attribute\n                            if let AttributeValue::Integer(value) = &credential.attributes[*index].value {\n                                let range_proof = self.create_attribute_range_proof(\n                                    *value,\n                                    *min,\n                                    *max,\n                                    message,\n                                    &randomness\n                                )?;\n                                attribute_proofs.push(AttributeProof::Range(range_proof));\n                            }\n                        },\n                        AttributeConstraint::SetMembership { allowed_values } => {\n                            let membership_proof = self.create_attribute_membership_proof(\n                                message,\n                                allowed_values,\n                                &randomness\n                            )?;\n                            attribute_proofs.push(AttributeProof::SetMembership(membership_proof));\n                        },\n                        AttributeConstraint::Predicate { predicate } => {\n                            let predicate_proof = self.create_predicate_proof(\n                                message,\n                                predicate,\n                                &randomness\n                            )?;\n                            attribute_proofs.push(AttributeProof::Predicate(predicate_proof));\n                        }\n                    }\n                }\n            }\n        }\n        \n        Ok(ProofOfKnowledge {\n            randomized_signature,\n            attribute_proofs,\n            challenge: self.compute_fiat_shamir_challenge(\n                &randomized_signature,\n                &attribute_proofs,\n                revealed\n            )?,\n        })\n    }\n    \n    fn attribute_to_field_element(&self, value: &AttributeValue) -> Result<FieldElement> {\n        match value {\n            AttributeValue::String(s) => {\n                let hash = sha256::digest(s.as_bytes());\n                Ok(FieldElement::from_bytes(&hash)?)\n            },\n            AttributeValue::Integer(i) => {\n                Ok(FieldElement::from(*i as u64))\n            },\n            AttributeValue::Boolean(b) => {\n                Ok(FieldElement::from(*b as u64))\n            },\n            AttributeValue::Timestamp(ts) => {\n                let secs = ts.duration_since(SystemTime::UNIX_EPOCH)\n                    .unwrap_or_default()\n                    .as_secs();\n                Ok(FieldElement::from(secs))\n            },\n            AttributeValue::Location(coord) => {\n                // Combine latitude and longitude into single field element\n                let lat_bytes = coord.latitude.to_be_bytes();\n                let lon_bytes = coord.longitude.to_be_bytes();\n                let combined = [lat_bytes, lon_bytes].concat();\n                let hash = sha256::digest(&combined);\n                Ok(FieldElement::from_bytes(&hash)?)\n            },\n            AttributeValue::Hash(h) => {\n                Ok(FieldElement::from_bytes(h)?)\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SelectiveDisclosureProof {\n    pub revealed_attributes: Vec<(usize, CredentialAttribute)>,\n    pub proof_of_knowledge: ProofOfKnowledge,\n    pub issuer_public_key: BBSPublicKey,\n    pub schema: CredentialSchema,\n}\n\n#[derive(Debug, Clone)]\npub struct ProofRequest {\n    pub constraints: HashMap<usize, Vec<AttributeConstraint>>,\n    pub nonce: Vec<u8>,\n    pub context: ProofContext,\n}\n\n#[derive(Debug, Clone)]\npub enum AttributeConstraint {\n    Range { min: i64, max: i64 },\n    SetMembership { allowed_values: Vec<AttributeValue> },\n    Predicate { predicate: String }, // Custom predicate in domain-specific language\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"nullifiers-and-anti-replay",children:"Nullifiers and Anti-Replay"}),"\n",(0,r.jsx)(n.h3,{id:"nullifier-generation",children:"Nullifier Generation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_privacy::zkp::nullifiers::*;\n\npub struct NullifierSystem {\n    nullifier_key: PrivateKey,      // Long-term nullifier key\n    used_nullifiers: HashSet<Nullifier>,\n}\n\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\npub struct Nullifier {\n    pub value: [u8; 32],\n    pub context: NullifierContext,\n}\n\n#[derive(Debug, Clone, Hash, PartialEq, Eq)]\npub enum NullifierContext {\n    LocationProof { region_id: String, time_bucket: u64 },\n    CredentialProof { schema_id: String, proof_session: String },\n    AnonymousVote { election_id: String },\n    AnonymousLogin { service_id: String, time_bucket: u64 },\n}\n\nimpl NullifierSystem {\n    pub fn generate_nullifier(\n        &self,\n        context: &NullifierContext,\n        secret: &[u8]\n    ) -> Result<Nullifier> {\n        // PRF: nullifier = HMAC(nullifier_key, context || secret)\n        let mut mac = HmacSha256::new_from_slice(&self.nullifier_key.as_bytes())\n            .map_err(|_| ZKError::InvalidKey)?;\n        \n        // Add context to the MAC\n        match context {\n            NullifierContext::LocationProof { region_id, time_bucket } => {\n                mac.update(b"location_proof");\n                mac.update(region_id.as_bytes());\n                mac.update(&time_bucket.to_be_bytes());\n            },\n            NullifierContext::CredentialProof { schema_id, proof_session } => {\n                mac.update(b"credential_proof");\n                mac.update(schema_id.as_bytes());\n                mac.update(proof_session.as_bytes());\n            },\n            NullifierContext::AnonymousVote { election_id } => {\n                mac.update(b"anonymous_vote");\n                mac.update(election_id.as_bytes());\n            },\n            NullifierContext::AnonymousLogin { service_id, time_bucket } => {\n                mac.update(b"anonymous_login");\n                mac.update(service_id.as_bytes());\n                mac.update(&time_bucket.to_be_bytes());\n            },\n        }\n        \n        // Add secret\n        mac.update(secret);\n        \n        let result = mac.finalize().into_bytes();\n        let mut nullifier_bytes = [0u8; 32];\n        nullifier_bytes.copy_from_slice(&result);\n        \n        Ok(Nullifier {\n            value: nullifier_bytes,\n            context: context.clone(),\n        })\n    }\n    \n    pub fn check_and_record_nullifier(&mut self, nullifier: &Nullifier) -> Result<bool> {\n        if self.used_nullifiers.contains(nullifier) {\n            return Ok(false); // Already used (replay attack)\n        }\n        \n        self.used_nullifiers.insert(nullifier.clone());\n        Ok(true) // Fresh nullifier\n    }\n    \n    pub fn cleanup_expired_nullifiers(&mut self, retention_period: Duration) {\n        // Remove old nullifiers based on context-specific expiry\n        let current_time = SystemTime::now();\n        let cutoff = current_time - retention_period;\n        \n        self.used_nullifiers.retain(|nullifier| {\n            match &nullifier.context {\n                NullifierContext::LocationProof { time_bucket, .. } |\n                NullifierContext::AnonymousLogin { time_bucket, .. } => {\n                    // Convert time bucket back to SystemTime\n                    let bucket_time = SystemTime::UNIX_EPOCH + Duration::from_secs(*time_bucket);\n                    bucket_time > cutoff\n                },\n                _ => true, // Keep other nullifiers\n            }\n        });\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"privacy-preserving-location-attestation",children:"Privacy-Preserving Location Attestation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_privacy::zkp::*;\nuse olocus_trust::*;\nuse olocus_location::*;\n\nasync fn create_private_location_attestation(\n    actual_location: Coordinate,\n    public_region: GeographicRegion,\n    trust_network: &TrustNetwork,\n    zkp_system: &LocationZKProof\n) -> Result<PrivateAttestation> {\n    \n    // 1. Generate zero-knowledge proof of presence in region\n    let location_witness = LocationWitness {\n        actual_location,\n        timestamp: SystemTime::now(),\n        randomness: Scalar::random(),\n        time_window: TimeWindow {\n            start: SystemTime::now() - Duration::from_mins(5),\n            end: SystemTime::now() + Duration::from_mins(5),\n            granularity: TemporalGranularity::Minute,\n        },\n    };\n    \n    let zk_proof = zkp_system.prove_presence_in_region(\n        &actual_location,\n        &public_region,\n        &location_witness.time_window,\n        &location_witness\n    )?;\n    \n    // 2. Get trust network attestation without revealing exact location\n    let attestation_claim = AttestationType::Presence {\n        location: public_region.center(), // Only reveal region center\n        radius: public_region.radius(),   // And radius\n        timestamp: SystemTime::now(),\n        duration: Some(Duration::from_mins(10)),\n    };\n    \n    let witnesses = trust_network.find_nearby_witnesses(&public_region, 3).await?;\n    let trust_attestation = trust_network.create_attestation(\n        trust_network.local_did(),\n        attestation_claim,\n        witnesses\n    ).await?;\n    \n    // 3. Combine ZK proof with trust attestation\n    Ok(PrivateAttestation {\n        zk_proof,\n        trust_attestation,\n        nullifier: location_witness.generate_nullifier()?,\n        public_region,\n        confidence_level: 0.95,\n    })\n}\n\n#[derive(Debug, Clone)]\npub struct PrivateAttestation {\n    pub zk_proof: ZKProof,\n    pub trust_attestation: Attestation,\n    pub nullifier: Nullifier,\n    pub public_region: GeographicRegion,\n    pub confidence_level: f64,\n}\n\nimpl PrivateAttestation {\n    pub fn verify(&self, zkp_system: &LocationZKProof, trust_network: &TrustNetwork) -> Result<bool> {\n        // Verify ZK proof\n        let zk_valid = zkp_system.verify_proof(&self.zk_proof)?;\n        if !zk_valid {\n            return Ok(false);\n        }\n        \n        // Verify trust attestation\n        let trust_valid = trust_network.verify_attestation(&self.trust_attestation)?;\n        if !trust_valid {\n            return Ok(false);\n        }\n        \n        // Check nullifier hasn't been used\n        let nullifier_valid = zkp_system.check_nullifier(&self.nullifier)?;\n        \n        Ok(zk_valid && trust_valid && nullifier_valid)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"anonymous-credential-presentation",children:"Anonymous Credential Presentation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'async fn present_anonymous_credential(\n    credential: &AnonymousCredential,\n    proof_request: &ProofRequest,\n    bbs_system: &BBSPlusCredentialSystem\n) -> Result<CredentialPresentation> {\n    \n    // Determine which attributes to reveal\n    let mut revealed_indices = Vec::new();\n    let mut hidden_constraints = HashMap::new();\n    \n    for (attr_index, constraints) in &proof_request.constraints {\n        let mut should_reveal = false;\n        \n        for constraint in constraints {\n            match constraint {\n                AttributeConstraint::Range { .. } => {\n                    // Can prove range without revealing exact value\n                    hidden_constraints.entry(*attr_index).or_insert_with(Vec::new).push(constraint.clone());\n                },\n                AttributeConstraint::SetMembership { .. } => {\n                    // May need to reveal for set membership depending on implementation\n                    should_reveal = true;\n                },\n                AttributeConstraint::Predicate { predicate } => {\n                    // Depends on the predicate\n                    if predicate.contains("reveal") {\n                        should_reveal = true;\n                    } else {\n                        hidden_constraints.entry(*attr_index).or_insert_with(Vec::new).push(constraint.clone());\n                    }\n                }\n            }\n        }\n        \n        if should_reveal {\n            revealed_indices.push(*attr_index);\n        }\n    }\n    \n    // Create selective disclosure proof\n    let disclosure_proof = bbs_system.create_selective_disclosure_proof(\n        credential,\n        &revealed_indices,\n        proof_request\n    )?;\n    \n    // Generate nullifier to prevent multiple presentations\n    let nullifier_context = NullifierContext::CredentialProof {\n        schema_id: credential.schema.id.clone(),\n        proof_session: proof_request.context.session_id.clone(),\n    };\n    \n    let nullifier = bbs_system.nullifier_system.generate_nullifier(\n        &nullifier_context,\n        &credential.signature.as_bytes()\n    )?;\n    \n    Ok(CredentialPresentation {\n        disclosure_proof,\n        nullifier,\n        context: proof_request.context.clone(),\n        timestamp: SystemTime::now(),\n    })\n}\n\n#[derive(Debug, Clone)]\npub struct CredentialPresentation {\n    pub disclosure_proof: SelectiveDisclosureProof,\n    pub nullifier: Nullifier,\n    pub context: ProofContext,\n    pub timestamp: SystemTime,\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance--security-considerations",children:"Performance & Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Typical performance characteristics\npub struct ZKPPerformanceMetrics {\n    pub proof_generation_time: Duration,    // ~500ms for location proofs\n    pub verification_time: Duration,        // ~50ms for most proofs\n    pub proof_size: usize,                  // ~2KB for range proofs\n    pub memory_usage: usize,                // ~100MB during generation\n}\n\n// Benchmark different proof types\n#[cfg(test)]\nmod zkp_benchmarks {\n    use super::*;\n    use criterion::{black_box, Criterion};\n    \n    #[bench]\n    fn bench_location_proof_generation(c: &mut Criterion) {\n        let zkp_system = LocationZKProof::new();\n        let location = Coordinate::new(37.7749, -122.4194);\n        let region = GeographicRegion::Circle {\n            center: Coordinate::new(37.7749, -122.4194),\n            radius: 1000.0,\n        };\n        \n        c.bench_function("location_proof_generation", |b| {\n            b.iter(|| {\n                let witness = LocationWitness::new();\n                zkp_system.prove_presence_in_region(\n                    black_box(&location),\n                    black_box(&region),\n                    black_box(&witness.time_window),\n                    black_box(&witness)\n                )\n            });\n        });\n    }\n    \n    #[bench]\n    fn bench_range_proof_generation(c: &mut Criterion) {\n        let bulletproof_system = BulletproofRangeProof::new();\n        \n        c.bench_function("range_proof_generation", |b| {\n            b.iter(|| {\n                bulletproof_system.prove_value_in_range(\n                    black_box(42),\n                    black_box(0),\n                    black_box(100),\n                    black_box(8),\n                    black_box(Scalar::random())\n                )\n            });\n        });\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"security-properties",children:"Security Properties"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct ZKPSecurityProperties {\n    // Completeness: Honest provers can always convince honest verifiers\n    pub completeness: bool,          // true\n    \n    // Soundness: Dishonest provers cannot convince honest verifiers\n    pub soundness_error: f64,        // 2^-128 (negligible)\n    \n    // Zero-knowledge: Verifiers learn nothing beyond statement validity\n    pub zero_knowledge: bool,        // true (statistical/perfect ZK)\n    \n    // Additional properties\n    pub honest_verifier_zk: bool,    // true (for Fiat-Shamir proofs)\n    pub non_interactive: bool,       // true (using random oracle model)\n    pub composable: bool,            // true (proofs can be combined)\n}\n\n// Security analysis\nimpl ZKPSecurityProperties {\n    pub fn analyze_security_level(&self, proof: &ZKProof) -> SecurityLevel {\n        match proof.proof_type {\n            ZKProofType::LocationPresence { .. } => {\n                // Location privacy depends on region size and temporal granularity\n                SecurityLevel::High // 128-bit equivalent\n            },\n            ZKProofType::RangeProof { bit_length, .. } => {\n                // Range proof security scales with bit length\n                if bit_length >= 64 {\n                    SecurityLevel::High\n                } else if bit_length >= 32 {\n                    SecurityLevel::Medium\n                } else {\n                    SecurityLevel::Low\n                }\n            },\n            ZKProofType::SetMembership { set_size, .. } => {\n                // Anonymity set size determines privacy level\n                if set_size >= 1024 {\n                    SecurityLevel::High\n                } else if set_size >= 256 {\n                    SecurityLevel::Medium\n                } else {\n                    SecurityLevel::Low\n                }\n            },\n            _ => SecurityLevel::Medium,\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum SecurityLevel {\n    Low,     // < 80 bits of security\n    Medium,  // 80-112 bits of security  \n    High,    // >= 128 bits of security\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/privacy/techniques",children:"Privacy Techniques"})," - Differential privacy and k-anonymity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../credentials/anonymous.md",children:"Anonymous Credentials"})," - W3C VC with ZK proofs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/trust-networks",children:"Trust Networks"})," - ZK-enhanced attestations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/architecture/formal-verification",children:"Formal Verification"})," - ZK protocol verification"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);