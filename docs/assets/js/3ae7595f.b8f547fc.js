"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[1952],{8165:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"case-studies/iot-telemetry","title":"IoT Device Telemetry","description":"This case study demonstrates how SmartCity Infrastructure implemented Olocus Protocol to create a secure, verifiable IoT telemetry system for managing thousands of connected devices across urban infrastructure, from traffic lights to environmental sensors.","source":"@site/docs/case-studies/iot-telemetry.md","sourceDirName":"case-studies","slug":"/case-studies/iot-telemetry","permalink":"/docs/case-studies/iot-telemetry","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/case-studies/iot-telemetry.md","tags":[],"version":"current","lastUpdatedAt":1764954839000,"sidebarPosition":3,"frontMatter":{"id":"iot-telemetry","title":"IoT Device Telemetry","sidebar_position":3}}');var a=i(4848),r=i(8453);const s={id:"iot-telemetry",title:"IoT Device Telemetry",sidebar_position:3},o="IoT Device Telemetry with Olocus Protocol",l={},c=[{value:"Business Challenge",id:"business-challenge",level:2},{value:"Data Integrity Issues",id:"data-integrity-issues",level:3},{value:"Scalability and Performance",id:"scalability-and-performance",level:3},{value:"Security and Trust",id:"security-and-trust",level:3},{value:"Regulatory and Compliance",id:"regulatory-and-compliance",level:3},{value:"Solution Architecture",id:"solution-architecture",level:2},{value:"System Overview",id:"system-overview",level:3},{value:"Core Extensions Used",id:"core-extensions-used",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"1. Device Identity and Attestation",id:"1-device-identity-and-attestation",level:3},{value:"2. Real-Time Sensor Data Collection",id:"2-real-time-sensor-data-collection",level:3},{value:"3. Edge Processing and Data Aggregation",id:"3-edge-processing-and-data-aggregation",level:3},{value:"4. Anomaly Detection and Alert Generation",id:"4-anomaly-detection-and-alert-generation",level:3},{value:"5. Trust and Reputation Management for Devices",id:"5-trust-and-reputation-management-for-devices",level:3},{value:"Query and Analytics",id:"query-and-analytics",level:2},{value:"Real-Time Monitoring Dashboard",id:"real-time-monitoring-dashboard",level:3},{value:"Predictive Analytics",id:"predictive-analytics",level:3},{value:"Results and Benefits",id:"results-and-benefits",level:2},{value:"Operational Improvements",id:"operational-improvements",level:3},{value:"Technical Achievements",id:"technical-achievements",level:3},{value:"Environmental and Social Impact",id:"environmental-and-social-impact",level:3},{value:"Edge Computing Architecture",id:"edge-computing-architecture",level:2},{value:"Hierarchical Processing Strategy",id:"hierarchical-processing-strategy",level:3},{value:"Bandwidth Optimization",id:"bandwidth-optimization",level:3},{value:"Privacy and Regulatory Compliance",id:"privacy-and-regulatory-compliance",level:2},{value:"Data Governance Framework",id:"data-governance-framework",level:3},{value:"Lessons Learned",id:"lessons-learned",level:2},{value:"Technical Implementation",id:"technical-implementation",level:3},{value:"Operational Insights",id:"operational-insights",level:3},{value:"Policy and Governance",id:"policy-and-governance",level:3},{value:"Future Expansion",id:"future-expansion",level:2},{value:"Code Repository",id:"code-repository",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"iot-device-telemetry-with-olocus-protocol",children:"IoT Device Telemetry with Olocus Protocol"})}),"\n",(0,a.jsxs)(n.p,{children:["This case study demonstrates how ",(0,a.jsx)(n.strong,{children:"SmartCity Infrastructure"})," implemented Olocus Protocol to create a secure, verifiable IoT telemetry system for managing thousands of connected devices across urban infrastructure, from traffic lights to environmental sensors."]}),"\n",(0,a.jsx)(n.h2,{id:"business-challenge",children:"Business Challenge"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"SmartCity Infrastructure"})," operates 50,000+ IoT devices across metropolitan areas and faced critical challenges:"]}),"\n",(0,a.jsx)(n.h3,{id:"data-integrity-issues",children:"Data Integrity Issues"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sensor data tampering by malicious actors"}),"\n",(0,a.jsx)(n.li,{children:"Unreliable devices producing false readings"}),"\n",(0,a.jsx)(n.li,{children:"No way to verify data authenticity from remote sensors"}),"\n",(0,a.jsx)(n.li,{children:"Difficulty distinguishing between device failure and cyberattacks"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"scalability-and-performance",children:"Scalability and Performance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Centralized systems creating bottlenecks with high device counts"}),"\n",(0,a.jsx)(n.li,{children:"Network outages causing data loss"}),"\n",(0,a.jsx)(n.li,{children:"Inability to process real-time data streams efficiently"}),"\n",(0,a.jsx)(n.li,{children:"Edge computing requirements for latency-sensitive applications"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"security-and-trust",children:"Security and Trust"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Vulnerable communication channels between devices and servers"}),"\n",(0,a.jsx)(n.li,{children:"No cryptographic verification of device identity"}),"\n",(0,a.jsx)(n.li,{children:"Unauthorized devices joining the network"}),"\n",(0,a.jsx)(n.li,{children:"Lack of audit trails for critical infrastructure decisions"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"regulatory-and-compliance",children:"Regulatory and Compliance"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Government requirements for data provenance in public infrastructure"}),"\n",(0,a.jsx)(n.li,{children:"Privacy concerns with environmental monitoring in residential areas"}),"\n",(0,a.jsx)(n.li,{children:"Need for forensic capabilities in incident investigations"}),"\n",(0,a.jsx)(n.li,{children:"Energy efficiency mandates requiring verifiable consumption data"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"solution-architecture",children:"Solution Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"system-overview",children:"System Overview"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SmartCity IoT Network                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Edge Devices    \u2502 Edge Gateways \u2502 City Cloud   \u2502 Data Centers  \u2502\n\u2502      \u2193           \u2502      \u2193        \u2502     \u2193        \u2502      \u2193        \u2502\n\u2502 [Sensors]        \u2502 [Fog Nodes]   \u2502 [Analytics]  \u2502 [Archives]    \u2502\n\u2502 [Actuators]      \u2502 [Local Proc]  \u2502 [ML Models]  \u2502 [Compliance]  \u2502\n\u2502 [Controllers]    \u2502 [Buffering]   \u2502 [Dashboards] \u2502 [Backups]     \u2502\n\u2502      \u2193           \u2502      \u2193        \u2502     \u2193        \u2502      \u2193        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                Olocus Protocol Network                     \u2502 \u2502\n\u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502\n\u2502  \u2502 \u2502 IoT \u2502 \u2502Edge \u2502 \u2502Fog  \u2502 \u2502Cloud\u2502 \u2502TSA  \u2502 \u2502Stor \u2502 \u2502Metr \u2502 \u2502 \u2502\n\u2502  \u2502 \u2502Node \u2502 \u2502Gate \u2502 \u2502Proc \u2502 \u2502Anal \u2502 \u2502Sync \u2502 \u2502Age  \u2502 \u2502ics  \u2502 \u2502 \u2502\n\u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502\n\u2502  \u2502    \u2195       \u2195       \u2195       \u2195       \u2195       \u2195       \u2195     \u2502 \u2502\n\u2502  \u2502 [Integrity] [Trust] [Location] [Metrics] [TSA] [Storage] \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(n.h3,{id:"core-extensions-used",children:"Core Extensions Used"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-integrity"}),": Device attestation and sensor verification"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-location"}),": GPS verification and geofencing"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-metrics"}),": Real-time telemetry aggregation and monitoring"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-tsa"}),": Immutable timestamps for all sensor readings"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-storage"}),": Distributed data storage with replication"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-trust"}),": Device identity and reputation management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"olocus-query"}),": Real-time analytics and historical data access"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,a.jsx)(n.h3,{id:"1-device-identity-and-attestation",children:"1. Device Identity and Attestation"}),"\n",(0,a.jsx)(n.p,{children:"Each IoT device has a cryptographically verified identity with hardware attestation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, Measurement, Value, Uncertainty, Provenance, Source};\nuse olocus_integrity::{DeviceIntegrityPayload, HardwareAttestation, DeviceProfile};\n\n// Device registration with hardware attestation\nlet device_registration = Block::new(\n    DeviceIntegrityPayload::DeviceRegistration {\n        device_id: [0x12, 0x34, /*...*/ 0xab; 32],\n        device_type: DeviceType::EnvironmentalSensor,\n        manufacturer: "AcmeSensors Inc".to_string(),\n        model: "EnviroMonitor-3000".to_string(),\n        firmware_version: "v2.1.3".to_string(),\n        hardware_attestation: HardwareAttestation {\n            attestation_type: AttestationType::TpmAttestation,\n            attestation_data: tpm_attestation_blob,\n            attestation_signature: tpm_signature,\n            attestation_certificate: device_cert_chain,\n            measurement_registers: vec![\n                PcrMeasurement {\n                    register: 0,\n                    value: bootloader_hash,\n                },\n                PcrMeasurement {\n                    register: 1, \n                    value: firmware_hash,\n                },\n                PcrMeasurement {\n                    register: 7,\n                    value: secure_boot_config_hash,\n                },\n            ],\n        },\n        capabilities: DeviceCapabilities {\n            sensors: vec![\n                SensorCapability {\n                    sensor_type: 0x1001, // Temperature\n                    measurement_range: MeasurementRange::Float(-40.0, 85.0),\n                    accuracy: 0.1,\n                    resolution: 0.01,\n                    sampling_rate_max: 10.0, // 10 Hz\n                },\n                SensorCapability {\n                    sensor_type: 0x1002, // Humidity\n                    measurement_range: MeasurementRange::Float(0.0, 100.0),\n                    accuracy: 2.0,\n                    resolution: 0.1,\n                    sampling_rate_max: 1.0, // 1 Hz\n                },\n                SensorCapability {\n                    sensor_type: 0x1003, // Air Quality (PM2.5)\n                    measurement_range: MeasurementRange::Float(0.0, 500.0),\n                    accuracy: 5.0,\n                    resolution: 0.1,\n                    sampling_rate_max: 0.1, // 0.1 Hz (every 10 seconds)\n                },\n            ],\n            actuators: vec![],\n            communication: CommunicationCapabilities {\n                protocols: vec!["LoRaWAN".to_string(), "WiFi".to_string()],\n                max_data_rate: 50000, // 50 kbps\n                transmission_power: TransmissionPower::Low,\n            },\n            power: PowerProfile {\n                power_source: PowerSource::Battery,\n                battery_capacity_mah: 5000,\n                sleep_current_ua: 10, // 10 microamps\n                active_current_ma: 50, // 50 milliamps\n                expected_lifetime_years: 5,\n            },\n        },\n        deployment_location: Measurement {\n            value: Value::Point3D {\n                lat: Coordinate::latitude_to_fixed(37.7749), // San Francisco\n                lon: Coordinate::longitude_to_fixed(-122.4194),\n                alt: 15000, // 15 meters above sea level (in mm)\n            },\n            uncertainty: Uncertainty::Circular {\n                angle: 0.0,\n                radius: 1.0, // 1 meter installation accuracy\n            },\n            provenance: Provenance {\n                source: Source::Sensor {\n                    device_id: installation_gps_id,\n                    sensor_type: 0x0001, // High-precision GPS\n                    calibration_id: Some(gps_calibration_cert),\n                },\n                transformations: vec![],\n                attestations: vec![\n                    Attestation {\n                        attestor: installation_technician_id,\n                        claim: AttestationClaim::Witnessed,\n                        signature: technician_signature,\n                        timestamp: installation_timestamp,\n                    }\n                ],\n            },\n            validity: ValidityWindow::perpetual(),\n        },\n        security_profile: SecurityProfile {\n            key_generation: KeyGenerationMethod::HardwareRng,\n            key_storage: KeyStorageMethod::SecureElement,\n            encryption_algorithms: vec!["AES-256-GCM".to_string()],\n            signing_algorithms: vec!["Ed25519".to_string()],\n            update_mechanism: UpdateMechanism::SecureOta,\n            tamper_detection: TamperDetection::Physical,\n        },\n        certification: DeviceCertification {\n            certifications: vec![\n                "FCC Part 15".to_string(),\n                "CE Marking".to_string(),\n                "IP67 Weatherproof".to_string(),\n                "NIST Cybersecurity Framework".to_string(),\n            ],\n            security_level: SecurityLevel::High,\n            compliance_frameworks: vec!["NIST SP 800-53".to_string()],\n        },\n        installer: installation_technician_id,\n        installation_timestamp: installation_timestamp,\n    },\n    device_keypair,\n).unwrap();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"2-real-time-sensor-data-collection",children:"2. Real-Time Sensor Data Collection"}),"\n",(0,a.jsx)(n.p,{children:"Continuous sensor readings with comprehensive metadata and uncertainty quantification:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::{MetricsPayload, SensorReading, AggregatedMetrics};\n\n// Environmental sensor readings every 30 seconds\nlet environmental_reading = Block::new(\n    MetricsPayload::SensorBatch {\n        device_id: device_id,\n        batch_timestamp: current_timestamp(),\n        readings: vec![\n            SensorReading {\n                sensor_id: temperature_sensor_id,\n                measurement: Measurement {\n                    value: Value::Float(23.7), // Celsius\n                    uncertainty: Uncertainty::Gaussian { \n                        std_dev: 0.1 // \xb10.1\xb0C accuracy\n                    },\n                    provenance: Provenance {\n                        source: Source::Sensor {\n                            device_id: device_id,\n                            sensor_type: 0x1001, // Temperature\n                            calibration_id: Some(temperature_calibration_cert),\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::UnitConversion {\n                                    from_unit: 0x0100, // Raw ADC\n                                    to_unit: 0x0101,   // Celsius\n                                },\n                                timestamp: current_timestamp(),\n                                actor: device_id,\n                                input_hash: raw_adc_reading_hash,\n                            }\n                        ],\n                        attestations: vec![\n                            Attestation {\n                                attestor: calibration_authority_id,\n                                claim: AttestationClaim::Verified {\n                                    reference_id: sensor_calibration_hash,\n                                },\n                                signature: calibration_signature,\n                                timestamp: calibration_timestamp,\n                            }\n                        ],\n                    },\n                    validity: ValidityWindow::new(\n                        current_timestamp() as i64,\n                        Some((current_timestamp() + 60) as i64), // Valid 1 minute\n                    ),\n                },\n                sampling_info: SamplingInfo {\n                    sample_rate_hz: 1.0,\n                    sample_count: 30, // 30 samples averaged over 30 seconds\n                    sampling_method: SamplingMethod::Average,\n                    noise_floor: 0.01,\n                },\n                quality_indicators: QualityIndicators {\n                    signal_to_noise_ratio: 45.2, // dB\n                    drift_compensation_applied: true,\n                    outlier_detection_applied: true,\n                    outliers_removed: 2,\n                    confidence_score: 0.97,\n                },\n            },\n            SensorReading {\n                sensor_id: humidity_sensor_id,\n                measurement: Measurement {\n                    value: Value::Float(65.3), // % Relative Humidity\n                    uncertainty: Uncertainty::Gaussian { \n                        std_dev: 2.0 // \xb12% RH accuracy\n                    },\n                    provenance: Provenance {\n                        source: Source::Sensor {\n                            device_id: device_id,\n                            sensor_type: 0x1002, // Humidity\n                            calibration_id: Some(humidity_calibration_cert),\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::TemperatureCompensation {\n                                    reference_temperature: 25.0,\n                                    compensation_coefficient: -0.3,\n                                },\n                                timestamp: current_timestamp(),\n                                actor: device_id,\n                                input_hash: raw_humidity_hash,\n                            }\n                        ],\n                        attestations: vec![calibration_authority_attestation],\n                    },\n                    validity: ValidityWindow::new(\n                        current_timestamp() as i64,\n                        Some((current_timestamp() + 60) as i64),\n                    ),\n                },\n                sampling_info: SamplingInfo {\n                    sample_rate_hz: 0.5,\n                    sample_count: 15,\n                    sampling_method: SamplingMethod::Average,\n                    noise_floor: 0.5,\n                },\n                quality_indicators: QualityIndicators {\n                    signal_to_noise_ratio: 38.7,\n                    drift_compensation_applied: true,\n                    outlier_detection_applied: true,\n                    outliers_removed: 0,\n                    confidence_score: 0.94,\n                },\n            },\n            SensorReading {\n                sensor_id: air_quality_sensor_id,\n                measurement: Measurement {\n                    value: Value::Object(BTreeMap::from([\n                        ("pm2_5".to_string(), Value::Float(12.4)), // \u03bcg/m\xb3\n                        ("pm10".to_string(), Value::Float(18.7)),  // \u03bcg/m\xb3\n                        ("ozone".to_string(), Value::Float(45.2)), // ppb\n                        ("no2".to_string(), Value::Float(23.1)),   // ppb\n                    ])),\n                    uncertainty: Uncertainty::Object(BTreeMap::from([\n                        ("pm2_5".to_string(), Uncertainty::Gaussian { std_dev: 1.0 }),\n                        ("pm10".to_string(), Uncertainty::Gaussian { std_dev: 1.5 }),\n                        ("ozone".to_string(), Uncertainty::Gaussian { std_dev: 2.0 }),\n                        ("no2".to_string(), Uncertainty::Gaussian { std_dev: 1.2 }),\n                    ])),\n                    provenance: Provenance {\n                        source: Source::Sensor {\n                            device_id: device_id,\n                            sensor_type: 0x1003, // Multi-gas sensor\n                            calibration_id: Some(air_quality_calibration_cert),\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::CrossSensitivityCompensation {\n                                    reference_compounds: vec!["CO", "SO2", "H2S"],\n                                    compensation_matrix: compensation_coefficients,\n                                },\n                                timestamp: current_timestamp(),\n                                actor: device_id,\n                                input_hash: raw_sensor_matrix_hash,\n                            }\n                        ],\n                        attestations: vec![\n                            epa_certification_attestation,\n                            field_calibration_attestation,\n                        ],\n                    },\n                    validity: ValidityWindow::new(\n                        current_timestamp() as i64,\n                        Some((current_timestamp() + 300) as i64), // Valid 5 minutes\n                    ),\n                },\n                sampling_info: SamplingInfo {\n                    sample_rate_hz: 0.1, // Every 10 seconds\n                    sample_count: 3,     // 3 samples over 30 seconds\n                    sampling_method: SamplingMethod::Median, // Robust to outliers\n                    noise_floor: 0.1,\n                },\n                quality_indicators: QualityIndicators {\n                    signal_to_noise_ratio: 32.1,\n                    drift_compensation_applied: true,\n                    outlier_detection_applied: true,\n                    outliers_removed: 0,\n                    confidence_score: 0.91,\n                },\n            },\n        ],\n        device_status: DeviceStatus {\n            battery_voltage: 3.7, // Volts\n            signal_strength: -67,  // dBm (LoRaWAN)\n            memory_usage: 0.23,    // 23% used\n            cpu_utilization: 0.15, // 15% average\n            uptime_seconds: 86400 * 30, // 30 days\n            last_reboot_reason: RebootReason::ScheduledMaintenance,\n            firmware_integrity_verified: true,\n        },\n        environmental_conditions: Measurement {\n            value: Value::Object(BTreeMap::from([\n                ("enclosure_temperature".to_string(), Value::Float(28.2)),\n                ("vibration_level".to_string(), Value::Float(0.02)), // m/s\xb2\n                ("power_supply_voltage".to_string(), Value::Float(3.65)), // V\n            ])),\n            uncertainty: Uncertainty::Gaussian { std_dev: 0.1 },\n            provenance: Provenance {\n                source: Source::Sensor {\n                    device_id: device_id,\n                    sensor_type: 0x2000, // Internal diagnostics\n                    calibration_id: None,\n                },\n                transformations: vec![],\n                attestations: vec![],\n            },\n            validity: ValidityWindow::new(\n                current_timestamp() as i64,\n                Some((current_timestamp() + 60) as i64),\n            ),\n        },\n    },\n    device_keypair,\n).unwrap();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"3-edge-processing-and-data-aggregation",children:"3. Edge Processing and Data Aggregation"}),"\n",(0,a.jsx)(n.p,{children:"Local processing at edge gateways for reduced latency and bandwidth:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_location::{LocationPayload, GeofenceEvent};\nuse olocus_metrics::{AggregatedMetrics, AggregationFunction};\n\n// Edge gateway aggregating data from 50 sensors in a geographic area\nlet edge_aggregation = Block::new(\n    MetricsPayload::EdgeAggregation {\n        gateway_id: edge_gateway_id,\n        aggregation_period: AggregationPeriod {\n            start: aggregation_start,\n            end: aggregation_end,\n            duration_seconds: 300, // 5-minute aggregation\n        },\n        geographic_bounds: GeographicBounds {\n            north_east: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7849),\n                lon: Coordinate::longitude_to_fixed(-122.4094),\n            },\n            south_west: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7649),\n                lon: Coordinate::longitude_to_fixed(-122.4294),\n            },\n            center: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7749),\n                lon: Coordinate::longitude_to_fixed(-122.4194),\n            },\n            radius_meters: 1000,\n        },\n        device_count: 47, // 47 out of 50 devices reported\n        aggregated_metrics: vec![\n            AggregatedMetric {\n                metric_type: "temperature".to_string(),\n                measurement: Measurement {\n                    value: Value::Object(BTreeMap::from([\n                        ("mean".to_string(), Value::Float(24.2)),\n                        ("std_dev".to_string(), Value::Float(1.8)),\n                        ("min".to_string(), Value::Float(21.1)),\n                        ("max".to_string(), Value::Float(27.6)),\n                        ("median".to_string(), Value::Float(24.0)),\n                        ("count".to_string(), Value::Int(235)), // Total readings\n                    ])),\n                    uncertainty: Uncertainty::Gaussian { \n                        std_dev: 0.3 // Uncertainty in the aggregated mean\n                    },\n                    provenance: Provenance {\n                        source: Source::Derived {\n                            algorithm_id: 0x6000, // Spatial-temporal aggregation\n                            input_hashes: sensor_reading_hashes,\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::Aggregate {\n                                    function: AggregateFunction::WeightedMean,\n                                    window_size: 235,\n                                },\n                                timestamp: aggregation_end,\n                                actor: edge_gateway_id,\n                                input_hash: raw_temperature_readings_hash,\n                            }\n                        ],\n                        attestations: vec![],\n                    },\n                    validity: ValidityWindow::new(\n                        aggregation_start as i64,\n                        Some((aggregation_start + 600) as i64), // Valid 10 minutes\n                    ),\n                },\n                quality_score: 0.95, // 95% confidence in aggregation\n                spatial_representativeness: 0.88, // Good spatial coverage\n                temporal_completeness: 0.94, // 94% of expected readings received\n            },\n            AggregatedMetric {\n                metric_type: "air_quality_index".to_string(),\n                measurement: Measurement {\n                    value: Value::Object(BTreeMap::from([\n                        ("aqi_mean".to_string(), Value::Float(42.7)),\n                        ("aqi_max".to_string(), Value::Float(58.2)),\n                        ("dominant_pollutant".to_string(), Value::String("PM2.5".to_string())),\n                        ("health_advisory".to_string(), Value::String("Good".to_string())),\n                    ])),\n                    uncertainty: Uncertainty::Interval {\n                        lower: 38.2,\n                        upper: 47.1,\n                        confidence: 0.95,\n                    },\n                    provenance: Provenance {\n                        source: Source::Derived {\n                            algorithm_id: 0x6001, // EPA AQI calculation\n                            input_hashes: air_quality_sensor_hashes,\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::AqiCalculation {\n                                    standard: "EPA AQI".to_string(),\n                                    pollutants: vec!["PM2.5", "PM10", "O3", "NO2"],\n                                },\n                                timestamp: aggregation_end,\n                                actor: edge_gateway_id,\n                                input_hash: pollutant_concentrations_hash,\n                            }\n                        ],\n                        attestations: vec![\n                            Attestation {\n                                attestor: epa_algorithm_authority,\n                                claim: AttestationClaim::AlgorithmVerified {\n                                    algorithm_hash: aqi_algorithm_hash,\n                                },\n                                signature: epa_signature,\n                                timestamp: algorithm_certification_date,\n                            }\n                        ],\n                    },\n                    validity: ValidityWindow::new(\n                        aggregation_start as i64,\n                        Some((aggregation_start + 1800) as i64), // Valid 30 minutes\n                    ),\n                },\n                quality_score: 0.92,\n                spatial_representativeness: 0.91,\n                temporal_completeness: 0.89,\n            },\n        ],\n        processing_metadata: ProcessingMetadata {\n            algorithms_used: vec![\n                AlgorithmMetadata {\n                    algorithm_id: 0x6000,\n                    version: "v2.3.1".to_string(),\n                    parameters: AlgorithmParameters::from([\n                        ("outlier_threshold".to_string(), "3.0".to_string()),\n                        ("spatial_weight_function".to_string(), "inverse_distance".to_string()),\n                        ("temporal_weight_decay".to_string(), "exponential".to_string()),\n                    ]),\n                    execution_time_ms: 120,\n                    memory_usage_kb: 450,\n                },\n            ],\n            data_quality_flags: vec![\n                DataQualityFlag::SpatialCoverageGood,\n                DataQualityFlag::TemporalCompletenessGood,\n                DataQualityFlag::OutliersDetected(3),\n            ],\n            performance_metrics: PerformanceMetrics {\n                processing_latency_ms: 85,\n                bandwidth_usage_kb: 12.4,\n                cpu_utilization: 0.23,\n                memory_peak_mb: 15.7,\n            },\n        },\n    },\n    edge_gateway_keypair,\n).unwrap();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"4-anomaly-detection-and-alert-generation",children:"4. Anomaly Detection and Alert Generation"}),"\n",(0,a.jsx)(n.p,{children:"Automated detection of sensor anomalies and environmental events:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Anomaly detection triggers immediate alert\nlet anomaly_detection = Block::new(\n    MetricsPayload::AnomalyAlert {\n        alert_id: [0x78, 0x9a, /*...*/ 0xef; 32],\n        detection_timestamp: anomaly_timestamp,\n        anomaly_type: AnomalyType::AirQualitySpike,\n        severity: AlertSeverity::High,\n        affected_area: GeographicBounds {\n            north_east: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7799),\n                lon: Coordinate::longitude_to_fixed(-122.4144),\n            },\n            south_west: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7699),\n                lon: Coordinate::longitude_to_fixed(-122.4244),\n            },\n            center: Point2D {\n                lat: Coordinate::latitude_to_fixed(37.7749),\n                lon: Coordinate::longitude_to_fixed(-122.4194),\n            },\n            radius_meters: 500,\n        },\n        detection_details: DetectionDetails {\n            metric_name: "pm2_5_concentration".to_string(),\n            baseline_measurement: Measurement {\n                value: Value::Float(12.4), // Normal baseline\n                uncertainty: Uncertainty::Gaussian { std_dev: 2.1 },\n                provenance: Provenance {\n                    source: Source::Derived {\n                        algorithm_id: 0x7000, // Baseline calculation\n                        input_hashes: vec![historical_data_hash],\n                    },\n                    transformations: vec![],\n                    attestations: vec![],\n                },\n                validity: ValidityWindow::new(\n                    (anomaly_timestamp - 86400 * 7) as i64, // Based on last 7 days\n                    Some(anomaly_timestamp as i64),\n                ),\n            },\n            anomalous_measurement: Measurement {\n                value: Value::Float(89.7), // Significant spike\n                uncertainty: Uncertainty::Gaussian { std_dev: 1.0 },\n                provenance: Provenance {\n                    source: Source::Sensor {\n                        device_id: primary_sensor_id,\n                        sensor_type: 0x1003,\n                        calibration_id: Some(calibration_cert),\n                    },\n                    transformations: vec![],\n                    attestations: vec![device_integrity_attestation],\n                },\n                validity: ValidityWindow::new(\n                    anomaly_timestamp as i64,\n                    Some((anomaly_timestamp + 300) as i64),\n                ),\n            },\n            confidence_score: 0.96,\n            statistical_significance: 7.2, // Z-score\n            detection_algorithm: DetectionAlgorithm {\n                algorithm_id: 0x7001,\n                algorithm_type: "Isolation Forest + LSTM".to_string(),\n                model_version: "v3.2.1".to_string(),\n                training_data_period: 86400 * 90, // 90 days\n                false_positive_rate: 0.02,\n                sensitivity_threshold: 0.95,\n            },\n        },\n        corroborating_evidence: vec![\n            CorroboratingEvidence {\n                evidence_type: "neighboring_sensors".to_string(),\n                supporting_devices: vec![\n                    nearby_sensor_1,\n                    nearby_sensor_2,\n                    nearby_sensor_3,\n                ],\n                correlation_coefficient: 0.87,\n                temporal_alignment: 0.95, // All sensors detected similar timing\n            },\n            CorroboratingEvidence {\n                evidence_type: "weather_conditions".to_string(),\n                supporting_devices: vec![weather_station_id],\n                correlation_coefficient: 0.23, // Low wind might explain accumulation\n                temporal_alignment: 1.0,\n            },\n            CorroboratingEvidence {\n                evidence_type: "traffic_patterns".to_string(),\n                supporting_devices: vec![traffic_counter_id],\n                correlation_coefficient: 0.78, // Heavy traffic correlation\n                temporal_alignment: 0.92,\n            },\n        ],\n        recommended_actions: vec![\n            RecommendedAction {\n                action_type: "public_health_advisory".to_string(),\n                urgency: ActionUrgency::Immediate,\n                description: "Issue air quality advisory for sensitive groups".to_string(),\n                estimated_affected_population: 5200,\n            },\n            RecommendedAction {\n                action_type: "source_investigation".to_string(),\n                urgency: ActionUrgency::High,\n                description: "Investigate potential pollution sources in area".to_string(),\n                estimated_affected_population: 0,\n            },\n            RecommendedAction {\n                action_type: "enhanced_monitoring".to_string(),\n                urgency: ActionUrgency::Medium,\n                description: "Increase sensor sampling frequency for 24 hours".to_string(),\n                estimated_affected_population: 0,\n            },\n        ],\n        notification_targets: vec![\n            NotificationTarget {\n                target_type: "emergency_services".to_string(),\n                contact_info: "city_emergency@smartcity.gov".to_string(),\n                notification_method: NotificationMethod::Email,\n            },\n            NotificationTarget {\n                target_type: "public_api".to_string(),\n                contact_info: "https://api.smartcity.gov/alerts".to_string(),\n                notification_method: NotificationMethod::Webhook,\n            },\n            NotificationTarget {\n                target_type: "citizen_app".to_string(),\n                contact_info: "air_quality_subscribers".to_string(),\n                notification_method: NotificationMethod::PushNotification,\n            },\n        ],\n    },\n    anomaly_detection_keypair,\n).unwrap();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"5-trust-and-reputation-management-for-devices",children:"5. Trust and Reputation Management for Devices"}),"\n",(0,a.jsx)(n.p,{children:"Dynamic trust scoring based on device reliability and data quality:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_trust::{TrustPayload, DeviceReputation, ReliabilityMetric};\n\nlet device_reputation_update = Block::new(\n    TrustPayload::DeviceReputationUpdate {\n        device_id: device_id,\n        evaluation_period: EvaluationPeriod {\n            start: evaluation_start,\n            end: evaluation_end,\n        },\n        reliability_metrics: vec![\n            ReliabilityMetric {\n                metric_type: "data_quality".to_string(),\n                measurement: Measurement {\n                    value: Value::Float(0.94), // 94% quality score\n                    uncertainty: Uncertainty::Confidence { level: 0.95 },\n                    provenance: Provenance {\n                        source: Source::Derived {\n                            algorithm_id: 0x8000, // Data quality assessment\n                            input_hashes: vec![sensor_readings_hash],\n                        },\n                        transformations: vec![\n                            Transformation {\n                                operation: TransformationOp::QualityScore {\n                                    factors: vec![\n                                        "calibration_drift",\n                                        "noise_level", \n                                        "outlier_frequency",\n                                        "cross_validation_accuracy",\n                                    ],\n                                },\n                                timestamp: evaluation_end,\n                                actor: reputation_engine_id,\n                                input_hash: quality_assessment_hash,\n                            }\n                        ],\n                        attestations: vec![],\n                    },\n                    validity: ValidityWindow::new(\n                        evaluation_end as i64,\n                        Some((evaluation_end + 86400 * 30) as i64), // Valid 30 days\n                    ),\n                },\n                weight: 0.4, // 40% weight in overall reputation\n                trend: ReputationTrend::Stable,\n                benchmark_comparison: BenchmarkComparison {\n                    peer_devices_mean: 0.89,\n                    percentile_rank: 78.5,\n                    industry_standard: 0.85,\n                },\n            },\n            ReliabilityMetric {\n                metric_type: "uptime".to_string(),\n                measurement: Measurement {\n                    value: Value::Float(0.998), // 99.8% uptime\n                    uncertainty: Uncertainty::Exact,\n                    provenance: Provenance {\n                        source: Source::Derived {\n                            algorithm_id: 0x8001, // Uptime calculation\n                            input_hashes: vec![device_status_logs_hash],\n                        },\n                        transformations: vec![],\n                        attestations: vec![],\n                    },\n                    validity: ValidityWindow::new(\n                        evaluation_end as i64,\n                        Some((evaluation_end + 86400 * 30) as i64),\n                    ),\n                },\n                weight: 0.3, // 30% weight\n                trend: ReputationTrend::Improving,\n                benchmark_comparison: BenchmarkComparison {\n                    peer_devices_mean: 0.995,\n                    percentile_rank: 65.2,\n                    industry_standard: 0.99,\n                },\n            },\n            ReliabilityMetric {\n                metric_type: "security_compliance".to_string(),\n                measurement: Measurement {\n                    value: Value::Float(1.0), // 100% compliance\n                    uncertainty: Uncertainty::Exact,\n                    provenance: Provenance {\n                        source: Source::Derived {\n                            algorithm_id: 0x8002, // Security audit\n                            input_hashes: vec![security_scan_hash],\n                        },\n                        transformations: vec![],\n                        attestations: vec![\n                            Attestation {\n                                attestor: security_audit_authority,\n                                claim: AttestationClaim::SecurityVerified {\n                                    compliance_level: "NIST High".to_string(),\n                                },\n                                signature: security_auditor_signature,\n                                timestamp: last_security_audit,\n                            }\n                        ],\n                    },\n                    validity: ValidityWindow::new(\n                        last_security_audit as i64,\n                        Some((last_security_audit + 86400 * 90) as i64), // Valid 90 days\n                    ),\n                },\n                weight: 0.3, // 30% weight\n                trend: ReputationTrend::Stable,\n                benchmark_comparison: BenchmarkComparison {\n                    peer_devices_mean: 0.97,\n                    percentile_rank: 100.0,\n                    industry_standard: 0.95,\n                },\n            },\n        ],\n        overall_reputation: DeviceReputation {\n            trust_score: 0.95,\n            confidence_level: 0.93,\n            last_updated: evaluation_end,\n            trend: ReputationTrend::Stable,\n            risk_assessment: RiskAssessment::Low,\n            recommendations: vec![\n                "Continue current maintenance schedule".to_string(),\n                "Consider for high-priority deployment locations".to_string(),\n            ],\n        },\n        peer_validation: PeerValidation {\n            validating_devices: vec![\n                nearby_device_1,\n                nearby_device_2,\n                nearby_device_3,\n            ],\n            cross_validation_score: 0.92,\n            consensus_agreement: 0.89,\n            outlier_detection_agreement: 0.95,\n        },\n        operator_feedback: OperatorFeedback {\n            maintenance_reports: vec![\n                MaintenanceReport {\n                    timestamp: last_maintenance,\n                    technician: maintenance_tech_id,\n                    issues_found: vec![],\n                    calibration_verified: true,\n                    physical_condition: PhysicalCondition::Excellent,\n                },\n            ],\n            performance_notes: "Consistent high-quality readings. No drift detected.".to_string(),\n            deployment_effectiveness: 0.97,\n        },\n    },\n    reputation_keypair,\n).unwrap();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"query-and-analytics",children:"Query and Analytics"}),"\n",(0,a.jsx)(n.h3,{id:"real-time-monitoring-dashboard",children:"Real-Time Monitoring Dashboard"}),"\n",(0,a.jsx)(n.p,{children:"City operators can query live and historical data across the entire sensor network:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_query::{QueryEngine, Query, QueryOperator, SpatialOperator};\n\n// Real-time air quality across the city\nlet citywide_air_quality = query_engine.execute(Query {\n    collection: "sensor_readings".to_string(),\n    filter: QueryOperator::And(vec![\n        QueryOperator::Equals {\n            field: "payload.readings.sensor_type".to_string(),\n            value: "0x1003".to_string(), // Air quality sensors\n        },\n        QueryOperator::GreaterThan {\n            field: "timestamp".to_string(),\n            value: (current_timestamp() - 300).to_string(), // Last 5 minutes\n        },\n        SpatialOperator::Within {\n            geometry: SpatialGeometry::Polygon {\n                coordinates: city_boundary_coordinates,\n            },\n        },\n    ]),\n    aggregation: Some(Aggregation {\n        group_by: vec![\n            "payload.device_location.lat_grid".to_string(), // Grid-based aggregation\n            "payload.device_location.lon_grid".to_string(),\n        ],\n        metrics: vec![\n            AggregateMetric::Average {\n                field: "payload.readings.measurement.value.pm2_5".to_string(),\n            },\n            AggregateMetric::Max {\n                field: "payload.readings.measurement.value.pm2_5".to_string(),\n            },\n            AggregateMetric::Count,\n        ],\n    }),\n    sort: Some(SortBy {\n        field: "avg_pm2_5".to_string(),\n        ascending: false, // Highest pollution first\n    }),\n    limit: Some(100),\n    offset: 0,\n}).await?;\n\n// Historical trends for specific sensor\nlet sensor_trends = query_engine.execute(Query {\n    collection: "sensor_readings".to_string(),\n    filter: QueryOperator::And(vec![\n        QueryOperator::Equals {\n            field: "payload.device_id".to_string(),\n            value: specific_device_id.to_string(),\n        },\n        QueryOperator::GreaterThanEquals {\n            field: "timestamp".to_string(),\n            value: (current_timestamp() - 86400 * 7).to_string(), // Last 7 days\n        }\n    ]),\n    time_series: Some(TimeSeriesAggregation {\n        time_field: "timestamp".to_string(),\n        interval: "1h".to_string(), // Hourly buckets\n        metrics: vec![\n            TimeSeriesMetric::Average {\n                field: "payload.readings.measurement.value".to_string(),\n            },\n            TimeSeriesMetric::StdDev {\n                field: "payload.readings.measurement.value".to_string(),\n            },\n        ],\n        fill_missing: FillMissing::Linear,\n    }),\n    sort: Some(SortBy {\n        field: "timestamp".to_string(),\n        ascending: true,\n    }),\n    limit: None,\n    offset: 0,\n}).await?;\n\n// Find devices needing maintenance\nlet maintenance_candidates = query_engine.execute(Query {\n    collection: "device_reputation".to_string(),\n    filter: QueryOperator::And(vec![\n        QueryOperator::Or(vec![\n            QueryOperator::LessThan {\n                field: "payload.reliability_metrics.data_quality.value".to_string(),\n                value: "0.85".to_string(),\n            },\n            QueryOperator::LessThan {\n                field: "payload.reliability_metrics.uptime.value".to_string(),\n                value: "0.95".to_string(),\n            },\n        ]),\n        QueryOperator::GreaterThan {\n            field: "timestamp".to_string(),\n            value: (current_timestamp() - 86400 * 7).to_string(), // Recent evaluations\n        }\n    ]),\n    sort: Some(SortBy {\n        field: "payload.overall_reputation.trust_score".to_string(),\n        ascending: true, // Lowest trust first\n    }),\n    limit: Some(50),\n    offset: 0,\n}).await?;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"predictive-analytics",children:"Predictive Analytics"}),"\n",(0,a.jsx)(n.p,{children:"Machine learning models for predictive maintenance and environmental forecasting:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'// Predict sensor failure risk\nlet failure_prediction = predict_sensor_failures(\n    PredictionModel::MaintenanceRisk,\n    PredictionHorizon::Days(30),\n    vec![\n        PredictionFeature::DataQualityTrend,\n        PredictionFeature::UptimeHistory,\n        PredictionFeature::CalibrationDrift,\n        PredictionFeature::EnvironmentalStress,\n        PredictionFeature::DeviceAge,\n    ],\n    ModelParameters::from([\n        ("confidence_threshold".to_string(), "0.8".to_string()),\n        ("early_warning_days".to_string(), "7".to_string()),\n    ]),\n).await?;\n\n// Forecast air quality based on weather and traffic\nlet air_quality_forecast = generate_environmental_forecast(\n    ForecastType::AirQuality,\n    ForecastHorizon::Hours(24),\n    GeographicScope::City(city_id),\n    vec![\n        ForecastInput::WeatherData,\n        ForecastInput::TrafficPatterns,\n        ForecastInput::HistoricalSensorData,\n        ForecastInput::EmissionSources,\n    ],\n).await?;\n'})}),"\n",(0,a.jsx)(n.h2,{id:"results-and-benefits",children:"Results and Benefits"}),"\n",(0,a.jsx)(n.h3,{id:"operational-improvements",children:"Operational Improvements"}),"\n",(0,a.jsx)(n.p,{children:"After 18 months of full deployment across the city:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Data Quality and Reliability"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sensor data accuracy: 78% \u2192 96% (23% improvement)"}),"\n",(0,a.jsx)(n.li,{children:"False alarm rate: 12% \u2192 1.2% (90% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Data availability (uptime): 92% \u2192 99.1% (7.7% improvement)"}),"\n",(0,a.jsx)(n.li,{children:"Cross-sensor validation accuracy: 65% \u2192 94% (44% improvement)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Response Times and Efficiency"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Environmental incident detection: 45 minutes \u2192 3 minutes (93% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Maintenance scheduling accuracy: 60% \u2192 87% (45% improvement)"}),"\n",(0,a.jsx)(n.li,{children:"Emergency response deployment time: 12 minutes \u2192 4 minutes (67% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Manual data validation effort: 40 hours/week \u2192 2 hours/week (95% reduction)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Cost Savings and Resource Optimization"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sensor maintenance costs: $2.1M \u2192 $0.8M annually (62% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"False alarm response costs: $450K \u2192 $45K annually (90% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Data storage costs: $180K \u2192 $65K annually (64% reduction through edge processing)"}),"\n",(0,a.jsx)(n.li,{children:"Energy consumption: 15% reduction through optimized sampling strategies"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"technical-achievements",children:"Technical Achievements"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Scalability and Performance"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Concurrent sensor readings processed: 5K \u2192 50K per second (1000% improvement)"}),"\n",(0,a.jsx)(n.li,{children:"Average data processing latency: 2.3 seconds \u2192 180ms (92% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Network bandwidth utilization: 75% \u2192 23% (69% reduction through edge aggregation)"}),"\n",(0,a.jsx)(n.li,{children:"Query response time (complex analytics): 45 seconds \u2192 1.2 seconds (97% improvement)"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Security and Trust"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Unauthorized device connection attempts: 100% detection and prevention"}),"\n",(0,a.jsx)(n.li,{children:"Data tampering incidents: 23 \u2192 0 (100% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Cryptographic verification coverage: 0% \u2192 100% of all sensor data"}),"\n",(0,a.jsx)(n.li,{children:"Device identity spoofing: 5 incidents \u2192 0 incidents"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Interoperability and Standards"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Third-party system integrations: 3 \u2192 27 systems successfully connected"}),"\n",(0,a.jsx)(n.li,{children:"Data format standardization: 15% \u2192 100% compliance with city standards"}),"\n",(0,a.jsx)(n.li,{children:"Cross-vendor device compatibility: 45% \u2192 92% of devices interoperable"}),"\n",(0,a.jsx)(n.li,{children:"API usage by external developers: 0 \u2192 1,200 registered applications"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"environmental-and-social-impact",children:"Environmental and Social Impact"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Public Health Protection"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Air quality advisories issued: Average 2 hours faster notification"}),"\n",(0,a.jsx)(n.li,{children:"Heat island effect monitoring: 300% improvement in spatial resolution"}),"\n",(0,a.jsx)(n.li,{children:"Noise pollution complaints resolved: 78% faster average resolution"}),"\n",(0,a.jsx)(n.li,{children:"Environmental justice: Equitable sensor coverage across all neighborhoods"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Urban Planning and Policy"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Evidence-based policy decisions: 100% of environmental policies now data-driven"}),"\n",(0,a.jsx)(n.li,{children:"Traffic optimization: 18% reduction in average commute times"}),"\n",(0,a.jsx)(n.li,{children:"Energy efficiency improvements: 12% citywide energy consumption reduction"}),"\n",(0,a.jsx)(n.li,{children:"Green space optimization: Data-driven park and tree placement"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Citizen Engagement"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Public environmental data access: Real-time city dashboard with 45K monthly users"}),"\n",(0,a.jsx)(n.li,{children:"Community sensor program: 200 citizen-operated sensors integrated"}),"\n",(0,a.jsx)(n.li,{children:"Environmental awareness: 67% of residents regularly check air quality data"}),"\n",(0,a.jsx)(n.li,{children:"Transparency score: City ranked #2 nationally for environmental data transparency"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"edge-computing-architecture",children:"Edge Computing Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"hierarchical-processing-strategy",children:"Hierarchical Processing Strategy"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Device Layer (50,000+ IoT devices)\n\u251c\u2500 Basic sensor readings every 30s-5min\n\u251c\u2500 Local data validation and quality checks  \n\u251c\u2500 Emergency threshold detection\n\u2514\u2500 Secure transmission to edge gateways\n\nEdge Gateway Layer (200 gateways)\n\u251c\u2500 Aggregate 100-300 devices per gateway\n\u251c\u2500 Real-time anomaly detection (5-minute windows)\n\u251c\u2500 Predictive maintenance scoring\n\u251c\u2500 Local data storage (72-hour cache)\n\u2514\u2500 Intelligent data filtering and compression\n\nFog Processing Layer (20 regional nodes)  \n\u251c\u2500 Cross-gateway correlation analysis\n\u251c\u2500 Advanced ML model inference\n\u251c\u2500 City-wide pattern recognition\n\u251c\u2500 Emergency response coordination\n\u2514\u2500 Historical trend analysis (30-day windows)\n\nCloud Infrastructure (3 data centers)\n\u251c\u2500 Long-term data archival and compliance\n\u251c\u2500 Complex machine learning model training\n\u251c\u2500 City planning and policy analytics\n\u251c\u2500 Inter-city data sharing and benchmarking\n\u2514\u2500 Disaster recovery and backup systems\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bandwidth-optimization",children:"Bandwidth Optimization"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Data Compression Results"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Raw sensor data: 2.4 KB per reading"}),"\n",(0,a.jsx)(n.li,{children:"Edge-processed summaries: 0.3 KB per 5-minute aggregate (87% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"City-wide bandwidth usage: 450 GB/day \u2192 65 GB/day (86% reduction)"}),"\n",(0,a.jsx)(n.li,{children:"Real-time analytics latency: 2.3s \u2192 180ms through local processing"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Smart Sampling"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adaptive sampling rates based on environmental conditions"}),"\n",(0,a.jsx)(n.li,{children:"Higher frequency during anomaly detection (every 10s vs. normal 5min)"}),"\n",(0,a.jsx)(n.li,{children:"Coordinated sampling to avoid network congestion"}),"\n",(0,a.jsx)(n.li,{children:"Battery life optimization: 2 years \u2192 4.5 years average device lifetime"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"privacy-and-regulatory-compliance",children:"Privacy and Regulatory Compliance"}),"\n",(0,a.jsx)(n.h3,{id:"data-governance-framework",children:"Data Governance Framework"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Location Privacy Protection"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Spatial obfuscation for residential area sensors (50m grid cells)"}),"\n",(0,a.jsx)(n.li,{children:"Differential privacy for aggregate statistics"}),"\n",(0,a.jsx)(n.li,{children:"Opt-out mechanisms for private property monitoring"}),"\n",(0,a.jsx)(n.li,{children:"Legal frameworks for emergency override capabilities"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"GDPR and Privacy Compliance"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automated data retention policies (environmental data: 7 years, personal data: 2 years)"}),"\n",(0,a.jsx)(n.li,{children:"Right to be forgotten implementation for citizen-contributed data"}),"\n",(0,a.jsx)(n.li,{children:"Data portability for research institutions and citizen scientists"}),"\n",(0,a.jsx)(n.li,{children:"Consent management for enhanced analytics programs"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Regulatory Reporting"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automated EPA compliance reporting (monthly air quality reports)"}),"\n",(0,a.jsx)(n.li,{children:"Chain of custody for legal proceedings (environmental violations)"}),"\n",(0,a.jsx)(n.li,{children:"Audit trails for all data access and modification"}),"\n",(0,a.jsx)(n.li,{children:"Inter-agency data sharing with proper authorization"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,a.jsx)(n.h3,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edge-First Architecture"}),": Process data as close to sensors as possible to reduce latency and bandwidth"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gradual Rollout Strategy"}),": Start with high-value corridors before city-wide deployment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Multi-Vendor Compatibility"}),": Standardize on protocols rather than specific hardware vendors"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Predictive Maintenance"}),": Proactive device management reduces costs and improves reliability"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Quality Over Quantity"}),": Better to have fewer high-quality sensors than many unreliable ones"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"operational-insights",children:"Operational Insights"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Stakeholder Engagement"}),": Early involvement of city departments, citizens, and environmental groups critical"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Emergency Integration"}),": Seamless integration with existing emergency response systems essential"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Maintenance Logistics"}),": Plan for scale - 50K devices require sophisticated logistics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance Monitoring"}),": Continuous monitoring of system health and data quality mandatory"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Staff Training"}),": Significant investment in training city staff on new data-driven workflows"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"policy-and-governance",children:"Policy and Governance"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Ownership"}),": Clear policies on who owns and can access different types of environmental data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Privacy Balance"}),": Balance transparency with privacy - not all location data should be public"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Inter-City Cooperation"}),": Standardized approaches enable regional environmental monitoring"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Vendor Lock-In Prevention"}),": Open standards and multiple vendor support prevents dependency"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Funding Models"}),": Sustainable funding requires demonstrating clear ROI and citizen benefits"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"future-expansion",children:"Future Expansion"}),"\n",(0,a.jsx)(n.p,{children:"SmartCity Infrastructure is expanding their Olocus Protocol implementation to include:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Next-Generation Sensors"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Acoustic monitoring for noise pollution and emergency detection"}),"\n",(0,a.jsx)(n.li,{children:"Soil quality sensors in parks and urban agriculture"}),"\n",(0,a.jsx)(n.li,{children:"Water quality monitoring in storm drains and waterways"}),"\n",(0,a.jsx)(n.li,{children:"Traffic flow optimization with computer vision integration"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Advanced Analytics"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Climate change adaptation modeling"}),"\n",(0,a.jsx)(n.li,{children:"Urban heat island mitigation strategies"}),"\n",(0,a.jsx)(n.li,{children:"Predictive flood detection and management"}),"\n",(0,a.jsx)(n.li,{children:"Air quality health impact assessment"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Regional Coordination"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Multi-city environmental data sharing"}),"\n",(0,a.jsx)(n.li,{children:"Regional air quality management"}),"\n",(0,a.jsx)(n.li,{children:"Climate change impact coordination"}),"\n",(0,a.jsx)(n.li,{children:"Emergency response mutual aid systems"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Citizen Participation"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Personal air quality monitors integrated with city network"}),"\n",(0,a.jsx)(n.li,{children:"Community sensor programs with data validation"}),"\n",(0,a.jsx)(n.li,{children:"Environmental justice monitoring in disadvantaged communities"}),"\n",(0,a.jsx)(n.li,{children:"Gamified citizen science environmental programs"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"code-repository",children:"Code Repository"}),"\n",(0,a.jsx)(n.p,{children:"Complete implementation including device firmware, edge processing, and cloud analytics:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://codeberg.org/examples/smartcity-iot-platform",children:"SmartCity IoT Platform"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://codeberg.org/examples/smartcity-device-sdk",children:"Device Firmware SDK"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://codeberg.org/examples/smartcity-edge-framework",children:"Edge Processing Framework"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://codeberg.org/examples/smartcity-citizen-app",children:"Citizen Environmental App"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.smartcity.gov/iot-deployment",children:"Deployment Documentation"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This case study demonstrates how Olocus Protocol can transform IoT infrastructure into a trustworthy, scalable, and privacy-preserving system that benefits citizens, government, and the environment while maintaining security and regulatory compliance at massive scale."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);