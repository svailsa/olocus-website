"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[8664],{6326:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/infrastructure/http-api","title":"HTTP REST API for Block Operations","description":"The HTTP extension provides a comprehensive REST API for interacting with Olocus Protocol blocks over HTTP. It supports all wire formats, provides efficient block operations, and includes features like pagination, filtering, and health monitoring.","source":"@site/docs/extensions/infrastructure/http-api.md","sourceDirName":"extensions/infrastructure","slug":"/extensions/infrastructure/http-api","permalink":"/docs/extensions/infrastructure/http-api","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/infrastructure/http-api.md","tags":[],"version":"current","lastUpdatedAt":1764951516000,"sidebarPosition":6,"frontMatter":{"id":"http-api","title":"HTTP REST API for Block Operations","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Network","permalink":"/docs/extensions/infrastructure/network"},"next":{"title":"Metrics Collection and Export","permalink":"/docs/extensions/infrastructure/metrics"}}');var o=t(4848),s=t(8453);const i={id:"http-api",title:"HTTP REST API for Block Operations",sidebar_position:6},a="HTTP REST API for Block Operations",l={},c=[{value:"Overview",id:"overview",level:2},{value:"HTTP Server Implementation",id:"http-server-implementation",level:2},{value:"Core HTTP Server",id:"core-http-server",level:3},{value:"API Endpoints",id:"api-endpoints",level:2},{value:"Block Submission",id:"block-submission",level:3},{value:"Block Retrieval",id:"block-retrieval",level:3},{value:"Block Listing",id:"block-listing",level:3},{value:"Block Deletion",id:"block-deletion",level:3},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:2},{value:"Rate Limiting",id:"rate-limiting",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Client Library",id:"client-library",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Server Setup",id:"basic-server-setup",level:3},{value:"Client Usage",id:"client-usage",level:3},{value:"Production Configuration",id:"production-configuration",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"http-rest-api-for-block-operations",children:"HTTP REST API for Block Operations"})}),"\n",(0,o.jsx)(n.p,{children:"The HTTP extension provides a comprehensive REST API for interacting with Olocus Protocol blocks over HTTP. It supports all wire formats, provides efficient block operations, and includes features like pagination, filtering, and health monitoring."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"The HTTP API enables web applications, services, and tools to interact with Olocus Protocol:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Block Operations"}),": Submit, retrieve, and manage blocks"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Wire Format Support"}),": JSON, MessagePack, Protobuf, SSZ encoding"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Storage Integration"}),": Pluggable storage backends"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"RESTful Design"}),": Standard HTTP methods and status codes"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance"}),": Efficient pagination and bulk operations"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::*;\nuse olocus_storage::memory::MemoryStorage;\n\n// Configure HTTP server\nlet http_config = HttpConfig {\n    bind_addr: "0.0.0.0:8080".parse()?,\n    max_block_size: 1024 * 1024, // 1MB\n    default_page_size: 50,\n    max_page_size: 1000,\n    request_timeout: Duration::from_secs(30),\n    cors_enabled: true,\n    compression_enabled: true,\n};\n\nlet storage = Box::new(MemoryStorage::new());\nlet server = HttpServer::new(http_config, storage).await?;\nserver.start().await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"http-server-implementation",children:"HTTP Server Implementation"}),"\n",(0,o.jsx)(n.h3,{id:"core-http-server",children:"Core HTTP Server"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::server::*;\nuse olocus_core::*;\nuse olocus_storage::traits::*;\n\n#[derive(Debug)]\npub struct HttpServer {\n    config: HttpConfig,\n    storage: Box<dyn BlockStorage>,\n    server_handle: Option<JoinHandle<()>>,\n}\n\n#[derive(Debug, Clone)]\npub struct HttpConfig {\n    pub bind_addr: SocketAddr,\n    pub max_block_size: usize,\n    pub default_page_size: usize,\n    pub max_page_size: usize,\n    pub request_timeout: Duration,\n    pub cors_enabled: bool,\n    pub compression_enabled: bool,\n    pub rate_limit: Option<RateLimit>,\n    pub auth_config: Option<AuthConfig>,\n}\n\nimpl Default for HttpConfig {\n    fn default() -> Self {\n        Self {\n            bind_addr: "127.0.0.1:8080".parse().unwrap(),\n            max_block_size: 1024 * 1024, // 1MB\n            default_page_size: 50,\n            max_page_size: 1000,\n            request_timeout: Duration::from_secs(30),\n            cors_enabled: false,\n            compression_enabled: true,\n            rate_limit: None,\n            auth_config: None,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct RateLimit {\n    pub requests_per_second: u32,\n    pub burst_size: u32,\n    pub window_size: Duration,\n}\n\n#[derive(Debug, Clone)]\npub struct AuthConfig {\n    pub enabled: bool,\n    pub api_key_header: String,\n    pub valid_api_keys: Vec<String>,\n    pub jwt_secret: Option<String>,\n}\n\nimpl HttpServer {\n    pub fn new(config: HttpConfig, storage: Box<dyn BlockStorage>) -> Self {\n        Self {\n            config,\n            storage,\n            server_handle: None,\n        }\n    }\n\n    pub async fn start(&mut self) -> Result<()> {\n        let config = self.config.clone();\n        let storage = self.storage.clone(); // Would need Arc<Mutex<>> in practice\n        \n        let routes = self.build_routes(storage, config.clone()).await?;\n        \n        let server = if config.cors_enabled {\n            warp::serve(routes.with(warp::cors().allow_any_origin()))\n        } else {\n            warp::serve(routes)\n        };\n        \n        let handle = tokio::spawn(async move {\n            server.run(config.bind_addr).await;\n        });\n        \n        self.server_handle = Some(handle);\n        Ok(())\n    }\n    \n    async fn build_routes(\n        &self, \n        storage: Box<dyn BlockStorage>, \n        config: HttpConfig\n    ) -> Result<impl Filter<Extract = impl warp::Reply> + Clone> {\n        \n        // Health endpoint\n        let health = warp::path("health")\n            .and(warp::get())\n            .and_then(|| async { \n                Ok::<_, Infallible>(warp::reply::json(&HealthResponse {\n                    status: "ok".to_string(),\n                    timestamp: SystemTime::now(),\n                }))\n            });\n        \n        // Block submission endpoint\n        let submit_block = warp::path("blocks")\n            .and(warp::post())\n            .and(warp::body::content_length_limit(config.max_block_size as u64))\n            .and(warp::body::bytes())\n            .and(warp::header::optional::<String>("content-type"))\n            .and(with_storage(storage.clone()))\n            .and_then(submit_block_handler);\n        \n        // Block retrieval by hash\n        let get_block = warp::path!("blocks" / String)\n            .and(warp::get())\n            .and(warp::header::optional::<String>("accept"))\n            .and(with_storage(storage.clone()))\n            .and_then(get_block_handler);\n        \n        // Block listing with pagination\n        let list_blocks = warp::path("blocks")\n            .and(warp::get())\n            .and(warp::query::<ListBlocksQuery>())\n            .and(warp::header::optional::<String>("accept"))\n            .and(with_storage(storage.clone()))\n            .and_then(list_blocks_handler);\n        \n        // Block deletion\n        let delete_block = warp::path!("blocks" / String)\n            .and(warp::delete())\n            .and(with_storage(storage.clone()))\n            .and_then(delete_block_handler);\n        \n        // Batch operations\n        let batch_submit = warp::path("blocks" / "batch")\n            .and(warp::post())\n            .and(warp::body::content_length_limit(config.max_block_size as u64 * 100))\n            .and(warp::body::bytes())\n            .and(warp::header::optional::<String>("content-type"))\n            .and(with_storage(storage.clone()))\n            .and_then(batch_submit_handler);\n        \n        let routes = health\n            .or(submit_block)\n            .or(get_block)\n            .or(list_blocks)\n            .or(delete_block)\n            .or(batch_submit)\n            .with(warp::trace::request());\n        \n        // Add compression if enabled\n        if config.compression_enabled {\n            Ok(routes.with(warp::compression::gzip()).boxed())\n        } else {\n            Ok(routes.boxed())\n        }\n    }\n}\n\nfn with_storage(\n    storage: Box<dyn BlockStorage>\n) -> impl Filter<Extract = (Box<dyn BlockStorage>,)> + Clone {\n    warp::any().map(move || storage.clone())\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"api-endpoints",children:"API Endpoints"}),"\n",(0,o.jsx)(n.h3,{id:"block-submission",children:"Block Submission"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::handlers::*;\n\n#[derive(Debug, Deserialize)]\npub struct SubmitBlockRequest {\n    pub block: Block<serde_json::Value>,\n    pub wire_format: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct SubmitBlockResponse {\n    pub block_hash: String,\n    pub index: u64,\n    pub timestamp: SystemTime,\n}\n\npub async fn submit_block_handler(\n    body: Bytes,\n    content_type: Option<String>,\n    storage: Box<dyn BlockStorage>,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    \n    // Determine wire format from content type\n    let wire_format = match content_type.as_deref() {\n        Some("application/json") => WireFormat::json(),\n        Some("application/msgpack") => WireFormat::messagepack(),\n        Some("application/x-protobuf") => WireFormat::protobuf(),\n        Some("application/ssz") => WireFormat::ssz(),\n        _ => WireFormat::json(), // Default to JSON\n    };\n    \n    // Parse block from request body\n    let block = Block::from_wire_format(&body, wire_format)\n        .map_err(|e| warp::reject::custom(ApiError::InvalidBlock(e.to_string())))?;\n    \n    // Validate block\n    if !block.verify_signature() {\n        return Err(warp::reject::custom(ApiError::InvalidSignature));\n    }\n    \n    // Store block\n    let block_hash = storage.store_block(&block).await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    let response = SubmitBlockResponse {\n        block_hash: block_hash.to_string(),\n        index: block.index,\n        timestamp: block.timestamp,\n    };\n    \n    Ok(warp::reply::with_status(\n        warp::reply::json(&response),\n        StatusCode::CREATED\n    ))\n}\n\npub async fn batch_submit_handler(\n    body: Bytes,\n    content_type: Option<String>,\n    storage: Box<dyn BlockStorage>,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    \n    // Determine wire format\n    let wire_format = match content_type.as_deref() {\n        Some("application/json") => WireFormat::json(),\n        Some("application/msgpack") => WireFormat::messagepack(),\n        _ => WireFormat::json(),\n    };\n    \n    // Parse blocks array\n    let blocks: Vec<Block<serde_json::Value>> = match wire_format.encoding {\n        Encoding::JSON => serde_json::from_slice(&body)\n            .map_err(|e| warp::reject::custom(ApiError::InvalidRequest(e.to_string())))?,\n        Encoding::MessagePack => rmp_serde::from_slice(&body)\n            .map_err(|e| warp::reject::custom(ApiError::InvalidRequest(e.to_string())))?,\n        _ => return Err(warp::reject::custom(ApiError::UnsupportedFormat)),\n    };\n    \n    // Validate all blocks first\n    for block in &blocks {\n        if !block.verify_signature() {\n            return Err(warp::reject::custom(ApiError::InvalidSignature));\n        }\n    }\n    \n    // Store all blocks\n    let block_hashes = storage.store_blocks(&blocks).await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    let responses: Vec<SubmitBlockResponse> = blocks.iter()\n        .zip(block_hashes.iter())\n        .map(|(block, hash)| SubmitBlockResponse {\n            block_hash: hash.to_string(),\n            index: block.index,\n            timestamp: block.timestamp,\n        })\n        .collect();\n    \n    Ok(warp::reply::with_status(\n        warp::reply::json(&responses),\n        StatusCode::CREATED\n    ))\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"block-retrieval",children:"Block Retrieval"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'pub async fn get_block_handler(\n    block_hash: String,\n    accept: Option<String>,\n    storage: Box<dyn BlockStorage>,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    \n    // Parse block hash\n    let hash = BlockHash::from_string(&block_hash)\n        .map_err(|_| warp::reject::custom(ApiError::InvalidHash))?;\n    \n    // Retrieve block from storage\n    let block = storage.retrieve_block(&hash).await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    let block = match block {\n        Some(b) => b,\n        None => return Err(warp::reject::not_found()),\n    };\n    \n    // Determine response format from Accept header\n    let wire_format = match accept.as_deref() {\n        Some("application/json") => WireFormat::json(),\n        Some("application/msgpack") => WireFormat::messagepack(),\n        Some("application/x-protobuf") => WireFormat::protobuf(),\n        Some("application/ssz") => WireFormat::ssz(),\n        _ => WireFormat::json(),\n    };\n    \n    // Serialize block to requested format\n    let response_data = block.to_wire_format(wire_format)\n        .map_err(|e| warp::reject::custom(ApiError::SerializationError(e.to_string())))?;\n    \n    let content_type = match wire_format.encoding {\n        Encoding::JSON => "application/json",\n        Encoding::MessagePack => "application/msgpack",\n        Encoding::Protobuf => "application/x-protobuf",\n        Encoding::SSZ => "application/ssz",\n        _ => "application/octet-stream",\n    };\n    \n    Ok(warp::reply::with_header(\n        response_data,\n        "content-type",\n        content_type,\n    ))\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"block-listing",children:"Block Listing"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, Deserialize)]\npub struct ListBlocksQuery {\n    pub page: Option<usize>,\n    pub size: Option<usize>,\n    pub start_time: Option<u64>, // Unix timestamp\n    pub end_time: Option<u64>,   // Unix timestamp\n    pub order: Option<String>,   // "asc" or "desc"\n    pub filter: Option<String>,  // JSON filter expression\n}\n\n#[derive(Debug, Serialize)]\npub struct ListBlocksResponse {\n    pub blocks: Vec<BlockSummary>,\n    pub pagination: PaginationInfo,\n}\n\n#[derive(Debug, Serialize)]\npub struct BlockSummary {\n    pub hash: String,\n    pub index: u64,\n    pub timestamp: SystemTime,\n    pub previous_hash: Option<String>,\n    pub payload_type: String,\n    pub size_bytes: usize,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaginationInfo {\n    pub page: usize,\n    pub size: usize,\n    pub total_count: u64,\n    pub total_pages: usize,\n    pub has_next: bool,\n    pub has_previous: bool,\n}\n\npub async fn list_blocks_handler(\n    query: ListBlocksQuery,\n    accept: Option<String>,\n    storage: Box<dyn BlockStorage>,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    \n    // Parse pagination parameters\n    let page = query.page.unwrap_or(0);\n    let size = query.size.unwrap_or(50).min(1000); // Cap at 1000\n    let offset = page * size;\n    \n    // Parse time filters\n    let start_time = query.start_time.map(|ts| {\n        SystemTime::UNIX_EPOCH + Duration::from_secs(ts)\n    });\n    let end_time = query.end_time.map(|ts| {\n        SystemTime::UNIX_EPOCH + Duration::from_secs(ts)\n    });\n    \n    // Parse order\n    let order = match query.order.as_deref() {\n        Some("desc") => SortOrder::Descending,\n        Some("asc") => SortOrder::Ascending,\n        _ => SortOrder::Descending, // Default to newest first\n    };\n    \n    // Build list options\n    let list_options = ListOptions {\n        limit: Some(size as u64),\n        offset: Some(offset as u64),\n        start_time,\n        end_time,\n        order,\n        filter: query.filter.map(|f| BlockFilter::from_json(&f)).transpose()\n            .map_err(|e| warp::reject::custom(ApiError::InvalidFilter(e.to_string())))?,\n    };\n    \n    // Get total count for pagination\n    let total_count = storage.count_blocks().await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    // Retrieve block metadata\n    let block_metadata = storage.list_blocks(&list_options).await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    // Convert to summaries\n    let block_summaries: Vec<BlockSummary> = block_metadata.into_iter()\n        .map(|meta| BlockSummary {\n            hash: meta.hash.to_string(),\n            index: meta.index,\n            timestamp: meta.timestamp,\n            previous_hash: meta.previous_hash.map(|h| h.to_string()),\n            payload_type: meta.payload_type,\n            size_bytes: meta.size_bytes,\n        })\n        .collect();\n    \n    // Calculate pagination info\n    let total_pages = ((total_count as usize + size - 1) / size).max(1);\n    let pagination = PaginationInfo {\n        page,\n        size,\n        total_count,\n        total_pages,\n        has_next: page + 1 < total_pages,\n        has_previous: page > 0,\n    };\n    \n    let response = ListBlocksResponse {\n        blocks: block_summaries,\n        pagination,\n    };\n    \n    // Determine response format\n    let wire_format = match accept.as_deref() {\n        Some("application/json") => WireFormat::json(),\n        Some("application/msgpack") => WireFormat::messagepack(),\n        _ => WireFormat::json(),\n    };\n    \n    match wire_format.encoding {\n        Encoding::JSON => Ok(warp::reply::json(&response)),\n        Encoding::MessagePack => {\n            let data = rmp_serde::to_vec(&response)\n                .map_err(|e| warp::reject::custom(ApiError::SerializationError(e.to_string())))?;\n            Ok(warp::reply::with_header(\n                data,\n                "content-type",\n                "application/msgpack",\n            ))\n        }\n        _ => Err(warp::reject::custom(ApiError::UnsupportedFormat)),\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"block-deletion",children:"Block Deletion"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'pub async fn delete_block_handler(\n    block_hash: String,\n    storage: Box<dyn BlockStorage>,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    \n    // Parse block hash\n    let hash = BlockHash::from_string(&block_hash)\n        .map_err(|_| warp::reject::custom(ApiError::InvalidHash))?;\n    \n    // Delete block from storage\n    let deleted = storage.delete_block(&hash).await\n        .map_err(|e| warp::reject::custom(ApiError::StorageError(e.to_string())))?;\n    \n    if deleted {\n        Ok(warp::reply::with_status(\n            warp::reply::json(&serde_json::json!({\n                "deleted": true,\n                "block_hash": block_hash\n            })),\n            StatusCode::OK\n        ))\n    } else {\n        Err(warp::reject::not_found())\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::auth::*;\n\n#[derive(Debug)]\npub struct ApiKeyAuth {\n    valid_keys: HashSet<String>,\n    header_name: String,\n}\n\nimpl ApiKeyAuth {\n    pub fn new(valid_keys: Vec<String>, header_name: String) -> Self {\n        Self {\n            valid_keys: valid_keys.into_iter().collect(),\n            header_name,\n        }\n    }\n    \n    pub fn filter(&self) -> impl Filter<Extract = (String,)> + Clone {\n        let valid_keys = self.valid_keys.clone();\n        let header_name = self.header_name.clone();\n        \n        warp::header::header(&header_name)\n            .and_then(move |api_key: String| {\n                let valid_keys = valid_keys.clone();\n                async move {\n                    if valid_keys.contains(&api_key) {\n                        Ok(api_key)\n                    } else {\n                        Err(warp::reject::custom(ApiError::Unauthorized))\n                    }\n                }\n            })\n    }\n}\n\n#[derive(Debug)]\npub struct JwtAuth {\n    secret: String,\n    algorithm: Algorithm,\n}\n\nimpl JwtAuth {\n    pub fn new(secret: String) -> Self {\n        Self {\n            secret,\n            algorithm: Algorithm::HS256,\n        }\n    }\n    \n    pub fn filter(&self) -> impl Filter<Extract = (Claims,)> + Clone {\n        let secret = self.secret.clone();\n        \n        warp::header::header::<String>("authorization")\n            .and_then(move |auth_header: String| {\n                let secret = secret.clone();\n                async move {\n                    if let Some(token) = auth_header.strip_prefix("Bearer ") {\n                        match decode::<Claims>(\n                            token,\n                            &DecodingKey::from_secret(secret.as_ref()),\n                            &Validation::new(Algorithm::HS256),\n                        ) {\n                            Ok(token_data) => Ok(token_data.claims),\n                            Err(_) => Err(warp::reject::custom(ApiError::Unauthorized)),\n                        }\n                    } else {\n                        Err(warp::reject::custom(ApiError::Unauthorized))\n                    }\n                }\n            })\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    pub sub: String,\n    pub exp: usize,\n    pub iat: usize,\n    pub permissions: Vec<String>,\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_http::ratelimit::*;\nuse std::collections::HashMap;\nuse tokio::sync::Mutex;\n\n#[derive(Debug)]\npub struct RateLimiter {\n    config: RateLimit,\n    clients: Arc<Mutex<HashMap<IpAddr, ClientState>>>,\n}\n\n#[derive(Debug)]\nstruct ClientState {\n    tokens: f64,\n    last_refill: Instant,\n}\n\nimpl RateLimiter {\n    pub fn new(config: RateLimit) -> Self {\n        Self {\n            config,\n            clients: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    \n    pub fn filter(&self) -> impl Filter<Extract = ()> + Clone {\n        let limiter = self.clone();\n        \n        warp::filters::addr::remote()\n            .and_then(move |addr: Option<SocketAddr>| {\n                let limiter = limiter.clone();\n                async move {\n                    if let Some(socket_addr) = addr {\n                        if limiter.check_rate_limit(socket_addr.ip()).await {\n                            Ok(())\n                        } else {\n                            Err(warp::reject::custom(ApiError::RateLimitExceeded))\n                        }\n                    } else {\n                        Ok(()) // Allow if no IP available\n                    }\n                }\n            })\n    }\n    \n    async fn check_rate_limit(&self, ip: IpAddr) -> bool {\n        let mut clients = self.clients.lock().await;\n        let now = Instant::now();\n        \n        let client_state = clients.entry(ip).or_insert(ClientState {\n            tokens: self.config.burst_size as f64,\n            last_refill: now,\n        });\n        \n        // Calculate tokens to add based on time elapsed\n        let elapsed = now.duration_since(client_state.last_refill);\n        let tokens_to_add = elapsed.as_secs_f64() * self.config.requests_per_second as f64;\n        \n        client_state.tokens = (client_state.tokens + tokens_to_add)\n            .min(self.config.burst_size as f64);\n        client_state.last_refill = now;\n        \n        // Check if request can be allowed\n        if client_state.tokens >= 1.0 {\n            client_state.tokens -= 1.0;\n            true\n        } else {\n            false\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::error::*;\n\n#[derive(Debug, thiserror::Error)]\npub enum ApiError {\n    #[error("Invalid block: {0}")]\n    InvalidBlock(String),\n    \n    #[error("Invalid signature")]\n    InvalidSignature,\n    \n    #[error("Invalid hash format")]\n    InvalidHash,\n    \n    #[error("Invalid request: {0}")]\n    InvalidRequest(String),\n    \n    #[error("Invalid filter: {0}")]\n    InvalidFilter(String),\n    \n    #[error("Unsupported format")]\n    UnsupportedFormat,\n    \n    #[error("Storage error: {0}")]\n    StorageError(String),\n    \n    #[error("Serialization error: {0}")]\n    SerializationError(String),\n    \n    #[error("Unauthorized")]\n    Unauthorized,\n    \n    #[error("Rate limit exceeded")]\n    RateLimitExceeded,\n    \n    #[error("Request timeout")]\n    Timeout,\n}\n\nimpl warp::reject::Reject for ApiError {}\n\npub async fn handle_rejection(err: warp::Rejection) -> Result<impl warp::Reply, Infallible> {\n    let (code, message) = if err.is_not_found() {\n        (StatusCode::NOT_FOUND, "Not Found".to_string())\n    } else if let Some(api_error) = err.find::<ApiError>() {\n        match api_error {\n            ApiError::InvalidBlock(_) | ApiError::InvalidRequest(_) | ApiError::InvalidFilter(_) => {\n                (StatusCode::BAD_REQUEST, api_error.to_string())\n            }\n            ApiError::InvalidSignature => {\n                (StatusCode::UNPROCESSABLE_ENTITY, api_error.to_string())\n            }\n            ApiError::InvalidHash => {\n                (StatusCode::BAD_REQUEST, api_error.to_string())\n            }\n            ApiError::UnsupportedFormat => {\n                (StatusCode::UNSUPPORTED_MEDIA_TYPE, api_error.to_string())\n            }\n            ApiError::StorageError(_) | ApiError::SerializationError(_) => {\n                (StatusCode::INTERNAL_SERVER_ERROR, "Internal Server Error".to_string())\n            }\n            ApiError::Unauthorized => {\n                (StatusCode::UNAUTHORIZED, "Unauthorized".to_string())\n            }\n            ApiError::RateLimitExceeded => {\n                (StatusCode::TOO_MANY_REQUESTS, "Rate limit exceeded".to_string())\n            }\n            ApiError::Timeout => {\n                (StatusCode::REQUEST_TIMEOUT, "Request timeout".to_string())\n            }\n        }\n    } else if err.find::<warp::filters::body::BodyDeserializeError>().is_some() {\n        (StatusCode::BAD_REQUEST, "Invalid request body".to_string())\n    } else if err.find::<warp::reject::MethodNotAllowed>().is_some() {\n        (StatusCode::METHOD_NOT_ALLOWED, "Method not allowed".to_string())\n    } else {\n        (StatusCode::INTERNAL_SERVER_ERROR, "Internal Server Error".to_string())\n    };\n\n    let error_response = ErrorResponse {\n        error: message,\n        code: code.as_u16(),\n        timestamp: SystemTime::now(),\n    };\n\n    Ok(warp::reply::with_status(\n        warp::reply::json(&error_response),\n        code,\n    ))\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorResponse {\n    pub error: String,\n    pub code: u16,\n    pub timestamp: SystemTime,\n}\n\n#[derive(Debug, Serialize)]\npub struct HealthResponse {\n    pub status: String,\n    pub timestamp: SystemTime,\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"client-library",children:"Client Library"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::client::*;\n\n#[derive(Debug)]\npub struct HttpClient {\n    base_url: String,\n    client: reqwest::Client,\n    default_format: WireFormat,\n}\n\nimpl HttpClient {\n    pub fn new(base_url: String) -> Self {\n        Self {\n            base_url,\n            client: reqwest::Client::new(),\n            default_format: WireFormat::json(),\n        }\n    }\n    \n    pub async fn submit_block(&self, block: &Block<impl BlockPayload>) -> Result<SubmitBlockResponse> {\n        let url = format!("{}/blocks", self.base_url);\n        let body = block.to_wire_format(self.default_format)?;\n        \n        let response = self.client\n            .post(&url)\n            .header("content-type", self.default_format.content_type())\n            .body(body)\n            .send()\n            .await?;\n        \n        if response.status().is_success() {\n            let submit_response: SubmitBlockResponse = response.json().await?;\n            Ok(submit_response)\n        } else {\n            let error: ErrorResponse = response.json().await?;\n            Err(ApiError::from(error).into())\n        }\n    }\n    \n    pub async fn get_block(&self, block_hash: &str) -> Result<Option<Block<serde_json::Value>>> {\n        let url = format!("{}/blocks/{}", self.base_url, block_hash);\n        \n        let response = self.client\n            .get(&url)\n            .header("accept", self.default_format.content_type())\n            .send()\n            .await?;\n        \n        match response.status() {\n            StatusCode::OK => {\n                let body = response.bytes().await?;\n                let block = Block::from_wire_format(&body, self.default_format)?;\n                Ok(Some(block))\n            }\n            StatusCode::NOT_FOUND => Ok(None),\n            _ => {\n                let error: ErrorResponse = response.json().await?;\n                Err(ApiError::from(error).into())\n            }\n        }\n    }\n    \n    pub async fn list_blocks(&self, query: &ListBlocksQuery) -> Result<ListBlocksResponse> {\n        let url = format!("{}/blocks", self.base_url);\n        \n        let response = self.client\n            .get(&url)\n            .query(query)\n            .header("accept", "application/json")\n            .send()\n            .await?;\n        \n        if response.status().is_success() {\n            let list_response: ListBlocksResponse = response.json().await?;\n            Ok(list_response)\n        } else {\n            let error: ErrorResponse = response.json().await?;\n            Err(ApiError::from(error).into())\n        }\n    }\n    \n    pub async fn delete_block(&self, block_hash: &str) -> Result<bool> {\n        let url = format!("{}/blocks/{}", self.base_url, block_hash);\n        \n        let response = self.client\n            .delete(&url)\n            .send()\n            .await?;\n        \n        match response.status() {\n            StatusCode::OK => Ok(true),\n            StatusCode::NOT_FOUND => Ok(false),\n            _ => {\n                let error: ErrorResponse = response.json().await?;\n                Err(ApiError::from(error).into())\n            }\n        }\n    }\n    \n    pub async fn health_check(&self) -> Result<HealthResponse> {\n        let url = format!("{}/health", self.base_url);\n        \n        let response = self.client\n            .get(&url)\n            .send()\n            .await?;\n        \n        let health_response: HealthResponse = response.json().await?;\n        Ok(health_response)\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,o.jsx)(n.h3,{id:"basic-server-setup",children:"Basic Server Setup"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::*;\nuse olocus_storage::memory::MemoryStorage;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Configure server\n    let config = HttpConfig {\n        bind_addr: "0.0.0.0:8080".parse()?,\n        max_block_size: 2 * 1024 * 1024, // 2MB\n        default_page_size: 100,\n        cors_enabled: true,\n        compression_enabled: true,\n        ..Default::default()\n    };\n    \n    // Use memory storage for this example\n    let storage = Box::new(MemoryStorage::new());\n    \n    // Start server\n    let mut server = HttpServer::new(config, storage);\n    server.start().await?;\n    \n    println!("HTTP server running on http://0.0.0.0:8080");\n    \n    // Keep running\n    tokio::signal::ctrl_c().await?;\n    Ok(())\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"client-usage",children:"Client Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::client::*;\nuse olocus_core::*;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let client = HttpClient::new("http://localhost:8080".to_string());\n    \n    // Check health\n    let health = client.health_check().await?;\n    println!("Server status: {}", health.status);\n    \n    // Submit a block\n    let block = Block::new(\n        0,\n        None,\n        serde_json::json!({"message": "Hello, Olocus!"}),\n        SystemTime::now(),\n    )?;\n    \n    let response = client.submit_block(&block).await?;\n    println!("Block submitted: {}", response.block_hash);\n    \n    // Retrieve the block\n    if let Some(retrieved_block) = client.get_block(&response.block_hash).await? {\n        println!("Retrieved block index: {}", retrieved_block.index);\n    }\n    \n    // List blocks\n    let query = ListBlocksQuery {\n        page: Some(0),\n        size: Some(10),\n        order: Some("desc".to_string()),\n        ..Default::default()\n    };\n    \n    let list_response = client.list_blocks(&query).await?;\n    println!("Found {} blocks", list_response.blocks.len());\n    \n    Ok(())\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"production-configuration",children:"Production Configuration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_http::*;\nuse olocus_storage::rocksdb::RocksDBStorage;\n\nasync fn production_server() -> Result<()> {\n    let config = HttpConfig {\n        bind_addr: "0.0.0.0:8080".parse()?,\n        max_block_size: 10 * 1024 * 1024, // 10MB\n        default_page_size: 50,\n        max_page_size: 500,\n        request_timeout: Duration::from_secs(30),\n        cors_enabled: false, // Disable in production\n        compression_enabled: true,\n        rate_limit: Some(RateLimit {\n            requests_per_second: 100,\n            burst_size: 200,\n            window_size: Duration::from_secs(60),\n        }),\n        auth_config: Some(AuthConfig {\n            enabled: true,\n            api_key_header: "X-API-Key".to_string(),\n            valid_api_keys: vec![\n                "api_key_1".to_string(),\n                "api_key_2".to_string(),\n            ],\n            jwt_secret: Some("your-secret-key".to_string()),\n        }),\n    };\n    \n    let storage = Box::new(RocksDBStorage::new("./blocks_db")?);\n    let mut server = HttpServer::new(config, storage);\n    server.start().await?;\n    \n    Ok(())\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Metric"}),(0,o.jsx)(n.th,{children:"Value"}),(0,o.jsx)(n.th,{children:"Notes"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Max Throughput"}),(0,o.jsx)(n.td,{children:"1000 req/s"}),(0,o.jsx)(n.td,{children:"With compression and caching"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Avg Latency"}),(0,o.jsx)(n.td,{children:"<10ms"}),(0,o.jsx)(n.td,{children:"For single block operations"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Max Block Size"}),(0,o.jsx)(n.td,{children:"Configurable"}),(0,o.jsx)(n.td,{children:"Default 1MB, recommend <10MB"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Concurrent Connections"}),(0,o.jsx)(n.td,{children:"1000+"}),(0,o.jsx)(n.td,{children:"Limited by system resources"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Wire Formats"}),(0,o.jsx)(n.td,{children:"4"}),(0,o.jsx)(n.td,{children:"JSON, MessagePack, Protobuf, SSZ"})]})]})]}),"\n",(0,o.jsx)(n.p,{children:"The HTTP extension provides a production-ready REST API for Olocus Protocol integration, supporting multiple wire formats, authentication, rate limiting, and comprehensive error handling for web applications and services."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);