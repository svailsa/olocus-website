"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[392],{3473:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"api/measurement-api","title":"Measurement API","description":"The Universal Measurement Foundation provides the core primitives for representing any measured data in the Olocus Protocol. It follows a three-layer architecture: Core defines structural types, Schema defines validity constraints, and Domain defines semantic meaning.","source":"@site/docs/api/measurement-api.md","sourceDirName":"api","slug":"/api/measurement-api","permalink":"/docs/api/measurement-api","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/api/measurement-api.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"measurement-api","title":"Measurement API","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Cryptographic Operations","permalink":"/docs/api/cryptographic-operations"},"next":{"title":"Wire Format API","permalink":"/docs/api/wire-format-api"}}');var i=t(4848),r=t(8453);const s={id:"measurement-api",title:"Measurement API",sidebar_position:1},o="Measurement API",l={},c=[{value:"Core Types",id:"core-types",level:2},{value:"Value Enum",id:"value-enum",level:3},{value:"Temporal Types",id:"temporal-types",level:3},{value:"Text and Binary",id:"text-and-binary",level:3},{value:"Collections",id:"collections",level:3},{value:"Spatial Types",id:"spatial-types",level:3},{value:"References and Patterns",id:"references-and-patterns",level:3},{value:"Value Type Checking and Conversion",id:"value-type-checking-and-conversion",level:2},{value:"Measurement Structure",id:"measurement-structure",level:2},{value:"Uncertainty Models",id:"uncertainty-models",level:2},{value:"Uncertainty Operations",id:"uncertainty-operations",level:3},{value:"Provenance Tracking",id:"provenance-tracking",level:2},{value:"Source Types",id:"source-types",level:3},{value:"Validity Windows",id:"validity-windows",level:2},{value:"Validity Decay",id:"validity-decay",level:3},{value:"Coordinate Utilities",id:"coordinate-utilities",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Value Constructors",id:"value-constructors",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"measurement-api",children:"Measurement API"})}),"\n",(0,i.jsx)(n.p,{children:"The Universal Measurement Foundation provides the core primitives for representing any measured data in the Olocus Protocol. It follows a three-layer architecture: Core defines structural types, Schema defines validity constraints, and Domain defines semantic meaning."}),"\n",(0,i.jsx)(n.h2,{id:"core-types",children:"Core Types"}),"\n",(0,i.jsx)(n.h3,{id:"value-enum",children:"Value Enum"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Value"})," enum represents the structural types supported by the protocol. It contains ~25 variants covering all fundamental data types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::Value;\n\n// Primitives\nlet none_val = Value::None;\nlet bool_val = Value::Bool(true);\nlet int_val = Value::Int(42);\nlet uint_val = Value::UInt(100);\nlet float_val = Value::Float(3.14159);\n\n// Decimal for exact precision\nlet price = Value::Decimal {\n    value: 1999,    // $19.99 stored as 1999 cents\n    scale: 2,       // 2 decimal places\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"temporal-types",children:"Temporal Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Timestamps\nlet unix_timestamp = Value::Timestamp(1609459200); // 2021-01-01 00:00:00 UTC\nlet precise_time = Value::TimestampNanos {\n    seconds: 1609459200,\n    nanos: 123456789,\n};\n\n// Duration\nlet duration = Value::Duration(3600_000_000_000); // 1 hour in nanoseconds\n\n// Structured time\nlet date = Value::Date {\n    year: 2023,\n    month: 12,\n    day: 25,\n};\n\nlet time = Value::Time {\n    hour: 14,\n    minute: 30,\n    second: 0,\n    nanos: 0,\n};\n\nlet datetime = Value::DateTime {\n    year: 2023,\n    month: 12,\n    day: 25,\n    hour: 14,\n    minute: 30,\n    second: 0,\n    nanos: 0,\n    tz_offset_minutes: -480, // PST (-8 hours)\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"text-and-binary",children:"Text and Binary"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Text\nlet text = Value::String("Hello, Olocus!".to_string());\n\n// Binary data\nlet data = Value::Bytes(vec![0x01, 0x02, 0x03, 0x04]);\nlet hash = Value::Hash256([0u8; 32]); // SHA-256 hash\nlet hash512 = Value::Hash512([0u8; 64]); // SHA-512 hash\n\n// UUID\nlet uuid = Value::UUID([0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, \n                       0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]);\n\n// JSON documents\nlet json_doc = Value::Json(br#"{"temperature": 23.5, "unit": "celsius"}"#.to_vec());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::collections::{BTreeMap, BTreeSet};\n\n// Arrays (ordered)\nlet readings: Value = vec![1_i64, 2, 3, 4, 5].into();\n\n// Objects (key-value maps)\nlet mut sensor_data = BTreeMap::new();\nsensor_data.insert("temperature".to_string(), Value::Float(23.5));\nsensor_data.insert("humidity".to_string(), Value::Float(65.0));\nsensor_data.insert("unit".to_string(), Value::String("celsius".to_string()));\nlet obj = Value::Object(sensor_data);\n\n// Sets (unique values)\nlet mut tags = BTreeSet::new();\ntags.insert(Value::String("temperature".to_string()));\ntags.insert(Value::String("outdoor".to_string()));\nlet set = Value::Set(tags);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"spatial-types",children:"Spatial Types"}),"\n",(0,i.jsx)(n.p,{children:"All spatial coordinates use fixed-point representation (degrees \xd7 10^7) for ~1cm precision and cross-platform determinism:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::{Value, Coordinate};\n\n// 2D Points\nlet san_francisco = Value::point2d(37.7749, -122.4194);\n// Stored as: Point2D { lat: 377749000, lon: -1224194000 }\n\n// 3D Points with altitude\nlet mount_everest = Value::point3d(27.9881, 86.9250, 8848.86);\n\n// Bounding boxes\nlet bbox = Value::BoundingBox {\n    min_lat: Coordinate::latitude_to_fixed(37.7),\n    min_lon: Coordinate::longitude_to_fixed(-122.5),\n    max_lat: Coordinate::latitude_to_fixed(37.8),\n    max_lon: Coordinate::longitude_to_fixed(-122.4),\n};\n\n// GeoJSON-style geometries\nlet path = Value::linestring(&[\n    (37.7749, -122.4194),  // Start\n    (37.7849, -122.4094),  // End\n]);\n\nlet polygon = Value::polygon(\n    &[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)], // Exterior\n    &[], // No holes\n);\n\nlet multipoint = Value::multipoint(&[\n    (37.7749, -122.4194),\n    (37.7849, -122.4094),\n]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"references-and-patterns",children:"References and Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Block references\nlet block_ref = Value::BlockRef([0u8; 32]); // Hash of another block\n\n// Schema references\nlet schema_ref = Value::SchemaRef {\n    namespace: "health".to_string(),\n    name: "heart_rate".to_string(),\n    version: "1.2.0".to_string(),\n};\n\n// Database records\nlet user_record = Value::record("users", "user_12345");\n\n// Ranges\nlet age_range = Value::range(Value::Int(18), Value::Int(65));\nlet inclusive_range = Value::range_inclusive(Value::Int(1), Value::Int(100));\n\n// Regular expressions\nlet phone_pattern = Value::regex(r"^\\d{3}-\\d{3}-\\d{4}$");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"value-type-checking-and-conversion",children:"Value Type Checking and Conversion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let value = Value::Int(42);\n\n// Type checking\nassert!(value.is_numeric());\nassert!(!value.is_temporal());\nassert!(!value.is_spatial());\nassert_eq!(value.type_name(), "Int");\n\n// Safe conversion\nif let Some(i) = value.as_int() {\n    println!("Integer value: {}", i);\n}\n\n// Pattern matching\nmatch value {\n    Value::Int(i) => println!("Got integer: {}", i),\n    Value::Float(f) => println!("Got float: {}", f),\n    Value::String(s) => println!("Got string: {}", s),\n    _ => println!("Other type: {}", value.type_name()),\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"measurement-structure",children:"Measurement Structure"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Measurement"})," combines a value with uncertainty, provenance, and validity context:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::{Measurement, Uncertainty, Provenance, Source, ValidityWindow};\n\n// Basic measurement\nlet heart_rate = Measurement::new(Value::Int(72))\n    .with_uncertainty(Uncertainty::gaussian(2.0))\n    .with_source(Source::Sensor {\n        device_id: [0u8; 32],\n        sensor_type: 0x0001, // Heart rate monitor\n        calibration_id: None,\n    })\n    .with_validity(ValidityWindow::seconds(60)); // Valid for 1 minute\n\n// Check if measurement is currently valid\nif heart_rate.is_valid_now() {\n    println!("Measurement is still valid");\n}\n\n// Get validity factor (0.0 to 1.0)\nlet validity = heart_rate.validity_factor_now();\nprintln!("Validity: {:.2}", validity);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"uncertainty-models",children:"Uncertainty Models"}),"\n",(0,i.jsx)(n.p,{children:"Different domains represent uncertainty differently:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Gaussian/normal distribution (physics, engineering)\nlet temp_uncertainty = Uncertainty::gaussian(0.5); // \xb10.5\xb0C std dev\n\n// Confidence intervals (statistics)\nlet gps_uncertainty = Uncertainty::interval(10.0, 0.95); // \xb110m with 95% confidence\n\n// Circular uncertainty (angles, bearings)\nlet compass_uncertainty = Uncertainty::Circular { kappa: 5.0 }; // von Mises distribution\n\n// Discrete categories (classification)\nlet weather_uncertainty = Uncertainty::Categorical {\n    probabilities: vec![\n        (0, 0.7), // 70% chance sunny\n        (1, 0.2), // 20% chance cloudy  \n        (2, 0.1), // 10% chance rainy\n    ],\n};\n\n// Simple confidence score\nlet ai_uncertainty = Uncertainty::confidence(0.85); // 85% confident\n\n// Exact value (theoretical)\nlet math_constant = Uncertainty::Exact;\n\n// Unknown uncertainty (discouraged)\nlet unknown = Uncertainty::Unknown;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"uncertainty-operations",children:"Uncertainty Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Convert any uncertainty to confidence level\nlet confidence = uncertainty.to_confidence(); // 0.0 to 1.0\n\n// Check if uncertainty is quantified\nif uncertainty.is_quantified() {\n    println!("Uncertainty is properly quantified");\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"provenance-tracking",children:"Provenance Tracking"}),"\n",(0,i.jsx)(n.p,{children:"Provenance tracks where measurements came from and how they were processed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Sensor source\nlet sensor_prov = Provenance::sensor([1u8; 32], 0x0001);\n\n// Self-reported source\nlet self_reported = Provenance::self_reported([2u8; 32]);\n\n// Derived from other measurements\nlet derived = Provenance::derived(\n    0x1001, // Algorithm ID\n    vec![[3u8; 32], [4u8; 32]], // Input measurement hashes\n);\n\n// Add transformations\nuse olocus_core::measure::{Transformation, TransformationOp};\n\nlet filtered = sensor_prov.with_transformation(Transformation {\n    operation: TransformationOp::Filter {\n        algorithm: 0x2001,\n        parameters: vec![],\n    },\n    timestamp: 1609459200,\n    actor: [5u8; 32],\n    input_hash: [6u8; 32],\n});\n\nprintln!("Transformations applied: {}", filtered.transformation_count());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"source-types",children:"Source Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Hardware sensor\nSource::Sensor {\n    device_id: [0u8; 32],\n    sensor_type: 0x0001,\n    calibration_id: Some([1u8; 32]),\n}\n\n// Computed from other data\nSource::Derived {\n    algorithm_id: 0x1001,\n    inputs: vec![[2u8; 32], [3u8; 32]],\n    parameters: Some(vec![0x01, 0x02]),\n}\n\n// Human input\nSource::SelfReported {\n    reporter_id: [4u8; 32],\n    method: 0x0001, // Web form, voice, etc.\n}\n\n// External oracle\nSource::Oracle {\n    oracle_id: [5u8; 32],\n    query_id: Some([6u8; 32]),\n}\n\n// Consensus of multiple sources\nSource::Consensus {\n    sources: vec![[7u8; 32], [8u8; 32], [9u8; 32]],\n    method: 0x0001, // Majority vote, weighted average, etc.\n    agreement: 0.85, // 85% agreement\n}\n\n// Unknown (discouraged - heavily penalized in trust calculations)\nSource::Unknown\n"})}),"\n",(0,i.jsx)(n.h2,{id:"validity-windows",children:"Validity Windows"}),"\n",(0,i.jsx)(n.p,{children:"Control when measurements are considered valid:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::time::{SystemTime, UNIX_EPOCH};\n\nlet now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap()\n    .as_secs();\n\n// Valid for specific duration\nlet short_term = ValidityWindow::new(now, Some(300)); // 5 minutes\n\n// Valid for N seconds from now\nlet real_time = ValidityWindow::seconds(60); // 1 minute\n\n// Indefinitely valid (use with caution)\nlet permanent = ValidityWindow::indefinite();\n\n// With exponential decay\nlet decaying = ValidityWindow::decaying(3600, 1800); // 1 hour validity, 30 min half-life\n\n// Check validity\nassert!(short_term.is_valid_at(now + 100)); // Valid\nassert!(!short_term.is_valid_at(now + 400)); // Expired\n\n// Get validity factor with decay\nlet factor = decaying.validity_at(now + 1800); // Should be ~0.5 (one half-life)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"validity-decay",children:"Validity Decay"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::ValidityDecay;\n\n// Step function (binary: valid/invalid)\nValidityDecay::StepFunction\n\n// Linear decay from 1.0 to 0.0\nValidityDecay::Linear\n\n// Exponential decay with half-life\nValidityDecay::Exponential { half_life: 1800 } // 30 minutes\n\n// Custom decay curve (domain-specific)\nValidityDecay::Custom {\n    curve_id: 0x1001,\n    parameters: vec![],\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"coordinate-utilities",children:"Coordinate Utilities"}),"\n",(0,i.jsx)(n.p,{children:"Fixed-point coordinate system for deterministic spatial calculations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::Coordinate;\n\n// Constants\nassert_eq!(Coordinate::SCALE, 10_000_000.0); // 10^7 scale factor\nassert_eq!(Coordinate::MAX_LAT, 900_000_000); // 90\xb0 \xd7 10^7\nassert_eq!(Coordinate::EARTH_RADIUS_M, 6_371_000.0);\n\n// Conversions\nlet lat_fixed = Coordinate::latitude_to_fixed(37.7749290);  // 377749290\nlet lat_degrees = Coordinate::fixed_to_latitude(377749290); // 37.7749290\n\n// Validation\nCoordinate::validate(377749290, -1224193580).unwrap(); // San Francisco\n\n// Distance calculation (Haversine formula)\nlet distance = Coordinate::haversine_distance(\n    377749290, -1224193580, // San Francisco\n    407589500, -739444400,  // New York\n); // Returns distance in meters\n\n// Bearing calculation (0-360 degrees, 0=north)\nlet bearing = Coordinate::bearing(\n    377749290, -1224193580, // From SF\n    407589500, -739444400,  // To NYC\n); // Returns ~78.5 degrees (northeast)\n\n// Destination point calculation\nlet (dest_lat, dest_lon) = Coordinate::destination_point(\n    377749290, -1224193580, // Start: San Francisco\n    90.0,      // Bearing: due east\n    1000.0,    // Distance: 1km\n);\n\n// Coordinate offsets\nlet lat_offset = Coordinate::meters_to_lat_offset(1000.0); // 1km north\nlet lon_offset = Coordinate::meters_to_lon_offset(1000.0, 377749290); // 1km east at SF latitude\n"})}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::*;\nuse std::collections::BTreeMap;\n\nfn main() -> Result<(), MeasurementError> {\n    // Create a comprehensive measurement\n    let mut sensor_data = BTreeMap::new();\n    sensor_data.insert("temperature".to_string(), Value::Float(23.5));\n    sensor_data.insert("humidity".to_string(), Value::Float(65.0));\n    sensor_data.insert("location".to_string(), Value::point2d(37.7749, -122.4194));\n    \n    let measurement = Measurement::new(Value::Object(sensor_data))\n        .with_uncertainty(Uncertainty::Interval {\n            lower_bound: -0.5,\n            upper_bound: 0.5,\n            confidence: 0.95,\n        })\n        .with_provenance(\n            Provenance::sensor([1u8; 32], 0x0001)\n                .with_transformation(Transformation {\n                    operation: TransformationOp::Filter {\n                        algorithm: 0x2001,\n                        parameters: vec![0x01, 0x02],\n                    },\n                    timestamp: 1609459200,\n                    actor: [2u8; 32],\n                    input_hash: [3u8; 32],\n                })\n                .with_attestation(Attestation {\n                    attestor: [4u8; 32],\n                    claim: AttestationClaim::Witnessed,\n                    signature: [0u8; 64],\n                    timestamp: 1609459200,\n                })\n        )\n        .with_validity(ValidityWindow::decaying(3600, 1800));\n\n    // Validate measurement\n    if measurement.is_valid_now() {\n        println!("Measurement is valid");\n        println!("Confidence: {:.2}", measurement.uncertainty.to_confidence());\n        println!("Sources: {}", measurement.provenance.attestation_count());\n        println!("Validity: {:.2}", measurement.validity_factor_now());\n    }\n\n    // Serialize for storage/transmission\n    let json = serde_json::to_string(&measurement).unwrap();\n    println!("Serialized measurement: {}", json);\n\n    // Deserialize\n    let deserialized: Measurement = serde_json::from_str(&json).unwrap();\n    assert_eq!(measurement, deserialized);\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"value-constructors",children:"Value Constructors"}),"\n",(0,i.jsx)(n.p,{children:"Convenience methods for creating common values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// From Rust primitives\nlet v1: Value = 42_i64.into();\nlet v2: Value = "hello".into();\nlet v3: Value = true.into();\nlet v4: Value = vec![1_i64, 2, 3].into();\n\n// Spatial constructors\nlet point = Value::point2d(37.7749, -122.4194);\nlet point3d = Value::point3d(37.7749, -122.4194, 100.0);\nlet line = Value::linestring(&[(0.0, 0.0), (1.0, 1.0)]);\n\n// Utility constructors\nlet uuid = Value::uuid_from_u128(0x123456789ABCDEF0123456789ABCDEF0);\nlet range = Value::range(Value::Int(1), Value::Int(100));\nlet record = Value::record("users", "user_123");\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::MeasurementError;\n\n// Value validation\nmatch Coordinate::validate(lat_fixed, lon_fixed) {\n    Ok(()) => println!("Coordinates valid"),\n    Err(MeasurementError::ValueOutOfRange { min, max, actual }) => {\n        println!("Coordinate out of range: {} not in {}..{}", actual, min, max);\n    }\n    Err(e) => println!("Other error: {}", e),\n}\n\n// Uncertainty validation\nlet uncertainty = Uncertainty::confidence(1.5); // Invalid: > 1.0\n// This would create ConfidenceOutOfRange error\n\n// Provenance validation\nlet circular = Provenance::derived(0x1001, vec![[1u8; 32]]);\n// If input hash references a measurement derived from this one,\n// would create CircularProvenance error\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed-Point Arithmetic"}),": Spatial calculations use integer math for speed and determinism"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Serialization"}),": Values serialize to compact binary or JSON format"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Layout"}),": Enums are optimized for minimal memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Collection Types"}),": BTreeMap/BTreeSet ensure deterministic iteration order"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./core",children:"Core API Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./block-operations",children:"Block Operations API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./wire-format-api",children:"Wire Format API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./error-handling",children:"Error Handling"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);