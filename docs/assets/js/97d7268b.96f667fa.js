"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[2362],{1130:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"extensions/location/privacy-obfuscation","title":"Privacy & Obfuscation","description":"The Location extension provides comprehensive privacy protection techniques to safeguard location data while maintaining utility for legitimate applications.","source":"@site/docs/extensions/location/privacy-obfuscation.md","sourceDirName":"extensions/location","slug":"/extensions/location/privacy-obfuscation","permalink":"/docs/extensions/location/privacy-obfuscation","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/location/privacy-obfuscation.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":4,"frontMatter":{"id":"privacy-obfuscation","title":"Privacy & Obfuscation","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Clustering Algorithms","permalink":"/docs/extensions/location/clustering"},"next":{"title":"Trust Networks","permalink":"/docs/extensions/security/trust-networks"}}');var t=i(4848),o=i(8453);const s={id:"privacy-obfuscation",title:"Privacy & Obfuscation",sidebar_position:4},l="Privacy & Obfuscation",r={},c=[{value:"Overview",id:"overview",level:2},{value:"Grid Snapping",id:"grid-snapping",level:2},{value:"Fixed Grid Snapping",id:"fixed-grid-snapping",level:3},{value:"Adaptive Grid Snapping",id:"adaptive-grid-snapping",level:3},{value:"Noise Addition",id:"noise-addition",level:2},{value:"Laplacian Noise (Differential Privacy)",id:"laplacian-noise-differential-privacy",level:3},{value:"Gaussian Noise",id:"gaussian-noise",level:3},{value:"k-Anonymity",id:"k-anonymity",level:2},{value:"Spatial k-Anonymity",id:"spatial-k-anonymity",level:3},{value:"Temporal k-Anonymity",id:"temporal-k-anonymity",level:3},{value:"Location Cloaking",id:"location-cloaking",level:2},{value:"Hierarchical Cloaking",id:"hierarchical-cloaking",level:3},{value:"Semantic Cloaking",id:"semantic-cloaking",level:3},{value:"Privacy Metrics",id:"privacy-metrics",level:2},{value:"Privacy Assessment",id:"privacy-assessment",level:3},{value:"Attack Resistance Analysis",id:"attack-resistance-analysis",level:3},{value:"Integration with Core Privacy Extension",id:"integration-with-core-privacy-extension",level:2},{value:"Privacy Policy Integration",id:"privacy-policy-integration",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"GDPR Compliance",id:"gdpr-compliance",level:3},{value:"Location Sharing with Trusted Contacts",id:"location-sharing-with-trusted-contacts",level:3},{value:"Testing &amp; Validation",id:"testing--validation",level:2},{value:"Configuration Guidelines",id:"configuration-guidelines",level:2},{value:"Privacy Level Recommendations",id:"privacy-level-recommendations",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"privacy--obfuscation",children:"Privacy & Obfuscation"})}),"\n",(0,t.jsx)(e.p,{children:"The Location extension provides comprehensive privacy protection techniques to safeguard location data while maintaining utility for legitimate applications."}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Location privacy is critical for protecting user safety, preventing tracking, and complying with privacy regulations. The system offers multiple obfuscation techniques:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Grid Snapping"}),": Reduce precision to discrete grid cells"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Noise Addition"}),": Add controlled random displacement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"k-Anonymity"}),": Ensure indistinguishability among k users"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Differential Privacy"}),": Provide mathematical privacy guarantees"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cloaking"}),": Use generalized location regions"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::*;\nuse olocus_privacy::*; // Core privacy extension integration\n\n// Configure privacy protection\nlet privacy_config = LocationPrivacyConfig {\n    obfuscation_method: ObfuscationMethod::AdaptiveGrid {\n        base_cell_size: 100.0,     // 100m base grid\n        min_k_anonymity: 5,        // At least 5 users per cell\n    },\n    noise_level: NoiseLevel::Medium,\n    preserve_temporal_patterns: false,\n    allow_home_inference: false,\n};\n\nlet privacy_manager = LocationPrivacyManager::new(privacy_config);\n"})}),"\n",(0,t.jsx)(e.h2,{id:"grid-snapping",children:"Grid Snapping"}),"\n",(0,t.jsx)(e.p,{children:"Grid snapping reduces location precision by quantizing coordinates to a discrete grid:"}),"\n",(0,t.jsx)(e.h3,{id:"fixed-grid-snapping",children:"Fixed Grid Snapping"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::grid::*;\n\n#[derive(Debug, Clone)]\npub struct GridConfig {\n    pub cell_size: f64,              // Grid cell size in meters\n    pub origin_lat: f64,             // Grid origin latitude\n    pub origin_lon: f64,             // Grid origin longitude\n    pub add_random_offset: bool,     // Add random offset within cell\n}\n\npub struct GridSnapper {\n    config: GridConfig,\n}\n\nimpl GridSnapper {\n    pub fn snap_location(&self, location: &LocationMeasurement) -> LocationMeasurement {\n        let lat_degrees = Coordinate::fixed_to_latitude(location.measurement.value.x());\n        let lon_degrees = Coordinate::fixed_to_longitude(location.measurement.value.y());\n        \n        // Convert to meters from origin\n        let x_meters = (lon_degrees - self.config.origin_lon) * 111_320.0 * lat_degrees.cos().to_radians();\n        let y_meters = (lat_degrees - self.config.origin_lat) * 111_320.0;\n        \n        // Snap to grid\n        let grid_x = (x_meters / self.config.cell_size).floor() * self.config.cell_size;\n        let grid_y = (y_meters / self.config.cell_size).floor() * self.config.cell_size;\n        \n        // Add random offset within cell if enabled\n        let (final_x, final_y) = if self.config.add_random_offset {\n            let offset_x = rand::random::<f64>() * self.config.cell_size;\n            let offset_y = rand::random::<f64>() * self.config.cell_size;\n            (grid_x + offset_x, grid_y + offset_y)\n        } else {\n            // Use cell center\n            (grid_x + self.config.cell_size / 2.0, grid_y + self.config.cell_size / 2.0)\n        };\n        \n        // Convert back to coordinates\n        let snapped_lon = self.config.origin_lon + final_x / (111_320.0 * lat_degrees.cos().to_radians());\n        let snapped_lat = self.config.origin_lat + final_y / 111_320.0;\n        \n        let mut snapped_location = location.clone();\n        snapped_location.measurement.value = Value::Point2D {\n            x: Coordinate::latitude_to_fixed(snapped_lat),\n            y: Coordinate::longitude_to_fixed(snapped_lon),\n        };\n        \n        // Increase uncertainty to reflect grid cell size\n        snapped_location.measurement.uncertainty = Uncertainty::Circular {\n            radius: self.config.cell_size / 2.0,\n        };\n        \n        snapped_location\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"adaptive-grid-snapping",children:"Adaptive Grid Snapping"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::adaptive_grid::*;\n\npub struct AdaptiveGridSnapper {\n    base_cell_size: f64,\n    population_density_map: PopulationDensityMap,\n    k_anonymity_threshold: usize,\n}\n\nimpl AdaptiveGridSnapper {\n    pub fn snap_location(&self, location: &LocationMeasurement) -> LocationMeasurement {\n        // Determine appropriate cell size based on population density\n        let density = self.population_density_map.get_density(\n            &location.measurement.value.x(),\n            &location.measurement.value.y()\n        );\n        \n        // Higher density areas can use smaller cells while maintaining k-anonymity\n        let adaptive_cell_size = self.calculate_adaptive_cell_size(density);\n        \n        let grid_config = GridConfig {\n            cell_size: adaptive_cell_size,\n            origin_lat: 0.0,\n            origin_lon: 0.0,\n            add_random_offset: true,\n        };\n        \n        let snapper = GridSnapper::new(grid_config);\n        snapper.snap_location(location)\n    }\n    \n    fn calculate_adaptive_cell_size(&self, density: f64) -> f64 {\n        // Ensure k-anonymity: cell_area * density >= k_anonymity_threshold\n        let required_area = self.k_anonymity_threshold as f64 / density;\n        let required_cell_size = required_area.sqrt();\n        \n        // Use larger of base size and required size\n        self.base_cell_size.max(required_cell_size)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"noise-addition",children:"Noise Addition"}),"\n",(0,t.jsx)(e.p,{children:"Adding controlled random noise provides location privacy while preserving statistical properties:"}),"\n",(0,t.jsx)(e.h3,{id:"laplacian-noise-differential-privacy",children:"Laplacian Noise (Differential Privacy)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::noise::*;\nuse rand_distr::{Distribution, Laplace};\n\npub struct LaplacianNoiseAdder {\n    epsilon: f64,              // Privacy parameter (smaller = more private)\n    sensitivity: f64,          // Global sensitivity (max change from single record)\n}\n\nimpl LaplacianNoiseAdder {\n    pub fn new(epsilon: f64) -> Self {\n        Self {\n            epsilon,\n            sensitivity: 1.0,    // 1 meter sensitivity for location data\n        }\n    }\n    \n    pub fn add_noise(&self, location: &LocationMeasurement) -> LocationMeasurement {\n        let scale = self.sensitivity / self.epsilon;\n        let laplace = Laplace::new(0.0, scale).unwrap();\n        \n        // Add independent noise to each coordinate\n        let lat_noise = laplace.sample(&mut rand::thread_rng());\n        let lon_noise = laplace.sample(&mut rand::thread_rng());\n        \n        let original_lat = Coordinate::fixed_to_latitude(location.measurement.value.x());\n        let original_lon = Coordinate::fixed_to_longitude(location.measurement.value.y());\n        \n        // Convert noise from meters to degrees (approximate)\n        let lat_degrees = original_lat + lat_noise / 111_320.0;\n        let lon_degrees = original_lon + lon_noise / (111_320.0 * original_lat.cos().to_radians());\n        \n        let mut noisy_location = location.clone();\n        noisy_location.measurement.value = Value::Point2D {\n            x: Coordinate::latitude_to_fixed(lat_degrees),\n            y: Coordinate::longitude_to_fixed(lon_degrees),\n        };\n        \n        // Update uncertainty to reflect added noise\n        let original_radius = match location.measurement.uncertainty {\n            Uncertainty::Circular { radius } => radius,\n            _ => 10.0, // Default uncertainty\n        };\n        \n        // Combine original uncertainty with noise uncertainty\n        let noise_std = scale * std::f64::consts::SQRT_2; // Standard deviation of Laplacian\n        let combined_uncertainty = (original_radius * original_radius + noise_std * noise_std).sqrt();\n        \n        noisy_location.measurement.uncertainty = Uncertainty::Circular {\n            radius: combined_uncertainty,\n        };\n        \n        noisy_location\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"gaussian-noise",children:"Gaussian Noise"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use rand_distr::{Normal, Distribution};\n\npub struct GaussianNoiseAdder {\n    std_dev: f64,              // Standard deviation in meters\n}\n\nimpl GaussianNoiseAdder {\n    pub fn add_noise(&self, location: &LocationMeasurement) -> LocationMeasurement {\n        let normal = Normal::new(0.0, self.std_dev).unwrap();\n        \n        let lat_noise = normal.sample(&mut rand::thread_rng());\n        let lon_noise = normal.sample(&mut rand::thread_rng());\n        \n        let original_lat = Coordinate::fixed_to_latitude(location.measurement.value.x());\n        let original_lon = Coordinate::fixed_to_longitude(location.measurement.value.y());\n        \n        let lat_degrees = original_lat + lat_noise / 111_320.0;\n        let lon_degrees = original_lon + lon_noise / (111_320.0 * original_lat.cos().to_radians());\n        \n        let mut noisy_location = location.clone();\n        noisy_location.measurement.value = Value::Point2D {\n            x: Coordinate::latitude_to_fixed(lat_degrees),\n            y: Coordinate::longitude_to_fixed(lon_degrees),\n        };\n        \n        // Gaussian noise adds to uncertainty\n        noisy_location.measurement.uncertainty = Uncertainty::Gaussian {\n            std_dev_x: self.std_dev,\n            std_dev_y: self.std_dev,\n            correlation: 0.0,\n        };\n        \n        noisy_location\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"k-anonymity",children:"k-Anonymity"}),"\n",(0,t.jsx)(e.p,{children:"k-Anonymity ensures each location is indistinguishable from at least k-1 other locations:"}),"\n",(0,t.jsx)(e.h3,{id:"spatial-k-anonymity",children:"Spatial k-Anonymity"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::k_anonymity::*;\n\npub struct SpatialKAnonymizer {\n    k: usize,                  // Minimum group size\n    spatial_index: SpatialIndex,\n    user_locations: HashMap<UserId, Vec<LocationMeasurement>>,\n}\n\nimpl SpatialKAnonymizer {\n    pub fn anonymize_location(\n        &self,\n        user_id: UserId,\n        location: &LocationMeasurement\n    ) -> Result<AnonymizedLocation> {\n        // Find nearby users within time window\n        let nearby_users = self.find_nearby_users(location, Duration::from_mins(10))?;\n        \n        if nearby_users.len() < self.k - 1 {\n            // Not enough users for k-anonymity\n            return Err(PrivacyError::InsufficientKAnonymity {\n                required: self.k,\n                available: nearby_users.len() + 1,\n            });\n        }\n        \n        // Select k users (including current user)\n        let mut selected_users = nearby_users;\n        selected_users.truncate(self.k - 1);\n        selected_users.push(user_id);\n        \n        // Calculate anonymization region (minimum bounding rectangle)\n        let anonymization_region = self.calculate_mbr(&selected_users, location)?;\n        \n        Ok(AnonymizedLocation {\n            region: anonymization_region,\n            k_value: self.k,\n            user_count: selected_users.len(),\n            confidence: self.calculate_confidence(&anonymization_region),\n        })\n    }\n    \n    fn find_nearby_users(\n        &self,\n        location: &LocationMeasurement,\n        time_window: Duration\n    ) -> Result<Vec<UserId>> {\n        let current_time = SystemTime::now();\n        let mut nearby_users = Vec::new();\n        \n        for (user_id, locations) in &self.user_locations {\n            // Check if user has recent location data\n            if let Some(recent_location) = locations.iter()\n                .filter(|loc| current_time.duration_since(loc.timestamp).unwrap_or_default() <= time_window)\n                .last() \n            {\n                // Check if within anonymization radius\n                let distance = Coordinate::haversine_distance(\n                    location.measurement.value.x(), location.measurement.value.y(),\n                    recent_location.measurement.value.x(), recent_location.measurement.value.y()\n                );\n                \n                if distance <= self.max_anonymization_radius {\n                    nearby_users.push(*user_id);\n                }\n            }\n        }\n        \n        Ok(nearby_users)\n    }\n    \n    fn calculate_mbr(&self, users: &[UserId], location: &LocationMeasurement) -> Result<BoundingBox> {\n        let mut min_lat = f64::INFINITY;\n        let mut max_lat = f64::NEG_INFINITY;\n        let mut min_lon = f64::INFINITY;\n        let mut max_lon = f64::NEG_INFINITY;\n        \n        // Include all user locations\n        for &user_id in users {\n            if let Some(user_locations) = self.user_locations.get(&user_id) {\n                if let Some(latest_location) = user_locations.last() {\n                    let lat = Coordinate::fixed_to_latitude(latest_location.measurement.value.x());\n                    let lon = Coordinate::fixed_to_longitude(latest_location.measurement.value.y());\n                    \n                    min_lat = min_lat.min(lat);\n                    max_lat = max_lat.max(lat);\n                    min_lon = min_lon.min(lon);\n                    max_lon = max_lon.max(lon);\n                }\n            }\n        }\n        \n        Ok(BoundingBox {\n            min_lat: Coordinate::latitude_to_fixed(min_lat),\n            max_lat: Coordinate::latitude_to_fixed(max_lat),\n            min_lon: Coordinate::longitude_to_fixed(min_lon),\n            max_lon: Coordinate::longitude_to_fixed(max_lon),\n        })\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"temporal-k-anonymity",children:"Temporal k-Anonymity"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"pub struct TemporalKAnonymizer {\n    k: usize,\n    time_window: Duration,\n    location_buffer: HashMap<UserId, VecDeque<LocationMeasurement>>,\n}\n\nimpl TemporalKAnonymizer {\n    pub fn anonymize_trajectory(\n        &mut self,\n        user_id: UserId,\n        locations: &[LocationMeasurement]\n    ) -> Result<Vec<AnonymizedLocation>> {\n        let mut anonymized_trajectory = Vec::new();\n        \n        for location in locations {\n            // Add to buffer\n            self.location_buffer.entry(user_id)\n                .or_default()\n                .push_back(location.clone());\n            \n            // Clean old locations\n            self.cleanup_old_locations();\n            \n            // Try to anonymize current location\n            if let Ok(anon_location) = self.try_anonymize_current_location(user_id, location) {\n                anonymized_trajectory.push(anon_location);\n            }\n        }\n        \n        Ok(anonymized_trajectory)\n    }\n    \n    fn try_anonymize_current_location(\n        &self,\n        user_id: UserId,\n        location: &LocationMeasurement\n    ) -> Result<AnonymizedLocation> {\n        let current_time = location.timestamp;\n        let time_start = current_time - self.time_window;\n        \n        let mut temporal_users = Vec::new();\n        \n        // Find users active in time window\n        for (&uid, user_locations) in &self.location_buffer {\n            let locations_in_window: Vec<&LocationMeasurement> = user_locations\n                .iter()\n                .filter(|loc| loc.timestamp >= time_start && loc.timestamp <= current_time)\n                .collect();\n                \n            if !locations_in_window.is_empty() {\n                temporal_users.push(uid);\n            }\n        }\n        \n        if temporal_users.len() < self.k {\n            return Err(PrivacyError::InsufficientTemporalKAnonymity {\n                required: self.k,\n                available: temporal_users.len(),\n                time_window: self.time_window,\n            });\n        }\n        \n        // Calculate temporal-spatial anonymization region\n        self.calculate_temporal_anonymization_region(&temporal_users, time_start, current_time)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"location-cloaking",children:"Location Cloaking"}),"\n",(0,t.jsx)(e.p,{children:"Cloaking replaces exact locations with generalized regions:"}),"\n",(0,t.jsx)(e.h3,{id:"hierarchical-cloaking",children:"Hierarchical Cloaking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::cloaking::*;\n\npub struct HierarchicalCloaker {\n    quad_tree: QuadTree,\n    min_region_size: f64,      // Minimum cloaking region size (meters)\n    max_region_size: f64,      // Maximum cloaking region size (meters)\n}\n\nimpl HierarchicalCloaker {\n    pub fn cloak_location(\n        &self,\n        location: &LocationMeasurement,\n        privacy_level: PrivacyLevel\n    ) -> CloakedLocation {\n        let target_region_size = match privacy_level {\n            PrivacyLevel::Low => self.min_region_size,\n            PrivacyLevel::Medium => (self.min_region_size + self.max_region_size) / 2.0,\n            PrivacyLevel::High => self.max_region_size,\n        };\n        \n        // Find appropriate quad tree node\n        let node = self.quad_tree.find_containing_region(\n            location,\n            target_region_size\n        );\n        \n        CloakedLocation {\n            region: node.bounding_box,\n            center: node.center,\n            radius: node.radius,\n            privacy_level,\n            cloaking_method: CloakingMethod::Hierarchical,\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"semantic-cloaking",children:"Semantic Cloaking"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"pub struct SemanticCloaker {\n    poi_database: POIDatabase,\n    semantic_regions: Vec<SemanticRegion>,\n}\n\nimpl SemanticCloaker {\n    pub fn cloak_semantically(\n        &self,\n        location: &LocationMeasurement,\n        semantic_level: SemanticLevel\n    ) -> SemanticallyCloakedLocation {\n        match semantic_level {\n            SemanticLevel::Building => {\n                // Return building-level region\n                let building = self.poi_database.find_building(location)?;\n                SemanticallyCloakedLocation::Building {\n                    name: building.name,\n                    address: building.address,\n                    region: building.footprint,\n                }\n            },\n            SemanticLevel::Block => {\n                // Return city block\n                let block = self.find_city_block(location)?;\n                SemanticallyCloakedLocation::Block {\n                    bounds: block.bounds,\n                    approximate_address: block.representative_address,\n                }\n            },\n            SemanticLevel::Neighborhood => {\n                // Return neighborhood region\n                let neighborhood = self.find_neighborhood(location)?;\n                SemanticallyCloakedLocation::Neighborhood {\n                    name: neighborhood.name,\n                    bounds: neighborhood.bounds,\n                }\n            },\n            SemanticLevel::City => {\n                // Return city-level region\n                let city = self.find_city(location)?;\n                SemanticallyCloakedLocation::City {\n                    name: city.name,\n                    bounds: city.bounds,\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"privacy-metrics",children:"Privacy Metrics"}),"\n",(0,t.jsx)(e.h3,{id:"privacy-assessment",children:"Privacy Assessment"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::metrics::*;\n\npub struct PrivacyMetrics;\n\nimpl PrivacyMetrics {\n    pub fn calculate_anonymity_level(\n        original: &LocationMeasurement,\n        anonymized: &AnonymizedLocation\n    ) -> AnonymityMetrics {\n        let area = anonymized.region.area_square_meters();\n        let perimeter = anonymized.region.perimeter_meters();\n        \n        // Geometric privacy metrics\n        let geometric_privacy = area.log10(); // Log-scale for interpretability\n        let shape_privacy = (4.0 * std::f64::consts::PI * area) / (perimeter * perimeter);\n        \n        // Information loss\n        let information_loss = Self::calculate_information_loss(original, anonymized);\n        \n        AnonymityMetrics {\n            k_value: anonymized.k_value,\n            geometric_privacy,\n            shape_privacy,\n            area_square_meters: area,\n            information_loss,\n            privacy_score: Self::calculate_overall_privacy_score(\n                anonymized.k_value,\n                geometric_privacy,\n                information_loss\n            ),\n        }\n    }\n    \n    fn calculate_information_loss(\n        original: &LocationMeasurement,\n        anonymized: &AnonymizedLocation\n    ) -> f64 {\n        let original_point = Point2D {\n            x: Coordinate::fixed_to_latitude(original.measurement.value.x()),\n            y: Coordinate::fixed_to_longitude(original.measurement.value.y()),\n        };\n        \n        let region_center = anonymized.region.center();\n        let displacement = original_point.distance_to(&region_center);\n        let region_radius = anonymized.region.max_radius();\n        \n        // Normalized information loss [0, 1]\n        (displacement / region_radius).min(1.0)\n    }\n    \n    fn calculate_overall_privacy_score(\n        k_value: usize,\n        geometric_privacy: f64,\n        information_loss: f64\n    ) -> f64 {\n        // Weighted combination of privacy factors\n        let k_score = (k_value as f64).log10() / 3.0; // Normalize to ~[0, 1]\n        let geo_score = geometric_privacy / 10.0;     // Normalize area score\n        let utility_score = 1.0 - information_loss;   // Higher utility = lower info loss\n        \n        // Balanced privacy-utility score\n        (k_score * 0.4 + geo_score * 0.3 + utility_score * 0.3).min(1.0)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"attack-resistance-analysis",children:"Attack Resistance Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"pub struct AttackResistanceAnalyzer {\n    background_knowledge: BackgroundKnowledge,\n    attack_models: Vec<AttackModel>,\n}\n\nimpl AttackResistanceAnalyzer {\n    pub fn assess_resistance(\n        &self,\n        trajectory: &[AnonymizedLocation],\n        user_profile: &UserProfile\n    ) -> ResistanceAssessment {\n        let mut resistances = Vec::new();\n        \n        for attack_model in &self.attack_models {\n            let resistance = match attack_model {\n                AttackModel::HomogeneityAttack => {\n                    self.assess_homogeneity_resistance(trajectory)\n                },\n                AttackModel::BackgroundKnowledgeAttack => {\n                    self.assess_background_knowledge_resistance(trajectory, user_profile)\n                },\n                AttackModel::InferenceAttack => {\n                    self.assess_inference_resistance(trajectory)\n                },\n                AttackModel::LinkageAttack => {\n                    self.assess_linkage_resistance(trajectory, user_profile)\n                }\n            };\n            \n            resistances.push(resistance);\n        }\n        \n        ResistanceAssessment {\n            overall_resistance: resistances.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap().clone(),\n            individual_resistances: resistances,\n            vulnerability_score: self.calculate_vulnerability_score(&resistances),\n            recommendations: self.generate_recommendations(&resistances),\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-core-privacy-extension",children:"Integration with Core Privacy Extension"}),"\n",(0,t.jsx)(e.h3,{id:"privacy-policy-integration",children:"Privacy Policy Integration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_privacy::*;\n\npub struct LocationPrivacyEngine {\n    privacy_techniques: HashMap<TechniqueName, Box<dyn PrivacyTechnique>>,\n    data_minimization: DataMinimizationStrategy,\n    consent_manager: ConsentManager,\n}\n\nimpl LocationPrivacyEngine {\n    pub fn apply_privacy_policy(\n        &self,\n        location: &LocationMeasurement,\n        user_id: UserId,\n        context: &ProcessingContext\n    ) -> Result<PrivacyProcessedLocation> {\n        // Check consent\n        let consent = self.consent_manager.get_consent(user_id, ConsentType::LocationProcessing)?;\n        if !consent.is_valid() {\n            return Err(PrivacyError::NoConsent);\n        }\n        \n        // Apply data minimization\n        let minimized_location = self.data_minimization.minimize(location, context)?;\n        \n        // Determine required privacy techniques based on policy\n        let required_techniques = self.determine_required_techniques(&minimized_location, context)?;\n        \n        let mut processed_location = minimized_location;\n        for technique_name in required_techniques {\n            if let Some(technique) = self.privacy_techniques.get(&technique_name) {\n                processed_location = technique.apply(&processed_location, context)?;\n            }\n        }\n        \n        Ok(PrivacyProcessedLocation {\n            location: processed_location,\n            applied_techniques: required_techniques,\n            privacy_level: self.calculate_privacy_level(&processed_location),\n            compliance_status: self.check_compliance(&processed_location, context)?,\n        })\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,t.jsx)(e.h3,{id:"gdpr-compliance",children:"GDPR Compliance"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_location::privacy::gdpr::*;\n\npub struct GDPRLocationProcessor {\n    privacy_engine: LocationPrivacyEngine,\n    purpose_limitation: PurposeLimitation,\n    retention_policy: RetentionPolicy,\n}\n\nimpl GDPRLocationProcessor {\n    pub fn process_for_gdpr(\n        &self,\n        location: &LocationMeasurement,\n        processing_purpose: ProcessingPurpose,\n        user_consent: &ConsentRecord\n    ) -> Result<GDPRCompliantLocation> {\n        // Verify lawful basis\n        self.verify_lawful_basis(&processing_purpose, user_consent)?;\n        \n        // Apply purpose limitation\n        let purpose_limited = self.purpose_limitation.apply(location, &processing_purpose)?;\n        \n        // Apply appropriate privacy techniques\n        let privacy_config = match processing_purpose {\n            ProcessingPurpose::Navigation => LocationPrivacyConfig {\n                obfuscation_method: ObfuscationMethod::LowNoise,\n                preserve_temporal_patterns: true,\n                allow_home_inference: false,\n            },\n            ProcessingPurpose::Analytics => LocationPrivacyConfig {\n                obfuscation_method: ObfuscationMethod::AdaptiveGrid {\n                    base_cell_size: 200.0,\n                    min_k_anonymity: 10,\n                },\n                preserve_temporal_patterns: false,\n                allow_home_inference: false,\n            },\n            ProcessingPurpose::EmergencyServices => LocationPrivacyConfig {\n                obfuscation_method: ObfuscationMethod::None, // Emergency exception\n                preserve_temporal_patterns: true,\n                allow_home_inference: true,\n            }\n        };\n        \n        let processed = self.privacy_engine.apply_privacy_config(&purpose_limited, privacy_config)?;\n        \n        Ok(GDPRCompliantLocation {\n            location: processed,\n            processing_purpose,\n            lawful_basis: user_consent.lawful_basis.clone(),\n            retention_until: self.retention_policy.calculate_retention_date(&processing_purpose),\n            data_subject_rights: self.calculate_applicable_rights(&processing_purpose),\n        })\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"location-sharing-with-trusted-contacts",children:"Location Sharing with Trusted Contacts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"pub struct TrustedContactSharing {\n    trust_manager: TrustManager,\n    privacy_levels: HashMap<ContactId, PrivacyLevel>,\n}\n\nimpl TrustedContactSharing {\n    pub fn share_location_with_contact(\n        &self,\n        user_location: &LocationMeasurement,\n        contact_id: ContactId,\n        sharing_context: SharingContext\n    ) -> Result<SharedLocation> {\n        // Get trust level for contact\n        let trust_level = self.trust_manager.get_trust_level(contact_id)?;\n        let privacy_level = self.privacy_levels.get(&contact_id)\n            .unwrap_or(&PrivacyLevel::Medium);\n        \n        let shared_location = match (trust_level, privacy_level, sharing_context) {\n            (TrustLevel::High, PrivacyLevel::Low, _) => {\n                // High trust, low privacy: share exact location\n                user_location.clone()\n            },\n            (TrustLevel::Medium, PrivacyLevel::Medium, SharingContext::Emergency) => {\n                // Medium trust, emergency: moderate obfuscation\n                self.apply_moderate_obfuscation(user_location)?\n            },\n            (TrustLevel::Low, _, _) | (_, PrivacyLevel::High, _) => {\n                // Low trust or high privacy: strong obfuscation\n                self.apply_strong_obfuscation(user_location)?\n            }\n            _ => {\n                // Default: adaptive grid based on context\n                self.apply_adaptive_obfuscation(user_location, &sharing_context)?\n            }\n        };\n        \n        Ok(SharedLocation {\n            location: shared_location,\n            contact_id,\n            sharing_timestamp: SystemTime::now(),\n            privacy_applied: self.get_applied_privacy_level(&shared_location, user_location),\n            expires_at: self.calculate_expiry(&sharing_context),\n        })\n    }\n    \n    fn apply_adaptive_obfuscation(\n        &self,\n        location: &LocationMeasurement,\n        context: &SharingContext\n    ) -> Result<LocationMeasurement> {\n        let obfuscation_method = match context {\n            SharingContext::SocialMeetup => ObfuscationMethod::GridSnap { cell_size: 50.0 },\n            SharingContext::WorkCollaboration => ObfuscationMethod::BuildingLevel,\n            SharingContext::FamilyTracking => ObfuscationMethod::LowNoise,\n            SharingContext::Emergency => ObfuscationMethod::None,\n            SharingContext::General => ObfuscationMethod::AdaptiveGrid {\n                base_cell_size: 100.0,\n                min_k_anonymity: 3,\n            },\n        };\n        \n        let privacy_manager = LocationPrivacyManager::new(LocationPrivacyConfig {\n            obfuscation_method,\n            noise_level: NoiseLevel::Low,\n            preserve_temporal_patterns: true,\n            allow_home_inference: false,\n        });\n        \n        privacy_manager.apply_obfuscation(location)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing--validation",children:"Testing & Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[cfg(test)]\nmod privacy_tests {\n    use super::*;\n    \n    #[test]\n    fn test_grid_snapping_preserves_general_area() {\n        let original_location = create_test_location(37.7749, -122.4194); // SF\n        \n        let config = GridConfig {\n            cell_size: 100.0,\n            origin_lat: 0.0,\n            origin_lon: 0.0,\n            add_random_offset: false,\n        };\n        \n        let snapper = GridSnapper::new(config);\n        let snapped = snapper.snap_location(&original_location);\n        \n        // Should be within reasonable distance\n        let distance = Coordinate::haversine_distance(\n            original_location.measurement.value.x(), original_location.measurement.value.y(),\n            snapped.measurement.value.x(), snapped.measurement.value.y()\n        );\n        \n        assert!(distance <= 100.0 * std::f64::consts::SQRT_2); // Maximum diagonal distance\n    }\n    \n    #[test]\n    fn test_differential_privacy_bounds() {\n        let location = create_test_location(37.7749, -122.4194);\n        let noise_adder = LaplacianNoiseAdder::new(0.1); // Strong privacy\n        \n        let mut distances = Vec::new();\n        \n        // Test multiple noise additions\n        for _ in 0..1000 {\n            let noisy = noise_adder.add_noise(&location);\n            let distance = Coordinate::haversine_distance(\n                location.measurement.value.x(), location.measurement.value.y(),\n                noisy.measurement.value.x(), noisy.measurement.value.y()\n            );\n            distances.push(distance);\n        }\n        \n        // Most points should be within reasonable bounds for epsilon=0.1\n        let median_distance = {\n            distances.sort_by(|a, b| a.partial_cmp(b).unwrap());\n            distances[distances.len() / 2]\n        };\n        \n        assert!(median_distance > 1.0);   // Should add meaningful noise\n        assert!(median_distance < 50.0);  // But not too much for epsilon=0.1\n    }\n    \n    #[test] \n    fn test_k_anonymity_enforcement() {\n        let mut anonymizer = SpatialKAnonymizer::new(5); // k=5\n        \n        // Add insufficient users\n        for i in 0..3 {\n            let location = create_test_location(37.7749 + i as f64 * 0.0001, -122.4194);\n            anonymizer.add_user_location(UserId(i), location);\n        }\n        \n        let test_location = create_test_location(37.7749, -122.4194);\n        let result = anonymizer.anonymize_location(UserId(999), &test_location);\n        \n        // Should fail due to insufficient k-anonymity\n        assert!(matches!(result, Err(PrivacyError::InsufficientKAnonymity { .. })));\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"configuration-guidelines",children:"Configuration Guidelines"}),"\n",(0,t.jsx)(e.h3,{id:"privacy-level-recommendations",children:"Privacy Level Recommendations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"// Public spaces (low privacy concerns)\nlet public_config = LocationPrivacyConfig {\n    obfuscation_method: ObfuscationMethod::GridSnap { cell_size: 25.0 },\n    noise_level: NoiseLevel::Low,\n    preserve_temporal_patterns: true,\n    allow_home_inference: false,\n};\n\n// Residential areas (medium privacy concerns)\nlet residential_config = LocationPrivacyConfig {\n    obfuscation_method: ObfuscationMethod::AdaptiveGrid {\n        base_cell_size: 100.0,\n        min_k_anonymity: 5,\n    },\n    noise_level: NoiseLevel::Medium,\n    preserve_temporal_patterns: false,\n    allow_home_inference: false,\n};\n\n// Sensitive locations (high privacy concerns)\nlet sensitive_config = LocationPrivacyConfig {\n    obfuscation_method: ObfuscationMethod::SemanticCloaking {\n        level: SemanticLevel::Neighborhood,\n    },\n    noise_level: NoiseLevel::High,\n    preserve_temporal_patterns: false,\n    allow_home_inference: false,\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/extensions/location/tracking",children:"GPS Tracking"})," - Core location tracking capabilities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/extensions/location/visit-detection",children:"Visit Detection"})," - Visit detection algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/extensions/privacy/",children:"Privacy Extension"})," - Core privacy techniques and compliance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/concepts/measurements",children:"Universal Measurement Foundation"})," - Uncertainty and provenance tracking"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>l});var a=i(6540);const t={},o=a.createContext(t);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);