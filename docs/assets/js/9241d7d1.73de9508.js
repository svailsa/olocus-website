"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[3461],{6818:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"architecture/scalability-roadmap","title":"Scalability Roadmap","description":"The Olocus Protocol achieves internet-scale deployment through a layered approach that preserves the minimal core while adding scalability features as optional extensions. This roadmap outlines how the protocol scales from single-node deployment to global infrastructure.","source":"@site/docs/architecture/scalability-roadmap.md","sourceDirName":"architecture","slug":"/architecture/scalability-roadmap","permalink":"/docs/architecture/scalability-roadmap","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/architecture/scalability-roadmap.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":5,"frontMatter":{"id":"scalability-roadmap","title":"Scalability Roadmap","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Formal Verification","permalink":"/docs/architecture/formal-verification"},"next":{"title":"Core API Reference","permalink":"/docs/api/core"}}');var a=i(4848),t=i(8453);const r={id:"scalability-roadmap",title:"Scalability Roadmap",sidebar_position:5},l="Scalability Roadmap",c={},o=[{value:"Scaling Philosophy",id:"scaling-philosophy",level:2},{value:"Layered Scaling Approach",id:"layered-scaling-approach",level:3},{value:"Design Principle",id:"design-principle",level:3},{value:"Phase 1: Transport &amp; Federation Layer",id:"phase-1-transport--federation-layer",level:2},{value:"HTTP/REST Transport Mapping",id:"httprest-transport-mapping",level:3},{value:"Federation Protocol",id:"federation-protocol",level:3},{value:"Phase 2: Multi-Writer &amp; Sharding",id:"phase-2-multi-writer--sharding",level:2},{value:"Namespace-Based Sharding",id:"namespace-based-sharding",level:3},{value:"Sharding Strategies",id:"sharding-strategies",level:3},{value:"Cross-Shard References",id:"cross-shard-references",level:3},{value:"Phase 3: Snapshots &amp; Light Clients",id:"phase-3-snapshots--light-clients",level:2},{value:"Canonical Checkpoints",id:"canonical-checkpoints",level:3},{value:"Merkle Snapshot Protocol",id:"merkle-snapshot-protocol",level:3},{value:"Intelligent Pruning",id:"intelligent-pruning",level:3},{value:"Phase 4: Performance Optimizations",id:"phase-4-performance-optimizations",level:2},{value:"Batch Verification",id:"batch-verification",level:3},{value:"Capability Caching",id:"capability-caching",level:3},{value:"Asynchronous Validation",id:"asynchronous-validation",level:3},{value:"Phase 5: CDN &amp; Caching Integration",id:"phase-5-cdn--caching-integration",level:2},{value:"Content-Addressed Caching",id:"content-addressed-caching",level:3},{value:"CDN-Optimized Operations",id:"cdn-optimized-operations",level:3},{value:"Performance Targets",id:"performance-targets",level:2},{value:"Current Performance (Single Node)",id:"current-performance-single-node",level:3},{value:"Internet Scale Targets",id:"internet-scale-targets",level:3},{value:"Implementation Priority",id:"implementation-priority",level:2},{value:"Phase 1-2 (Must Do)",id:"phase-1-2-must-do",level:3},{value:"Phase 3-4 (Should Do)",id:"phase-3-4-should-do",level:3},{value:"Phase 5 (Nice to Have)",id:"phase-5-nice-to-have",level:3},{value:"Migration Strategy",id:"migration-strategy",level:2},{value:"Backward Compatibility",id:"backward-compatibility",level:3},{value:"Deployment Path",id:"deployment-path",level:3},{value:"Success Metrics",id:"success-metrics",level:2},{value:"Phase 1 Success (Q1 2025)",id:"phase-1-success-q1-2025",level:3},{value:"Phase 2 Success (Q2 2025)",id:"phase-2-success-q2-2025",level:3},{value:"Phase 3 Success (Q3 2025)",id:"phase-3-success-q3-2025",level:3},{value:"Full Scale Success (Q4 2025)",id:"full-scale-success-q4-2025",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Trade-offs and Mitigations",id:"trade-offs-and-mitigations",level:3},{value:"Future Research",id:"future-research",level:2},{value:"Beyond Current Roadmap",id:"beyond-current-roadmap",level:3}];function d(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"scalability-roadmap",children:"Scalability Roadmap"})}),"\n",(0,a.jsx)(n.p,{children:"The Olocus Protocol achieves internet-scale deployment through a layered approach that preserves the minimal core while adding scalability features as optional extensions. This roadmap outlines how the protocol scales from single-node deployment to global infrastructure."}),"\n",(0,a.jsx)(n.h2,{id:"scaling-philosophy",children:"Scaling Philosophy"}),"\n",(0,a.jsx)(n.h3,{id:"layered-scaling-approach",children:"Layered Scaling Approach"}),"\n",(0,a.jsx)(n.p,{children:"Following successful internet protocols like SMTP and HTTP, Olocus embraces:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Statelessness"}),": Protocol operations don't require persistent connections\n",(0,a.jsx)(n.strong,{children:"Intermediaries"}),": Relay nodes, caches, and proxies enhance distribution\n",(0,a.jsx)(n.strong,{children:"Content Addressing"}),": Blocks identified by cryptographic hashes\n",(0,a.jsx)(n.strong,{children:"Federation"}),": Store-and-forward architecture like email"]}),"\n",(0,a.jsx)(n.h3,{id:"design-principle",children:"Design Principle"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:'"Embrace statelessness, intermediaries, caching, and well-known transport mappings"'}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This approach enables:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"CDN integration for global distribution"}),"\n",(0,a.jsx)(n.li,{children:"Corporate proxy compatibility"}),"\n",(0,a.jsx)(n.li,{children:"Lightweight client support"}),"\n",(0,a.jsx)(n.li,{children:"Horizontal scaling through parallelism"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"phase-1-transport--federation-layer",children:"Phase 1: Transport & Federation Layer"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Target: Q1 2025"})}),"\n",(0,a.jsx)(n.h3,{id:"httprest-transport-mapping",children:"HTTP/REST Transport Mapping"}),"\n",(0,a.jsx)(n.p,{children:"Create stateless REST endpoints for block operations:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"# Core Block Operations\nPOST   /blocks                    # Submit new block\nGET    /blocks/{hash}             # Fetch block by hash\nGET    /chains/{chain_id}/head    # Get chain head\nGET    /chains/{chain_id}/blocks  # List blocks (paginated)\n\n# Light Client Operations  \nGET    /blocks/{hash}/proof       # Merkle inclusion proof\nGET    /snapshots/{height}        # Chain snapshot at height\nGET    /blocks/{hash}/header      # Header only (no payload)\n\n# Federation Operations\nPOST   /announce                  # Block existence announcement\nGET    /peers                     # Discover other nodes\nPOST   /relay                     # Forward block to peers\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Implementation Benefits"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Reuses existing wire format as HTTP body"}),"\n",(0,a.jsxs)(n.li,{children:["Standard HTTP headers: ",(0,a.jsx)(n.code,{children:"Content-Type: application/x-olocus-block"})]}),"\n",(0,a.jsxs)(n.li,{children:["Supports ",(0,a.jsx)(n.code,{children:"ETag"})," (block hash), ",(0,a.jsx)(n.code,{children:"Cache-Control"}),", ",(0,a.jsx)(n.code,{children:"If-None-Match"})]}),"\n",(0,a.jsx)(n.li,{children:"Enables range requests for large payloads"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"federation-protocol",children:"Federation Protocol"}),"\n",(0,a.jsx)(n.p,{children:"Define SMTP-like relay semantics with multiple node roles:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub enum NodeRole {\n    Origin,      // Creates blocks (has signing key)\n    Relay,       // Forwards blocks (no signing capability)\n    Cache,       // Stores popular blocks for fast access\n    Archive,     // Stores complete historical blocks\n    Light,       // Verifies without storing\n}\n\npub struct FederationConfig {\n    pub accept_unsigned_relay: bool,      // Allow untrusted relays\n    pub max_relay_hops: u8,               // Prevent infinite loops\n    pub cache_popular_threshold: u32,     // Cache blocks after N requests\n    pub archive_retention_days: Option<u32>, // Full history retention\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Enables CDN integration for global distribution"}),"\n",(0,a.jsx)(n.li,{children:"Supports corporate proxies and firewalls"}),"\n",(0,a.jsx)(n.li,{children:"Allows lightweight mobile clients"}),"\n",(0,a.jsx)(n.li,{children:"Preserves end-to-end cryptographic verification"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"phase-2-multi-writer--sharding",children:"Phase 2: Multi-Writer & Sharding"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Target: Q1-Q2 2025"})}),"\n",(0,a.jsx)(n.h3,{id:"namespace-based-sharding",children:"Namespace-Based Sharding"}),"\n",(0,a.jsx)(n.p,{children:"Add namespace support to enable parallel chains:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct BlockHeader {\n    pub version: u16,\n    pub chain_namespace: [u8; 16],  // NEW: UUID namespace identifier\n    pub index: u64,                 // Per-namespace sequence number\n    pub timestamp: i64,\n    pub previous: [u8; 32],         // Previous block in same namespace\n    pub payload_hash: [u8; 32],\n    pub payload_type: u32,\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"sharding-strategies",children:"Sharding Strategies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'pub enum ShardingStrategy {\n    // Each writer owns a dedicated namespace\n    PerWriter { \n        writer_id: PublicKey,\n        namespace: [u8; 16],\n    },\n    \n    // Geographic partitioning\n    Geographic {\n        region: String,              // "us-west", "eu-central"\n        namespace: [u8; 16],\n    },\n    \n    // Topic-based partitioning  \n    Topic {\n        topic_id: String,            // "location", "metrics"\n        namespace: [u8; 16],\n    },\n    \n    // Time-based rolling shards\n    Temporal {\n        epoch: u64,                  // Unix timestamp epoch\n        duration_seconds: u64,       // Shard duration\n    },\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"cross-shard-references",children:"Cross-Shard References"}),"\n",(0,a.jsx)(n.p,{children:"Enable secure references between different shards:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct CrossShardReference {\n    pub source_namespace: [u8; 16],      // Referencing shard\n    pub source_block: [u8; 32],          // Block hash in source\n    pub target_namespace: [u8; 16],      // Referenced shard\n    pub target_block: [u8; 32],          // Referenced block\n    pub proof: MerkleProof,              // Inclusion proof\n    pub timestamp: i64,                  // Reference timestamp\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Parallel write throughput across shards"}),"\n",(0,a.jsx)(n.li,{children:"Natural partitioning boundaries by use case"}),"\n",(0,a.jsx)(n.li,{children:"Maintains total ordering within each shard"}),"\n",(0,a.jsx)(n.li,{children:"Enables selective synchronization"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"phase-3-snapshots--light-clients",children:"Phase 3: Snapshots & Light Clients"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Target: Q2 2025"})}),"\n",(0,a.jsx)(n.h3,{id:"canonical-checkpoints",children:"Canonical Checkpoints"}),"\n",(0,a.jsx)(n.p,{children:"Define checkpoint mechanisms for history finalization:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct CheckpointPayload {\n    pub checkpoint_height: u64,          // Block height of checkpoint\n    pub chain_namespace: [u8; 16],       // Namespace being checkpointed\n    pub state_root: [u8; 32],            // Merkle root of all blocks\n    pub pruning_boundary: u64,           // Safe pruning point\n    pub block_count: u64,                // Total blocks included\n    pub signature_aggregation: Vec<u8>,  // Optional: multiple signatures\n    pub tsa_timestamp: Option<Vec<u8>>,  // RFC 3161 timestamp\n}\n\nimpl BlockPayload for CheckpointPayload {\n    fn payload_type() -> u32 { 0x00FF } // Reserved checkpoint type\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"merkle-snapshot-protocol",children:"Merkle Snapshot Protocol"}),"\n",(0,a.jsx)(n.p,{children:"Enable fast verification without complete history:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct SnapshotProof {\n    pub snapshot_height: u64,            // Height at snapshot\n    pub state_root: [u8; 32],            // Merkle root of state\n    pub block_count: u64,                // Number of blocks included\n    pub total_size_bytes: u64,           // Total historical size\n    pub merkle_depth: u8,                // Depth of Merkle tree\n    pub creation_timestamp: i64,         // When snapshot created\n}\n\npub trait LightClientProtocol {\n    // Verify block against snapshot without full history\n    fn verify_with_snapshot(\n        &self,\n        block: &Block,\n        proof: &MerkleProof,\n        snapshot: &SnapshotProof,\n    ) -> Result<bool>;\n    \n    // Verify chain continuity from snapshot\n    fn verify_chain_from_snapshot(\n        &self,\n        blocks: &[Block],\n        snapshot: &SnapshotProof,\n    ) -> Result<bool>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"intelligent-pruning",children:"Intelligent Pruning"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct PruningPolicy {\n    pub mode: PruningMode,\n    pub retention_blocks: u64,           // Keep recent N blocks\n    pub archive_url: Option<String>,     // Archive service URL\n    pub min_checkpoint_interval: u64,    // Blocks between checkpoints\n}\n\npub enum PruningMode {\n    None,                                // Keep everything (archive mode)\n    AfterCheckpoint,                     // Prune after checkpoint confirmation\n    KeepRecent { days: u32 },           // Keep recent N days only\n    KeepHeaders,                         // Prune payloads, keep headers\n    Selective { policy: SelectionPolicy }, // Custom pruning logic\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Bounded storage growth for normal nodes"}),"\n",(0,a.jsx)(n.li,{children:"Fast synchronization for new participants"}),"\n",(0,a.jsx)(n.li,{children:"Maintains cryptographic verifiability"}),"\n",(0,a.jsx)(n.li,{children:"Archive nodes preserve complete history"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"phase-4-performance-optimizations",children:"Phase 4: Performance Optimizations"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Target: Q2-Q3 2025"})}),"\n",(0,a.jsx)(n.h3,{id:"batch-verification",children:"Batch Verification"}),"\n",(0,a.jsx)(n.p,{children:"Optimize cryptographic operations through batching:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub trait BatchVerification {\n    // Verify multiple blocks in parallel\n    fn verify_batch(\n        blocks: &[Block],\n        parallel: bool,\n    ) -> Vec<Result<bool>>;\n    \n    // Verify aggregated signatures when available\n    fn verify_aggregated_signature(\n        blocks: &[Block],\n        aggregated_sig: &[u8],\n        public_keys: &[PublicKey],\n    ) -> Result<bool>;\n    \n    // Batch hash verification\n    fn verify_hash_batch(\n        blocks: &[Block],\n    ) -> Vec<bool>;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"capability-caching",children:"Capability Caching"}),"\n",(0,a.jsx)(n.p,{children:"Replace expensive per-connection negotiation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct CachedCapabilities {\n    pub peer_id: PublicKey,              // Peer identifier\n    pub capabilities: Capabilities,      // Negotiated capabilities\n    pub negotiated_at: i64,             // Negotiation timestamp\n    pub session_token: [u8; 32],        // Reusable session token\n    pub expires_at: i64,                // Cache expiration\n    pub signature: [u8; 64],            // Token signature\n}\n\npub struct HandshakeCache {\n    cache: LruCache<PublicKey, CachedCapabilities>,\n    max_age_seconds: u64,               // Maximum cache age\n    max_entries: usize,                 // Cache size limit\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"asynchronous-validation",children:"Asynchronous Validation"}),"\n",(0,a.jsx)(n.p,{children:"Support different consistency levels:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub enum ConsistencyLevel {\n    Immediate,      // Fully validated before response (strongest)\n    Eventual,       // Accept now, validate asynchronously\n    StaleOk,        // Return cached result without revalidation\n}\n\npub struct AsyncValidator {\n    validation_queue: VecDeque<Block>,   // Pending validation\n    worker_threads: usize,              // Validation parallelism\n    consistency: ConsistencyLevel,      // Required consistency\n    max_queue_size: usize,              // Backpressure limit\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"phase-5-cdn--caching-integration",children:"Phase 5: CDN & Caching Integration"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Target: Q3 2025"})}),"\n",(0,a.jsx)(n.h3,{id:"content-addressed-caching",children:"Content-Addressed Caching"}),"\n",(0,a.jsx)(n.p,{children:"Leverage hash-based addressing for efficient caching:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub struct CacheableBlock {\n    pub block: Block,\n    pub cache_control: CacheDirective,\n    pub etag: String,                    // Block hash as ETag\n    pub vary: Vec<String>,               // Variation headers\n    pub content_encoding: Option<String>, // Compression used\n}\n\npub enum CacheDirective {\n    Immutable,                          // Never changes (content-addressed)\n    MaxAge { seconds: u64 },            // Time-based expiry\n    MustRevalidate,                     // Always check with origin\n    Private,                            // Don't cache in shared proxies\n    NoCache,                            // Don't cache at all\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cdn-optimized-operations",children:"CDN-Optimized Operations"}),"\n",(0,a.jsx)(n.p,{children:"Design operations that work well with CDNs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// Lightweight announcement without full block\npub struct BlockAnnounce {\n    pub block_hash: [u8; 32],           // Block identifier\n    pub chain_namespace: [u8; 16],      // Shard identifier\n    pub height: u64,                    // Block height\n    pub size_bytes: u32,                // Payload size\n    pub timestamp: i64,                 // Block timestamp\n    pub signature: [u8; 64],            // Announcement signature\n}\n\n// Support range requests for large payloads\npub struct BlockRange {\n    pub block_hash: [u8; 32],           // Target block\n    pub offset: u64,                    // Byte offset\n    pub length: u64,                    // Byte length\n}\n\n// Batch operations for efficiency\npub struct BatchRequest {\n    pub block_hashes: Vec<[u8; 32]>,    // Multiple blocks\n    pub include_proofs: bool,           // Include Merkle proofs\n    pub compression: CompressionType,   // Preferred compression\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"performance-targets",children:"Performance Targets"}),"\n",(0,a.jsx)(n.h3,{id:"current-performance-single-node",children:"Current Performance (Single Node)"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operation"}),(0,a.jsx)(n.th,{children:"Target"}),(0,a.jsx)(n.th,{children:"Typical"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Block creation"}),(0,a.jsx)(n.td,{children:"<2ms"}),(0,a.jsx)(n.td,{children:"~1ms"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Signature verification"}),(0,a.jsx)(n.td,{children:"<1ms"}),(0,a.jsx)(n.td,{children:"~0.5ms"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Memory usage"}),(0,a.jsx)(n.td,{children:"<25MB"}),(0,a.jsx)(n.td,{children:"~15MB"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Chain validation (1000 blocks)"}),(0,a.jsx)(n.td,{children:"<100ms"}),(0,a.jsx)(n.td,{children:"~60ms"})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"internet-scale-targets",children:"Internet Scale Targets"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Metric"}),(0,a.jsx)(n.th,{children:"Target"}),(0,a.jsx)(n.th,{children:"Scaling Method"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Write throughput"}),(0,a.jsx)(n.td,{children:"10,000 blocks/sec"}),(0,a.jsx)(n.td,{children:"Namespace sharding"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Read throughput"}),(0,a.jsx)(n.td,{children:"1M blocks/sec"}),(0,a.jsx)(n.td,{children:"CDN + caching"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Verification rate"}),(0,a.jsx)(n.td,{children:"100,000 sigs/sec"}),(0,a.jsx)(n.td,{children:"Batch verification"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Bootstrap time"}),(0,a.jsx)(n.td,{children:"<1 minute"}),(0,a.jsx)(n.td,{children:"Snapshots"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Storage growth"}),(0,a.jsx)(n.td,{children:"<1GB/day"}),(0,a.jsx)(n.td,{children:"Pruning policies"})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"implementation-priority",children:"Implementation Priority"}),"\n",(0,a.jsx)(n.h3,{id:"phase-1-2-must-do",children:"Phase 1-2 (Must Do)"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Critical for Scale:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"HTTP/REST mapping"})," - Leverages existing web infrastructure"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Namespace sharding"})," - Enables parallel write throughput"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Federation protocol"})," - Enables relay/cache node deployment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Checkpoint mechanism"})," - Enables light clients"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"phase-3-4-should-do",children:"Phase 3-4 (Should Do)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Performance Optimizations:"}),"\n5. ",(0,a.jsx)(n.strong,{children:"Batch verification"})," - Improves signature throughput\n6. ",(0,a.jsx)(n.strong,{children:"Capability caching"})," - Reduces handshake overhead\n7. ",(0,a.jsx)(n.strong,{children:"Async validation"})," - Improves response latency\n8. ",(0,a.jsx)(n.strong,{children:"Pruning policies"})," - Controls storage growth"]}),"\n",(0,a.jsx)(n.h3,{id:"phase-5-nice-to-have",children:"Phase 5 (Nice to Have)"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Advanced Features:"}),"\n9. ",(0,a.jsx)(n.strong,{children:"CDN integration"})," - Leverages global content distribution\n10. ",(0,a.jsx)(n.strong,{children:"Content addressing"})," - Enables distributed caching\n11. ",(0,a.jsx)(n.strong,{children:"Range requests"})," - Optimizes large payload handling"]}),"\n",(0,a.jsx)(n.h2,{id:"migration-strategy",children:"Migration Strategy"}),"\n",(0,a.jsx)(n.h3,{id:"backward-compatibility",children:"Backward Compatibility"}),"\n",(0,a.jsx)(n.p,{children:"All scaling features maintain backward compatibility:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Core protocol unchanged"})," - Existing implementations continue working"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Opt-in extensions"})," - New features are optional"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Single-writer support"})," - Original use cases preserved"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"P2P coexistence"})," - P2P and HTTP nodes interoperate"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Gradual adoption"})," - Incremental deployment possible"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"deployment-path",children:"Deployment Path"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Stage 1: HTTP Gateway"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Deploy HTTP gateways in front of existing nodes"}),"\n",(0,a.jsx)(n.li,{children:"Enable web integration without code changes"}),"\n",(0,a.jsx)(n.li,{children:"Add caching and load balancing"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Stage 2: Namespace Adoption"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Migrate high-throughput applications to namespaces"}),"\n",(0,a.jsx)(n.li,{children:"Deploy parallel writers for different use cases"}),"\n",(0,a.jsx)(n.li,{children:"Maintain single-namespace chains for simple applications"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Stage 3: Light Client Rollout"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Deploy snapshot services"}),"\n",(0,a.jsx)(n.li,{children:"Enable mobile and IoT light clients"}),"\n",(0,a.jsx)(n.li,{children:"Reduce bandwidth requirements"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Stage 4: Global Distribution"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Deploy CDN integration"}),"\n",(0,a.jsx)(n.li,{children:"Enable global relay networks"}),"\n",(0,a.jsx)(n.li,{children:"Optimize for geographic distribution"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"success-metrics",children:"Success Metrics"}),"\n",(0,a.jsx)(n.h3,{id:"phase-1-success-q1-2025",children:"Phase 1 Success (Q1 2025)"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","HTTP gateway handling 1,000 requests/second"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Federation with 10+ relay nodes operational"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","CDN proof-of-concept demonstrating caching"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Single namespace supporting 100 blocks/second"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"phase-2-success-q2-2025",children:"Phase 2 Success (Q2 2025)"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","10+ parallel namespaces in production"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Cross-shard references working correctly"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Write throughput exceeding 1,000 blocks/second"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Namespace-aware client libraries available"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"phase-3-success-q3-2025",children:"Phase 3 Success (Q3 2025)"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Light clients syncing in under 1 minute"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Storage growth under 1GB/day with pruning"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Snapshot-based verification working"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Mobile clients with acceptable performance"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"full-scale-success-q4-2025",children:"Full Scale Success (Q4 2025)"}),"\n",(0,a.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Internet-scale deployment (>1M nodes)"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Performance competitive with IPFS/BitTorrent"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Major applications using the protocol"]}),"\n",(0,a.jsxs)(n.li,{className:"task-list-item",children:[(0,a.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Global relay network operational"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"trade-offs-and-mitigations",children:"Trade-offs and Mitigations"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Pruning vs. Auditability"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Risk"}),": Pruned history unavailable for audit"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Mitigation"}),": Archive nodes maintain complete history"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Acceptance"}),": Most nodes benefit from bounded storage"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Multi-writer Complexity"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Risk"}),": Increased attack surface from namespace management"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Mitigation"}),": Clear namespace ownership and isolation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Acceptance"}),": Performance benefits justify complexity"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Caching vs. Freshness"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Risk"}),": Stale data served from caches"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Mitigation"}),": Configurable consistency levels"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Acceptance"}),": Performance worth eventual consistency option"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Federation vs. Trust"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Risk"}),": Relay nodes could act maliciously"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Mitigation"}),": End-to-end verification still required"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Acceptance"}),": Improves availability and distribution"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"future-research",children:"Future Research"}),"\n",(0,a.jsx)(n.h3,{id:"beyond-current-roadmap",children:"Beyond Current Roadmap"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Advanced Scaling Techniques:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Sharded state machines"}),"\n",(0,a.jsx)(n.li,{children:"Cross-shard atomic transactions"}),"\n",(0,a.jsx)(n.li,{children:"Dynamic namespace rebalancing"}),"\n",(0,a.jsx)(n.li,{children:"Predictive caching algorithms"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Next-Generation Protocols:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Integration with emerging storage protocols"}),"\n",(0,a.jsx)(n.li,{children:"Quantum-safe distribution mechanisms"}),"\n",(0,a.jsx)(n.li,{children:"AI-assisted optimization"}),"\n",(0,a.jsx)(n.li,{children:"Edge computing integration"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The scalability roadmap transforms Olocus from a correct minimal protocol into an internet-scale infrastructure while preserving the security and simplicity that make it valuable."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);