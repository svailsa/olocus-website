"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[4109],{2031:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"extensions/location/visit-detection","title":"Visit Detection","description":"The Location extension provides sophisticated visit detection capabilities using clustering algorithms to identify meaningful stays and locations in movement data.","source":"@site/docs/extensions/location/visit-detection.md","sourceDirName":"extensions/location","slug":"/extensions/location/visit-detection","permalink":"/docs/extensions/location/visit-detection","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/location/visit-detection.md","tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":2,"frontMatter":{"id":"visit-detection","title":"Visit Detection","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"GPS Tracking & Coordinates","permalink":"/docs/extensions/location/tracking"},"next":{"title":"Clustering Algorithms","permalink":"/docs/extensions/location/clustering"}}');var s=i(4848),a=i(8453);const o={id:"visit-detection",title:"Visit Detection",sidebar_position:2},l="Visit Detection",r={},c=[{value:"Overview",id:"overview",level:2},{value:"DBSCAN Clustering",id:"dbscan-clustering",level:2},{value:"Algorithm Configuration",id:"algorithm-configuration",level:3},{value:"Clustering Process",id:"clustering-process",level:3},{value:"DBSCAN Parameters",id:"dbscan-parameters",level:3},{value:"Visit Detection Algorithm",id:"visit-detection-algorithm",level:2},{value:"Real-Time Visit Detection",id:"real-time-visit-detection",level:3},{value:"Dwell Time Analysis",id:"dwell-time-analysis",level:3},{value:"Visit Classification",id:"visit-classification",level:2},{value:"Visit Types",id:"visit-types",level:3},{value:"Classification Algorithm",id:"classification-algorithm",level:3},{value:"Advanced Clustering Algorithms",id:"advanced-clustering-algorithms",level:2},{value:"K-Means Clustering",id:"k-means-clustering",level:3},{value:"OPTICS Clustering",id:"optics-clustering",level:3},{value:"HDBSCAN Clustering",id:"hdbscan-clustering",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Incremental Processing",id:"incremental-processing",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Real-Time Visit Stream",id:"real-time-visit-stream",level:3},{value:"Batch Visit Analysis",id:"batch-visit-analysis",level:3},{value:"Visit Analytics",id:"visit-analytics",level:3},{value:"Testing &amp; Validation",id:"testing--validation",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Urban Environment",id:"urban-environment",level:3},{value:"Rural Environment",id:"rural-environment",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"visit-detection",children:"Visit Detection"})}),"\n",(0,s.jsx)(n.p,{children:"The Location extension provides sophisticated visit detection capabilities using clustering algorithms to identify meaningful stays and locations in movement data."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Visit detection analyzes sequences of location measurements to identify:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stops"}),": Stationary periods exceeding minimum dwell time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visits"}),": Semantically meaningful locations (home, work, shops)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transitions"}),": Movement between significant locations"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_location::visit::*;\nuse olocus_location::clustering::*;\n\n// Configure visit detection\nlet config = VisitConfig {\n    min_dwell_time: Duration::from_mins(5),    // 5 minute minimum\n    max_distance: 50.0,                        // 50m radius for visit\n    clustering_algorithm: ClusteringAlgorithm::DBSCAN {\n        epsilon: 30.0,      // 30m cluster radius\n        min_points: 3,      // minimum 3 points per visit\n    },\n};\n\nlet detector = VisitDetector::new(config);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dbscan-clustering",children:"DBSCAN Clustering"}),"\n",(0,s.jsx)(n.p,{children:"DBSCAN (Density-Based Spatial Clustering) is the primary algorithm for visit detection:"}),"\n",(0,s.jsx)(n.h3,{id:"algorithm-configuration",children:"Algorithm Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_location::clustering::dbscan::*;\n\nlet dbscan_config = DBSCANConfig {\n    epsilon: 30.0,           // Maximum distance between points (meters)\n    min_points: 3,           // Minimum points to form a cluster\n    distance_metric: DistanceMetric::Haversine, // Geographic distance\n};\n\nlet dbscan = DBSCANClusterer::new(dbscan_config);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"clustering-process",children:"Clustering Process"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Input: sequence of location measurements\nlet locations: Vec<LocationMeasurement> = get_location_history();\n\n// Run DBSCAN clustering\nlet clusters = dbscan.cluster(&locations)?;\n\nfor cluster in clusters {\n    match cluster {\n        Cluster::Core { id, points, centroid } => {\n            println!("Visit detected at ({:.6}, {:.6}) with {} points", \n                centroid.latitude, centroid.longitude, points.len());\n        },\n        Cluster::Noise { points } => {\n            println!("Transit points: {} locations", points.len());\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dbscan-parameters",children:"DBSCAN Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Urban environment (dense GPS data)\nlet urban_config = DBSCANConfig {\n    epsilon: 25.0,      // Smaller radius for precise urban locations\n    min_points: 4,      // More points needed due to GPS density\n    distance_metric: DistanceMetric::Haversine,\n};\n\n// Rural environment (sparse GPS data)  \nlet rural_config = DBSCANConfig {\n    epsilon: 100.0,     // Larger radius for sparse data\n    min_points: 2,      // Fewer points available\n    distance_metric: DistanceMetric::Haversine,\n};\n\n// Indoor environment (WiFi/Bluetooth beacons)\nlet indoor_config = DBSCANConfig {\n    epsilon: 10.0,      // High precision indoor positioning\n    min_points: 5,      // Dense beacon coverage\n    distance_metric: DistanceMetric::Euclidean,\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"visit-detection-algorithm",children:"Visit Detection Algorithm"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-visit-detection",children:"Real-Time Visit Detection"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use std::collections::VecDeque;\n\npub struct VisitDetector {\n    config: VisitConfig,\n    location_buffer: VecDeque<LocationMeasurement>,\n    current_visit: Option<PendingVisit>,\n    clusterer: Box<dyn ClusteringAlgorithm>,\n}\n\nimpl VisitDetector {\n    pub fn add_location(&mut self, location: LocationMeasurement) -> Result<Vec<Visit>> {\n        self.location_buffer.push_back(location.clone());\n        \n        // Keep rolling window of recent locations\n        if self.location_buffer.len() > self.config.max_buffer_size {\n            self.location_buffer.pop_front();\n        }\n        \n        // Check for visit completion\n        let mut completed_visits = Vec::new();\n        \n        if let Some(ref mut visit) = self.current_visit {\n            if self.is_visit_ended(&location, visit) {\n                // Complete the current visit\n                let finished_visit = self.finalize_visit(visit.clone())?;\n                completed_visits.push(finished_visit);\n                self.current_visit = None;\n            } else {\n                // Continue current visit\n                visit.locations.push(location);\n                visit.end_time = location.timestamp;\n            }\n        }\n        \n        // Check for new visit start\n        if self.current_visit.is_none() {\n            if let Some(new_visit) = self.detect_new_visit(&location)? {\n                self.current_visit = Some(new_visit);\n            }\n        }\n        \n        Ok(completed_visits)\n    }\n    \n    fn is_visit_ended(&self, location: &LocationMeasurement, visit: &PendingVisit) -> bool {\n        // Check if moved too far from visit centroid\n        let distance = Coordinate::haversine_distance(\n            visit.centroid.latitude,\n            visit.centroid.longitude,\n            location.measurement.value.x(),\n            location.measurement.value.y()\n        );\n        \n        distance > self.config.max_distance\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dwell-time-analysis",children:"Dwell Time Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug, Clone)]\npub struct DwellTimeAnalysis {\n    pub total_duration: Duration,\n    pub active_duration: Duration,     // Time with movement\n    pub stationary_duration: Duration, // Time without movement  \n    pub movement_ratio: f64,           // active / total\n}\n\nimpl VisitDetector {\n    fn analyze_dwell_time(&self, locations: &[LocationMeasurement]) -> DwellTimeAnalysis {\n        let mut active_duration = Duration::ZERO;\n        let mut total_duration = Duration::ZERO;\n        \n        for window in locations.windows(2) {\n            let [prev, curr] = [&window[0], &window[1]];\n            let time_delta = curr.timestamp.duration_since(prev.timestamp).unwrap_or_default();\n            total_duration += time_delta;\n            \n            // Check for movement above threshold\n            let distance = Coordinate::haversine_distance(\n                prev.measurement.value.x(), prev.measurement.value.y(),\n                curr.measurement.value.x(), curr.measurement.value.y()\n            );\n            \n            if distance > self.config.movement_threshold {\n                active_duration += time_delta;\n            }\n        }\n        \n        let movement_ratio = if total_duration.as_secs() > 0 {\n            active_duration.as_secs_f64() / total_duration.as_secs_f64()\n        } else {\n            0.0\n        };\n        \n        DwellTimeAnalysis {\n            total_duration,\n            active_duration,\n            stationary_duration: total_duration - active_duration,\n            movement_ratio,\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"visit-classification",children:"Visit Classification"}),"\n",(0,s.jsx)(n.h3,{id:"visit-types",children:"Visit Types"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug, Clone, PartialEq)]\npub enum VisitType {\n    Home,           // Frequent overnight stays\n    Work,           // Weekday daytime stays  \n    School,         // Regular educational visits\n    Shopping,       // Short commercial visits\n    Recreation,     // Entertainment venues\n    Transit,        // Transportation hubs\n    Unknown,        // Unclassified visits\n}\n\n#[derive(Debug, Clone)]\npub struct Visit {\n    pub id: VisitId,\n    pub centroid: Coordinate,\n    pub radius: f64,                    // Visit area radius\n    pub start_time: SystemTime,\n    pub end_time: SystemTime,\n    pub duration: Duration,\n    pub visit_type: VisitType,\n    pub confidence: f64,                // Classification confidence\n    pub locations: Vec<LocationMeasurement>,\n    pub dwell_analysis: DwellTimeAnalysis,\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"classification-algorithm",children:"Classification Algorithm"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl VisitClassifier {\n    pub fn classify_visit(&self, visit: &Visit) -> (VisitType, f64) {\n        let features = self.extract_features(visit);\n        \n        // Rule-based classification\n        if self.is_home_visit(&features) {\n            (VisitType::Home, features.home_confidence)\n        } else if self.is_work_visit(&features) {\n            (VisitType::Work, features.work_confidence)\n        } else if self.is_shopping_visit(&features) {\n            (VisitType::Shopping, features.shopping_confidence)\n        } else {\n            (VisitType::Unknown, 0.5)\n        }\n    }\n    \n    fn extract_features(&self, visit: &Visit) -> VisitFeatures {\n        VisitFeatures {\n            duration: visit.duration,\n            time_of_day: self.get_time_of_day(&visit.start_time),\n            day_of_week: self.get_day_of_week(&visit.start_time),\n            frequency: self.get_visit_frequency(&visit.centroid),\n            nearby_pois: self.get_nearby_pois(&visit.centroid),\n            movement_pattern: visit.dwell_analysis.movement_ratio,\n            home_confidence: self.calculate_home_confidence(visit),\n            work_confidence: self.calculate_work_confidence(visit),\n            shopping_confidence: self.calculate_shopping_confidence(visit),\n        }\n    }\n    \n    fn is_home_visit(&self, features: &VisitFeatures) -> bool {\n        // Long duration overnight visits\n        features.duration > Duration::from_hours(6) &&\n        (features.time_of_day == TimeOfDay::Evening || \n         features.time_of_day == TimeOfDay::Night || \n         features.time_of_day == TimeOfDay::Morning) &&\n        features.frequency > 0.7 // Visited regularly\n    }\n    \n    fn is_work_visit(&self, features: &VisitFeatures) -> bool {\n        // Weekday daytime visits\n        features.duration > Duration::from_hours(2) &&\n        features.time_of_day == TimeOfDay::Business &&\n        matches!(features.day_of_week, DayOfWeek::Monday..=DayOfWeek::Friday) &&\n        features.frequency > 0.5\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-clustering-algorithms",children:"Advanced Clustering Algorithms"}),"\n",(0,s.jsx)(n.h3,{id:"k-means-clustering",children:"K-Means Clustering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_location::clustering::kmeans::*;\n\nlet kmeans_config = KMeansConfig {\n    k: 5,                           // Expected number of significant locations\n    max_iterations: 100,\n    convergence_threshold: 1.0,     // Meters\n    initialization: InitMethod::KMeansPlusPlus,\n};\n\nlet kmeans = KMeansClusterer::new(kmeans_config);\nlet clusters = kmeans.cluster(&location_history)?;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"optics-clustering",children:"OPTICS Clustering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_location::clustering::optics::*;\n\n// OPTICS provides hierarchical density-based clustering\nlet optics_config = OPTICSConfig {\n    min_points: 3,\n    epsilon: 100.0,                 // Maximum search radius\n    xi: 0.05,                       // Steepness threshold for cluster extraction\n};\n\nlet optics = OPTICSClusterer::new(optics_config);\nlet hierarchy = optics.cluster(&locations)?;\n\n// Extract clusters at different density levels\nlet clusters_loose = hierarchy.extract_clusters(0.1)?;   // Loose clustering\nlet clusters_tight = hierarchy.extract_clusters(0.3)?;   // Tight clustering\n"})}),"\n",(0,s.jsx)(n.h3,{id:"hdbscan-clustering",children:"HDBSCAN Clustering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_location::clustering::hdbscan::*;\n\n// Hierarchical DBSCAN with automatic parameter selection\nlet hdbscan_config = HDBSCANConfig {\n    min_cluster_size: 5,\n    min_samples: 3,\n    cluster_selection_epsilon: 0.0, // Use all hierarchy levels\n    cluster_selection_method: ClusterSelection::EOM, // Excess of Mass\n};\n\nlet hdbscan = HDBSCANClusterer::new(hdbscan_config);\nlet result = hdbscan.cluster(&locations)?;\n\n// HDBSCAN provides stability scores for each cluster\nfor (cluster_id, stability) in result.cluster_stability {\n    println!("Cluster {} stability: {:.2}", cluster_id, stability);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"incremental-processing",children:"Incremental Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct IncrementalVisitDetector {\n    spatial_index: KDTree,          // Fast spatial queries\n    visit_cache: LRU<VisitId, Visit>,\n    recent_locations: CircularBuffer<LocationMeasurement>,\n}\n\nimpl IncrementalVisitDetector {\n    pub fn add_location(&mut self, location: LocationMeasurement) -> Result<Option<Visit>> {\n        // Use spatial index for fast nearby visit lookup\n        let nearby_visits = self.spatial_index.within_radius(\n            &location.centroid(), \n            self.config.max_distance\n        );\n        \n        if let Some(existing_visit_id) = nearby_visits.first() {\n            // Extend existing visit\n            self.extend_visit(*existing_visit_id, location)\n        } else {\n            // Check if we have enough points for new visit\n            let nearby_points = self.get_nearby_recent_locations(&location);\n            if nearby_points.len() >= self.config.min_points {\n                self.create_new_visit(nearby_points)\n            } else {\n                Ok(None)\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Configure memory usage for large datasets\nlet config = VisitConfig {\n    max_buffer_size: 1000,          // Keep last 1000 locations in memory\n    visit_cache_size: 100,          // Cache 100 most recent visits\n    clustering_batch_size: 500,     // Process locations in batches\n    use_spatial_index: true,        // Enable spatial indexing\n};\n\n// Periodic cleanup of old data\ndetector.cleanup_old_data(cutoff_time)?;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"real-time-visit-stream",children:"Real-Time Visit Stream"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use tokio_stream::StreamExt;\n\nasync fn process_location_stream() -> Result<()> {\n    let mut detector = VisitDetector::new(VisitConfig::default());\n    let mut location_stream = get_location_stream().await?;\n    \n    while let Some(location) = location_stream.next().await {\n        match detector.add_location(location?).await? {\n            Some(completed_visit) => {\n                println!("Visit completed: {:?}", completed_visit);\n                \n                // Store visit in blockchain\n                let visit_block = create_visit_block(completed_visit)?;\n                store_block(visit_block).await?;\n                \n                // Notify applications\n                send_visit_notification(&completed_visit).await?;\n            },\n            None => {\n                // Continue tracking\n            }\n        }\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"batch-visit-analysis",children:"Batch Visit Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"async fn analyze_historical_visits(\n    start_time: SystemTime,\n    end_time: SystemTime\n) -> Result<Vec<Visit>> {\n    \n    // Load historical location data\n    let locations = load_location_history(start_time, end_time).await?;\n    \n    // Configure for historical analysis (different parameters)\n    let config = VisitConfig {\n        min_dwell_time: Duration::from_mins(10),  // Longer minimum for historical\n        clustering_algorithm: ClusteringAlgorithm::HDBSCAN {\n            min_cluster_size: 8,    // More conservative for historical data\n            min_samples: 5,\n        },\n        ..Default::default()\n    };\n    \n    let detector = VisitDetector::new(config);\n    let visits = detector.detect_visits_batch(&locations)?;\n    \n    // Classify visits\n    let classifier = VisitClassifier::new();\n    let classified_visits: Vec<Visit> = visits\n        .into_iter()\n        .map(|mut visit| {\n            let (visit_type, confidence) = classifier.classify_visit(&visit);\n            visit.visit_type = visit_type;\n            visit.confidence = confidence;\n            visit\n        })\n        .collect();\n    \n    Ok(classified_visits)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"visit-analytics",children:"Visit Analytics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub struct VisitAnalytics {\n    pub total_visits: usize,\n    pub visit_types: HashMap<VisitType, usize>,\n    pub average_duration: Duration,\n    pub most_frequent_locations: Vec<(Coordinate, usize)>,\n    pub daily_patterns: HashMap<DayOfWeek, Vec<TimeRange>>,\n}\n\nimpl VisitAnalytics {\n    pub fn analyze_visits(visits: &[Visit]) -> Self {\n        let total_visits = visits.len();\n        \n        let mut visit_types = HashMap::new();\n        let mut total_duration = Duration::ZERO;\n        \n        for visit in visits {\n            *visit_types.entry(visit.visit_type.clone()).or_insert(0) += 1;\n            total_duration += visit.duration;\n        }\n        \n        let average_duration = if total_visits > 0 {\n            total_duration / total_visits as u32\n        } else {\n            Duration::ZERO\n        };\n        \n        // Additional analytics...\n        \n        Self {\n            total_visits,\n            visit_types,\n            average_duration,\n            most_frequent_locations: Self::find_frequent_locations(visits),\n            daily_patterns: Self::analyze_daily_patterns(visits),\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"testing--validation",children:"Testing & Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_home_visit_detection() {\n        let mut detector = VisitDetector::new(VisitConfig::default());\n        \n        // Simulate overnight stay at home\n        let home_location = create_test_location(37.7749, -122.4194);\n        let mut visits = Vec::new();\n        \n        // Add locations over 8 hours (evening to morning)\n        for hour in 20..=28 { // 8pm to 4am next day\n            let timestamp = base_time + Duration::from_hours(hour);\n            let location = create_location_with_time(home_location, timestamp);\n            \n            if let Ok(new_visits) = detector.add_location(location).await {\n                visits.extend(new_visits);\n            }\n        }\n        \n        // Should detect one home visit\n        assert_eq!(visits.len(), 1);\n        assert_eq!(visits[0].visit_type, VisitType::Home);\n        assert!(visits[0].duration >= Duration::from_hours(8));\n    }\n    \n    #[test]\n    fn test_dbscan_clustering() {\n        let locations = create_clustered_test_data();\n        \n        let dbscan = DBSCANClusterer::new(DBSCANConfig {\n            epsilon: 50.0,\n            min_points: 3,\n            distance_metric: DistanceMetric::Haversine,\n        });\n        \n        let clusters = dbscan.cluster(&locations).unwrap();\n        \n        // Verify expected cluster count\n        let core_clusters: Vec<_> = clusters.iter()\n            .filter(|c| matches!(c, Cluster::Core { .. }))\n            .collect();\n            \n        assert_eq!(core_clusters.len(), 2); // Two distinct visit locations\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"urban-environment",children:"Urban Environment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let urban_config = VisitConfig {\n    min_dwell_time: Duration::from_mins(3),     // Shorter for busy urban areas\n    max_distance: 25.0,                         // Smaller radius for precision\n    movement_threshold: 5.0,                    // Sensitive movement detection\n    clustering_algorithm: ClusteringAlgorithm::DBSCAN {\n        epsilon: 20.0,\n        min_points: 4,\n    },\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rural-environment",children:"Rural Environment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let rural_config = VisitConfig {\n    min_dwell_time: Duration::from_mins(10),    // Longer for sparse data\n    max_distance: 100.0,                        // Larger radius for GPS variance\n    movement_threshold: 15.0,                   // Less sensitive to noise\n    clustering_algorithm: ClusteringAlgorithm::DBSCAN {\n        epsilon: 75.0,\n        min_points: 2,\n    },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/location/tracking",children:"GPS Tracking"})," - Coordinate systems and accuracy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/location/clustering",children:"Clustering Algorithms"})," - Detailed clustering documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/extensions/location/privacy-obfuscation",children:"Privacy & Obfuscation"})," - Protecting visit privacy"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);