"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[8034],{3641:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/security/device-integrity","title":"Device Integrity","description":"The Integrity extension provides comprehensive device integrity verification and fraud detection capabilities using platform-specific attestation frameworks and behavioral analysis.","source":"@site/docs/extensions/security/device-integrity.md","sourceDirName":"extensions/security","slug":"/extensions/security/device-integrity","permalink":"/docs/extensions/security/device-integrity","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/security/device-integrity.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":2,"frontMatter":{"id":"device-integrity","title":"Device Integrity","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Trust Networks","permalink":"/docs/extensions/security/trust-networks"},"next":{"title":"HSM Integration","permalink":"/docs/extensions/security/hsm-integration"}}');var r=t(4848),a=t(8453);const s={id:"device-integrity",title:"Device Integrity",sidebar_position:2},o="Device Integrity",l={},c=[{value:"Overview",id:"overview",level:2},{value:"iOS App Attest",id:"ios-app-attest",level:2},{value:"App Attest Implementation",id:"app-attest-implementation",level:3},{value:"App Attest Challenge-Response",id:"app-attest-challenge-response",level:3},{value:"Android Play Integrity",id:"android-play-integrity",level:2},{value:"Play Integrity Implementation",id:"play-integrity-implementation",level:3},{value:"Play Integrity Token Request",id:"play-integrity-token-request",level:3},{value:"Fraud Detection",id:"fraud-detection",level:2},{value:"Device Fingerprinting",id:"device-fingerprinting",level:3},{value:"Behavioral Analysis",id:"behavioral-analysis",level:3},{value:"Velocity Checking",id:"velocity-checking",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Complete Integrity Verification Flow",id:"complete-integrity-verification-flow",level:3},{value:"Testing &amp; Validation",id:"testing--validation",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function _(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"device-integrity",children:"Device Integrity"})}),"\n",(0,r.jsx)(n.p,{children:"The Integrity extension provides comprehensive device integrity verification and fraud detection capabilities using platform-specific attestation frameworks and behavioral analysis."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The integrity extension verifies device trustworthiness through multiple mechanisms:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"iOS App Attest"}),": Hardware-backed attestation on iOS devices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Android Play Integrity"}),": Google Play Services integrity verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Attestation"}),": Hardware Security Module integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fraud Detection"}),": Behavioral analysis and anomaly detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Anti-Tampering"}),": Root/jailbreak detection and runtime protection"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_integrity::*;\n\n// Configure device integrity verification\nlet integrity_config = IntegrityConfig {\n    ios_app_attest: Some(AppAttestConfig {\n        team_id: "YOUR_TEAM_ID".to_string(),\n        key_id: "YOUR_KEY_ID".to_string(),\n        environment: AppAttestEnvironment::Production,\n    }),\n    android_play_integrity: Some(PlayIntegrityConfig {\n        cloud_project_number: 123456789,\n        package_name: "com.yourapp.package".to_string(),\n        environment: PlayIntegrityEnvironment::Production,\n    }),\n    fraud_detection: FraudDetectionConfig {\n        enabled_strategies: vec![\n            FraudDetectionStrategy::DeviceFingerprinting,\n            FraudDetectionStrategy::BehavioralAnalysis,\n            FraudDetectionStrategy::VelocityChecking,\n        ],\n        risk_threshold: 0.7,\n    },\n};\n\nlet integrity_verifier = DeviceIntegrityVerifier::new(integrity_config)?;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"ios-app-attest",children:"iOS App Attest"}),"\n",(0,r.jsx)(n.p,{children:"Apple's App Attest provides hardware-backed device integrity verification:"}),"\n",(0,r.jsx)(n.h3,{id:"app-attest-implementation",children:"App Attest Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_integrity::ios::*;\n\npub struct AppAttestVerifier {\n    team_id: String,\n    key_id: String,\n    environment: AppAttestEnvironment,\n    attestation_cache: LruCache<String, AttestationResult>,\n}\n\n#[derive(Debug, Clone)]\npub enum AppAttestEnvironment {\n    Development,\n    Production,\n}\n\nimpl AppAttestVerifier {\n    pub async fn verify_device(&self, device_id: &str) -> Result<IntegrityResult> {\n        // Step 1: Generate key pair on device (done on client)\n        // Step 2: Generate attestation object (done on client)\n        // Step 3: Verify attestation on server (this method)\n        \n        let attestation_data = self.get_attestation_from_device(device_id).await?;\n        \n        // Verify attestation object\n        let verification_result = self.verify_attestation_object(&attestation_data)?;\n        \n        // Check device integrity factors\n        let integrity_checks = self.perform_integrity_checks(&verification_result)?;\n        \n        let result = IntegrityResult {\n            device_id: device_id.to_string(),\n            platform: Platform::iOS,\n            attestation_valid: verification_result.is_valid,\n            integrity_level: self.calculate_integrity_level(&integrity_checks),\n            risk_factors: integrity_checks.risk_factors,\n            timestamp: SystemTime::now(),\n            expires_at: SystemTime::now() + Duration::from_hours(24),\n        };\n        \n        // Cache result\n        self.attestation_cache.insert(device_id.to_string(), result.clone());\n        \n        Ok(result)\n    }\n    \n    fn verify_attestation_object(&self, attestation: &AttestationObject) -> Result<VerificationResult> {\n        // Parse CBOR attestation object\n        let parsed = self.parse_attestation_object(attestation)?;\n        \n        // Verify certificate chain\n        self.verify_certificate_chain(&parsed.certificate_chain)?;\n        \n        // Verify attestation statement\n        self.verify_attestation_statement(&parsed.auth_data, &parsed.attestation_statement)?;\n        \n        // Check app ID and environment\n        self.verify_app_id(&parsed.auth_data)?;\n        \n        Ok(VerificationResult {\n            is_valid: true,\n            auth_data: parsed.auth_data,\n            credential_id: parsed.credential_id,\n            public_key: parsed.public_key,\n        })\n    }\n    \n    fn verify_certificate_chain(&self, chain: &[Certificate]) -> Result<()> {\n        // Verify certificate chain up to Apple Root CA\n        let apple_root_ca = self.get_apple_root_ca()?;\n        \n        // Check each certificate in chain\n        for (i, cert) in chain.iter().enumerate() {\n            if i == 0 {\n                // Leaf certificate - verify it\'s from Apple\n                self.verify_apple_leaf_certificate(cert)?;\n            } else {\n                // Intermediate certificates\n                self.verify_intermediate_certificate(cert, &chain[i-1])?;\n            }\n        }\n        \n        // Verify root\n        self.verify_root_certificate(chain.last().unwrap(), &apple_root_ca)?;\n        \n        Ok(())\n    }\n    \n    fn verify_app_id(&self, auth_data: &AuthenticatorData) -> Result<()> {\n        // Extract RP ID hash from auth data\n        let rp_id_hash = &auth_data.rp_id_hash;\n        \n        // Calculate expected RP ID hash for our app\n        let expected_app_id = format!("{}.{}", self.team_id, "YOUR_APP_BUNDLE_ID");\n        let expected_hash = sha256(expected_app_id.as_bytes());\n        \n        if rp_id_hash != &expected_hash {\n            return Err(IntegrityError::InvalidAppId {\n                expected: hex::encode(expected_hash),\n                received: hex::encode(rp_id_hash),\n            });\n        }\n        \n        Ok(())\n    }\n    \n    fn perform_integrity_checks(&self, verification: &VerificationResult) -> Result<IntegrityChecks> {\n        let mut risk_factors = Vec::new();\n        let mut integrity_score = 1.0;\n        \n        // Check for jailbreak indicators\n        if self.check_jailbreak_indicators(&verification.auth_data)? {\n            risk_factors.push(RiskFactor::JailbrokenDevice);\n            integrity_score *= 0.1; // Severe penalty\n        }\n        \n        // Check device model and OS version\n        let device_info = self.extract_device_info(&verification.auth_data)?;\n        if self.is_unsupported_device(&device_info) {\n            risk_factors.push(RiskFactor::UnsupportedDevice);\n            integrity_score *= 0.5;\n        }\n        \n        // Check for debugging/development signs\n        if self.check_development_environment(&verification.auth_data)? {\n            if matches!(self.environment, AppAttestEnvironment::Production) {\n                risk_factors.push(RiskFactor::DevelopmentEnvironment);\n                integrity_score *= 0.3;\n            }\n        }\n        \n        Ok(IntegrityChecks {\n            integrity_score,\n            risk_factors,\n            device_info,\n            checks_performed: vec![\n                "jailbreak_detection".to_string(),\n                "device_model_verification".to_string(),\n                "environment_validation".to_string(),\n            ],\n        })\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"app-attest-challenge-response",children:"App Attest Challenge-Response"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl AppAttestVerifier {\n    pub async fn create_challenge(&self, device_id: &str) -> Result<AttestationChallenge> {\n        let challenge_data = self.generate_random_challenge(32)?; // 32 random bytes\n        let challenge_id = Uuid::new_v4().to_string();\n        \n        let challenge = AttestationChallenge {\n            challenge_id,\n            challenge_data: challenge_data.clone(),\n            device_id: device_id.to_string(),\n            created_at: SystemTime::now(),\n            expires_at: SystemTime::now() + Duration::from_mins(5), // Short expiry\n        };\n        \n        // Store challenge for verification\n        self.store_challenge(&challenge).await?;\n        \n        Ok(challenge)\n    }\n    \n    pub async fn verify_challenge_response(\n        &self,\n        challenge_id: &str,\n        response: &AttestationResponse\n    ) -> Result<bool> {\n        let challenge = self.get_stored_challenge(challenge_id).await?\n            .ok_or(IntegrityError::ChallengeNotFound)?;\n            \n        // Check if challenge has expired\n        if SystemTime::now() > challenge.expires_at {\n            return Err(IntegrityError::ChallengeExpired);\n        }\n        \n        // Verify the response signature\n        let public_key = self.get_device_public_key(&challenge.device_id).await?;\n        let signature_valid = public_key.verify(\n            &challenge.challenge_data,\n            &response.signature\n        )?;\n        \n        if !signature_valid {\n            return Err(IntegrityError::InvalidSignature);\n        }\n        \n        // Clean up challenge\n        self.remove_challenge(challenge_id).await?;\n        \n        Ok(true)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"android-play-integrity",children:"Android Play Integrity"}),"\n",(0,r.jsx)(n.p,{children:"Google Play Integrity API provides app and device verification:"}),"\n",(0,r.jsx)(n.h3,{id:"play-integrity-implementation",children:"Play Integrity Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_integrity::android::*;\n\npub struct PlayIntegrityVerifier {\n    project_number: i64,\n    package_name: String,\n    service_account_key: ServiceAccountKey,\n    environment: PlayIntegrityEnvironment,\n}\n\n#[derive(Debug, Clone)]\npub enum PlayIntegrityEnvironment {\n    Development,\n    Production,\n}\n\nimpl PlayIntegrityVerifier {\n    pub async fn verify_device(&self, integrity_token: &str) -> Result<IntegrityResult> {\n        // Decrypt and verify the integrity token\n        let token_payload = self.decrypt_integrity_token(integrity_token).await?;\n        \n        // Extract integrity verdicts\n        let app_integrity = self.verify_app_integrity(&token_payload)?;\n        let device_integrity = self.verify_device_integrity(&token_payload)?;\n        let account_details = self.extract_account_details(&token_payload)?;\n        \n        // Assess overall integrity\n        let integrity_level = self.calculate_overall_integrity(\n            &app_integrity,\n            &device_integrity,\n            &account_details\n        )?;\n        \n        Ok(IntegrityResult {\n            device_id: token_payload.device_id,\n            platform: Platform::Android,\n            attestation_valid: true,\n            integrity_level,\n            risk_factors: self.identify_risk_factors(&token_payload),\n            timestamp: SystemTime::now(),\n            expires_at: SystemTime::now() + Duration::from_hours(24),\n        })\n    }\n    \n    async fn decrypt_integrity_token(&self, token: &str) -> Result<IntegrityTokenPayload> {\n        // The token is a JWS (JSON Web Signature)\n        let jws = JsonWebSignature::from_str(token)?;\n        \n        // Get Google\'s public keys for verification\n        let google_keys = self.fetch_google_public_keys().await?;\n        \n        // Verify signature\n        let key_id = jws.header().key_id()\n            .ok_or(IntegrityError::MissingKeyId)?;\n            \n        let public_key = google_keys.get(key_id)\n            .ok_or(IntegrityError::UnknownKeyId)?;\n            \n        if !jws.verify(public_key)? {\n            return Err(IntegrityError::InvalidSignature);\n        }\n        \n        // Parse payload\n        let payload: IntegrityTokenPayload = serde_json::from_slice(jws.payload())?;\n        \n        // Verify token is for our app\n        if payload.app_integrity.package_name != self.package_name {\n            return Err(IntegrityError::WrongPackageName {\n                expected: self.package_name.clone(),\n                received: payload.app_integrity.package_name,\n            });\n        }\n        \n        Ok(payload)\n    }\n    \n    fn verify_app_integrity(&self, payload: &IntegrityTokenPayload) -> Result<AppIntegrityAssessment> {\n        let app_integrity = &payload.app_integrity;\n        \n        let mut assessment = AppIntegrityAssessment {\n            app_recognition_verdict: app_integrity.app_recognition_verdict.clone(),\n            package_name_matches: app_integrity.package_name == self.package_name,\n            certificate_sha256_digest_matches: self.verify_certificate_digest(&app_integrity.certificate_sha256_digest)?,\n            version_code_matches: self.verify_version_code(app_integrity.version_code)?,\n            installed_from_play: app_integrity.app_recognition_verdict == AppRecognitionVerdict::PlayRecognized,\n        };\n        \n        Ok(assessment)\n    }\n    \n    fn verify_device_integrity(&self, payload: &IntegrityTokenPayload) -> Result<DeviceIntegrityAssessment> {\n        let device_integrity = &payload.device_integrity;\n        \n        let mut risk_score = 0.0;\n        let mut verdicts = Vec::new();\n        \n        // Check each verdict\n        for verdict in &device_integrity.device_recognition_verdict {\n            match verdict {\n                DeviceRecognitionVerdict::MeetsDeviceIntegrity => {\n                    verdicts.push("meets_basic_integrity".to_string());\n                },\n                DeviceRecognitionVerdict::MeetsStrongIntegrity => {\n                    verdicts.push("meets_strong_integrity".to_string());\n                },\n                DeviceRecognitionVerdict::MeetsVirtualIntegrity => {\n                    verdicts.push("virtual_device".to_string());\n                    risk_score += 0.3; // Emulators are riskier\n                },\n                DeviceRecognitionVerdict::Unknown => {\n                    verdicts.push("unknown".to_string());\n                    risk_score += 0.5; // Unknown devices are risky\n                }\n            }\n        }\n        \n        // Check for rooted device\n        if !device_integrity.device_recognition_verdict.contains(&DeviceRecognitionVerdict::MeetsDeviceIntegrity) {\n            risk_score += 0.6; // Likely rooted\n        }\n        \n        Ok(DeviceIntegrityAssessment {\n            verdicts,\n            risk_score,\n            meets_basic_integrity: device_integrity.device_recognition_verdict.contains(&DeviceRecognitionVerdict::MeetsDeviceIntegrity),\n            meets_strong_integrity: device_integrity.device_recognition_verdict.contains(&DeviceRecognitionVerdict::MeetsStrongIntegrity),\n            is_emulator: device_integrity.device_recognition_verdict.contains(&DeviceRecognitionVerdict::MeetsVirtualIntegrity),\n        })\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"play-integrity-token-request",children:"Play Integrity Token Request"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl PlayIntegrityVerifier {\n    pub async fn create_integrity_challenge(&self) -> Result<IntegrityChallenge> {\n        // Generate nonce for this verification request\n        let nonce = self.generate_nonce()?;\n        let challenge_id = Uuid::new_v4().to_string();\n        \n        let challenge = IntegrityChallenge {\n            challenge_id,\n            nonce: nonce.clone(),\n            cloud_project_number: self.project_number,\n            created_at: SystemTime::now(),\n            expires_at: SystemTime::now() + Duration::from_mins(10),\n        };\n        \n        // Store challenge for later verification\n        self.store_challenge(&challenge).await?;\n        \n        Ok(challenge)\n    }\n    \n    pub async fn verify_integrity_response(\n        &self,\n        challenge_id: &str,\n        integrity_token: &str\n    ) -> Result<IntegrityResult> {\n        // Get stored challenge\n        let challenge = self.get_stored_challenge(challenge_id).await?\n            .ok_or(IntegrityError::ChallengeNotFound)?;\n            \n        // Verify token\n        let token_payload = self.decrypt_integrity_token(integrity_token).await?;\n        \n        // Verify nonce matches\n        if token_payload.request_details.nonce != challenge.nonce {\n            return Err(IntegrityError::NonceMismatch);\n        }\n        \n        // Verify timestamp freshness\n        let token_time = SystemTime::UNIX_EPOCH + Duration::from_millis(token_payload.request_details.timestamp_millis);\n        let age = SystemTime::now().duration_since(token_time).unwrap_or_default();\n        \n        if age > Duration::from_mins(5) {\n            return Err(IntegrityError::StaleToken);\n        }\n        \n        // Perform full verification\n        let result = self.verify_device(integrity_token).await?;\n        \n        // Clean up challenge\n        self.remove_challenge(challenge_id).await?;\n        \n        Ok(result)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"fraud-detection",children:"Fraud Detection"}),"\n",(0,r.jsx)(n.p,{children:"Behavioral analysis and anomaly detection for fraud prevention:"}),"\n",(0,r.jsx)(n.h3,{id:"device-fingerprinting",children:"Device Fingerprinting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_integrity::fraud::*;\n\npub struct DeviceFingerprinter {\n    fingerprint_cache: LruCache<String, DeviceFingerprint>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DeviceFingerprint {\n    pub device_id: String,\n    pub hardware_fingerprint: HardwareFingerprint,\n    pub software_fingerprint: SoftwareFingerprint,\n    pub behavioral_fingerprint: BehavioralFingerprint,\n    pub network_fingerprint: NetworkFingerprint,\n    pub risk_score: f64,\n    pub created_at: SystemTime,\n    pub last_seen: SystemTime,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HardwareFingerprint {\n    pub device_model: String,\n    pub screen_resolution: String,\n    pub cpu_architecture: String,\n    pub memory_size: Option<u64>,\n    pub storage_size: Option<u64>,\n    pub sensors: Vec<String>,              // Available sensors\n    pub camera_info: Option<CameraInfo>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SoftwareFingerprint {\n    pub os_version: String,\n    pub app_version: String,\n    pub installed_apps: Vec<String>,       // App package names\n    pub system_settings: HashMap<String, String>,\n    pub fonts: Vec<String>,               // Available fonts\n    pub languages: Vec<String>,           // System languages\n}\n\nimpl DeviceFingerprinter {\n    pub fn generate_fingerprint(&self, device_info: &DeviceInfo) -> Result<DeviceFingerprint> {\n        let hardware_fp = self.generate_hardware_fingerprint(device_info)?;\n        let software_fp = self.generate_software_fingerprint(device_info)?;\n        let behavioral_fp = self.generate_behavioral_fingerprint(device_info)?;\n        let network_fp = self.generate_network_fingerprint(device_info)?;\n        \n        // Calculate composite risk score\n        let risk_score = self.calculate_risk_score(\n            &hardware_fp,\n            &software_fp,\n            &behavioral_fp,\n            &network_fp\n        );\n        \n        Ok(DeviceFingerprint {\n            device_id: device_info.device_id.clone(),\n            hardware_fingerprint: hardware_fp,\n            software_fingerprint: software_fp,\n            behavioral_fingerprint: behavioral_fp,\n            network_fingerprint: network_fp,\n            risk_score,\n            created_at: SystemTime::now(),\n            last_seen: SystemTime::now(),\n        })\n    }\n    \n    fn calculate_risk_score(\n        &self,\n        hardware: &HardwareFingerprint,\n        software: &SoftwareFingerprint,\n        behavioral: &BehavioralFingerprint,\n        network: &NetworkFingerprint\n    ) -> f64 {\n        let mut risk = 0.0;\n        \n        // Hardware risk factors\n        if hardware.device_model.contains("emulator") || hardware.device_model.contains("simulator") {\n            risk += 0.4; // Emulators are riskier\n        }\n        \n        if hardware.sensors.is_empty() {\n            risk += 0.2; // Missing sensors unusual for real devices\n        }\n        \n        // Software risk factors  \n        if software.installed_apps.iter().any(|app| app.contains("root") || app.contains("superuser")) {\n            risk += 0.5; // Root detection apps\n        }\n        \n        if software.installed_apps.len() < 10 {\n            risk += 0.1; // Too few apps for normal device\n        }\n        \n        // Behavioral risk factors\n        if behavioral.typing_speed > 200.0 {\n            risk += 0.3; // Unusually fast typing (bot behavior)\n        }\n        \n        if behavioral.click_precision > 0.95 {\n            risk += 0.2; // Too precise clicking\n        }\n        \n        // Network risk factors\n        if network.is_vpn {\n            risk += 0.1; // VPN usage slightly increases risk\n        }\n        \n        if network.is_tor {\n            risk += 0.3; // Tor usage significantly increases risk\n        }\n        \n        risk.min(1.0) // Cap at 1.0\n    }\n    \n    pub fn compare_fingerprints(&self, fp1: &DeviceFingerprint, fp2: &DeviceFingerprint) -> FingerprintSimilarity {\n        let hardware_sim = self.compare_hardware_fingerprints(&fp1.hardware_fingerprint, &fp2.hardware_fingerprint);\n        let software_sim = self.compare_software_fingerprints(&fp1.software_fingerprint, &fp2.software_fingerprint);\n        let behavioral_sim = self.compare_behavioral_fingerprints(&fp1.behavioral_fingerprint, &fp2.behavioral_fingerprint);\n        let network_sim = self.compare_network_fingerprints(&fp1.network_fingerprint, &fp2.network_fingerprint);\n        \n        let overall_similarity = (hardware_sim + software_sim + behavioral_sim + network_sim) / 4.0;\n        \n        FingerprintSimilarity {\n            overall_similarity,\n            hardware_similarity: hardware_sim,\n            software_similarity: software_sim,\n            behavioral_similarity: behavioral_sim,\n            network_similarity: network_sim,\n            is_likely_same_device: overall_similarity > 0.8,\n            is_suspicious_similarity: overall_similarity > 0.95 && fp1.device_id != fp2.device_id,\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"behavioral-analysis",children:"Behavioral Analysis"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct BehavioralAnalyzer {\n    user_patterns: HashMap<String, UserBehaviorProfile>,\n    anomaly_detector: AnomalyDetector,\n}\n\n#[derive(Debug, Clone)]\npub struct UserBehaviorProfile {\n    pub user_id: String,\n    pub typical_usage_patterns: UsagePatterns,\n    pub location_patterns: LocationPatterns,\n    pub temporal_patterns: TemporalPatterns,\n    pub interaction_patterns: InteractionPatterns,\n    pub baseline_established: bool,\n    pub last_updated: SystemTime,\n}\n\n#[derive(Debug, Clone)]\npub struct UsagePatterns {\n    pub session_durations: StatisticalDistribution,\n    pub actions_per_session: StatisticalDistribution,\n    pub navigation_patterns: Vec<String>,      // Common navigation paths\n    pub feature_usage: HashMap<String, f64>,  // Feature -> usage frequency\n}\n\nimpl BehavioralAnalyzer {\n    pub fn analyze_behavior(&mut self, user_id: &str, session: &UserSession) -> BehavioralAnalysis {\n        let profile = self.user_patterns.entry(user_id.to_string())\n            .or_insert_with(|| UserBehaviorProfile::new(user_id));\n            \n        if !profile.baseline_established {\n            // Still building baseline - collect data\n            profile.update_with_session(session);\n            \n            if profile.has_sufficient_data() {\n                profile.baseline_established = true;\n            }\n            \n            return BehavioralAnalysis {\n                risk_score: 0.1, // Low risk during baseline\n                anomalies: vec![],\n                confidence: 0.3,  // Low confidence without baseline\n                recommendation: "Building behavioral baseline".to_string(),\n            };\n        }\n        \n        // Analyze against established baseline\n        let anomalies = self.detect_anomalies(profile, session);\n        let risk_score = self.calculate_behavioral_risk(&anomalies);\n        \n        // Update profile with new data\n        profile.update_with_session(session);\n        \n        BehavioralAnalysis {\n            risk_score,\n            anomalies,\n            confidence: 0.8, // High confidence with established baseline\n            recommendation: self.generate_recommendation(risk_score, &anomalies),\n        }\n    }\n    \n    fn detect_anomalies(&self, profile: &UserBehaviorProfile, session: &UserSession) -> Vec<BehavioralAnomaly> {\n        let mut anomalies = Vec::new();\n        \n        // Session duration anomaly\n        let duration_zscore = profile.typical_usage_patterns.session_durations\n            .z_score(session.duration.as_secs() as f64);\n        if duration_zscore.abs() > 3.0 {\n            anomalies.push(BehavioralAnomaly {\n                anomaly_type: AnomalyType::UnusualSessionDuration,\n                severity: if duration_zscore.abs() > 4.0 { AnomalySeverity::High } else { AnomalySeverity::Medium },\n                description: format!("Session duration {} standard deviations from normal", duration_zscore.abs()),\n                confidence: self.zscore_to_confidence(duration_zscore.abs()),\n            });\n        }\n        \n        // Location anomaly\n        if let Some(location) = &session.location {\n            if let Some(usual_location) = profile.location_patterns.most_common_location() {\n                let distance = location.distance_to(&usual_location);\n                if distance > profile.location_patterns.typical_radius * 3.0 {\n                    anomalies.push(BehavioralAnomaly {\n                        anomaly_type: AnomalyType::UnusualLocation,\n                        severity: AnomalySeverity::Medium,\n                        description: format!("Location {} km from typical area", distance / 1000.0),\n                        confidence: 0.7,\n                    });\n                }\n            }\n        }\n        \n        // Temporal pattern anomaly\n        let session_hour = session.start_time.hour();\n        if !profile.temporal_patterns.is_typical_hour(session_hour) {\n            anomalies.push(BehavioralAnomaly {\n                anomaly_type: AnomalyType::UnusualTime,\n                severity: AnomalySeverity::Low,\n                description: format!("Activity at unusual hour: {}", session_hour),\n                confidence: 0.6,\n            });\n        }\n        \n        // Interaction pattern anomalies\n        let typing_speed = session.calculate_average_typing_speed();\n        let baseline_typing = profile.interaction_patterns.average_typing_speed;\n        \n        if (typing_speed - baseline_typing).abs() > baseline_typing * 0.5 {\n            anomalies.push(BehavioralAnomaly {\n                anomaly_type: AnomalyType::UnusualTypingSpeed,\n                severity: AnomalySeverity::Medium,\n                description: format!("Typing speed deviation: {} vs {} WPM", typing_speed, baseline_typing),\n                confidence: 0.7,\n            });\n        }\n        \n        anomalies\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"velocity-checking",children:"Velocity Checking"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct VelocityChecker {\n    action_history: HashMap<String, VecDeque<ActionRecord>>,\n    velocity_limits: VelocityLimits,\n}\n\n#[derive(Debug, Clone)]\npub struct VelocityLimits {\n    pub max_requests_per_minute: u32,\n    pub max_requests_per_hour: u32,\n    pub max_requests_per_day: u32,\n    pub max_failed_attempts_per_hour: u32,\n    pub suspicious_velocity_threshold: f64,\n}\n\nimpl VelocityChecker {\n    pub fn check_velocity(&mut self, user_id: &str, action: &UserAction) -> VelocityCheckResult {\n        let now = SystemTime::now();\n        \n        // Get or create action history for user\n        let history = self.action_history.entry(user_id.to_string())\n            .or_insert_with(VecDeque::new);\n            \n        // Clean old entries\n        self.clean_old_entries(history, now);\n        \n        // Add current action\n        history.push_back(ActionRecord {\n            action_type: action.action_type.clone(),\n            timestamp: now,\n            success: action.success,\n            metadata: action.metadata.clone(),\n        });\n        \n        // Check velocity limits\n        let velocity_stats = self.calculate_velocity_stats(history, now);\n        let violations = self.check_velocity_violations(&velocity_stats);\n        \n        VelocityCheckResult {\n            allowed: violations.is_empty(),\n            violations,\n            velocity_stats,\n            risk_score: self.calculate_velocity_risk(&velocity_stats),\n        }\n    }\n    \n    fn calculate_velocity_stats(&self, history: &VecDeque<ActionRecord>, now: SystemTime) -> VelocityStats {\n        let one_minute_ago = now - Duration::from_secs(60);\n        let one_hour_ago = now - Duration::from_secs(3600);\n        let one_day_ago = now - Duration::from_secs(86400);\n        \n        let mut stats = VelocityStats::default();\n        \n        for record in history {\n            if record.timestamp >= one_minute_ago {\n                stats.requests_last_minute += 1;\n                if !record.success {\n                    stats.failed_requests_last_minute += 1;\n                }\n            }\n            \n            if record.timestamp >= one_hour_ago {\n                stats.requests_last_hour += 1;\n                if !record.success {\n                    stats.failed_requests_last_hour += 1;\n                }\n            }\n            \n            if record.timestamp >= one_day_ago {\n                stats.requests_last_day += 1;\n                if !record.success {\n                    stats.failed_requests_last_day += 1;\n                }\n            }\n        }\n        \n        // Calculate velocity (requests per second over different windows)\n        stats.velocity_per_second_1min = stats.requests_last_minute as f64 / 60.0;\n        stats.velocity_per_second_1hour = stats.requests_last_hour as f64 / 3600.0;\n        \n        stats\n    }\n    \n    fn check_velocity_violations(&self, stats: &VelocityStats) -> Vec<VelocityViolation> {\n        let mut violations = Vec::new();\n        \n        if stats.requests_last_minute > self.velocity_limits.max_requests_per_minute {\n            violations.push(VelocityViolation {\n                violation_type: VelocityViolationType::ExcessiveRequestsPerMinute,\n                limit: self.velocity_limits.max_requests_per_minute as f64,\n                actual: stats.requests_last_minute as f64,\n                severity: ViolationSeverity::High,\n            });\n        }\n        \n        if stats.requests_last_hour > self.velocity_limits.max_requests_per_hour {\n            violations.push(VelocityViolation {\n                violation_type: VelocityViolationType::ExcessiveRequestsPerHour,\n                limit: self.velocity_limits.max_requests_per_hour as f64,\n                actual: stats.requests_last_hour as f64,\n                severity: ViolationSeverity::Medium,\n            });\n        }\n        \n        if stats.failed_requests_last_hour > self.velocity_limits.max_failed_attempts_per_hour {\n            violations.push(VelocityViolation {\n                violation_type: VelocityViolationType::ExcessiveFailedAttempts,\n                limit: self.velocity_limits.max_failed_attempts_per_hour as f64,\n                actual: stats.failed_requests_last_hour as f64,\n                severity: ViolationSeverity::High,\n            });\n        }\n        \n        violations\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"complete-integrity-verification-flow",children:"Complete Integrity Verification Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_integrity::*;\n\npub struct IntegrityManager {\n    ios_verifier: Option<AppAttestVerifier>,\n    android_verifier: Option<PlayIntegrityVerifier>,\n    fraud_detector: FraudDetectionEngine,\n    verification_cache: LruCache<String, IntegrityResult>,\n}\n\nimpl IntegrityManager {\n    pub async fn verify_device_integrity(\n        &mut self,\n        request: &IntegrityVerificationRequest\n    ) -> Result<IntegrityVerificationResponse> {\n        \n        // Check cache first\n        if let Some(cached_result) = self.verification_cache.get(&request.device_id) {\n            if !self.is_result_expired(cached_result) {\n                return Ok(IntegrityVerificationResponse::from_result(cached_result.clone()));\n            }\n        }\n        \n        // Perform platform-specific verification\n        let platform_result = match request.platform {\n            Platform::iOS => {\n                if let Some(ref verifier) = self.ios_verifier {\n                    verifier.verify_device(&request.device_id).await?\n                } else {\n                    return Err(IntegrityError::PlatformNotSupported(Platform::iOS));\n                }\n            },\n            Platform::Android => {\n                if let Some(ref verifier) = self.android_verifier {\n                    verifier.verify_device(&request.integrity_token).await?\n                } else {\n                    return Err(IntegrityError::PlatformNotSupported(Platform::Android));\n                }\n            },\n            Platform::Web => {\n                // Web-based verification (WebAuthn, etc.)\n                self.verify_web_device(&request).await?\n            }\n        };\n        \n        // Perform fraud detection\n        let fraud_result = self.fraud_detector.analyze_device(&request.device_info).await?;\n        \n        // Combine results\n        let combined_result = self.combine_verification_results(\n            platform_result,\n            fraud_result\n        )?;\n        \n        // Cache result\n        self.verification_cache.insert(\n            request.device_id.clone(),\n            combined_result.clone()\n        );\n        \n        // Create response with recommendations\n        let response = IntegrityVerificationResponse {\n            device_id: request.device_id.clone(),\n            verification_successful: combined_result.integrity_level >= IntegrityLevel::Medium,\n            integrity_level: combined_result.integrity_level,\n            risk_factors: combined_result.risk_factors,\n            recommendations: self.generate_recommendations(&combined_result),\n            expires_at: combined_result.expires_at,\n            metadata: self.create_verification_metadata(&request, &combined_result),\n        };\n        \n        Ok(response)\n    }\n    \n    fn combine_verification_results(\n        &self,\n        platform: IntegrityResult,\n        fraud: FraudAnalysisResult\n    ) -> Result<IntegrityResult> {\n        \n        let mut combined_risk_factors = platform.risk_factors;\n        combined_risk_factors.extend(fraud.risk_factors);\n        \n        // Calculate combined integrity level\n        let platform_score = match platform.integrity_level {\n            IntegrityLevel::High => 0.9,\n            IntegrityLevel::Medium => 0.7,\n            IntegrityLevel::Low => 0.4,\n            IntegrityLevel::Critical => 0.1,\n        };\n        \n        let fraud_penalty = fraud.risk_score;\n        let combined_score = platform_score * (1.0 - fraud_penalty);\n        \n        let combined_level = match combined_score {\n            s if s >= 0.8 => IntegrityLevel::High,\n            s if s >= 0.6 => IntegrityLevel::Medium,\n            s if s >= 0.3 => IntegrityLevel::Low,\n            _ => IntegrityLevel::Critical,\n        };\n        \n        Ok(IntegrityResult {\n            device_id: platform.device_id,\n            platform: platform.platform,\n            attestation_valid: platform.attestation_valid,\n            integrity_level: combined_level,\n            risk_factors: combined_risk_factors,\n            timestamp: SystemTime::now(),\n            expires_at: platform.expires_at,\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing--validation",children:"Testing & Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod integrity_tests {\n    use super::*;\n    \n    #[test]\n    fn test_device_fingerprint_similarity() {\n        let fingerprinter = DeviceFingerprinter::new();\n        \n        // Create two similar device fingerprints\n        let device1 = create_test_device_info("iPhone13,4", "iOS 15.0");\n        let device2 = create_test_device_info("iPhone13,4", "iOS 15.1"); // Same device, different OS\n        \n        let fp1 = fingerprinter.generate_fingerprint(&device1).unwrap();\n        let fp2 = fingerprinter.generate_fingerprint(&device2).unwrap();\n        \n        let similarity = fingerprinter.compare_fingerprints(&fp1, &fp2);\n        \n        assert!(similarity.is_likely_same_device);\n        assert!(!similarity.is_suspicious_similarity); // Same device ID\n        assert!(similarity.overall_similarity > 0.8);\n    }\n    \n    #[tokio::test]\n    async fn test_velocity_checking() {\n        let mut checker = VelocityChecker::new(VelocityLimits {\n            max_requests_per_minute: 10,\n            max_requests_per_hour: 100,\n            max_requests_per_day: 1000,\n            max_failed_attempts_per_hour: 5,\n            suspicious_velocity_threshold: 0.5,\n        });\n        \n        let user_id = "test_user";\n        \n        // Send normal requests\n        for _ in 0..5 {\n            let action = UserAction {\n                action_type: "login".to_string(),\n                success: true,\n                metadata: HashMap::new(),\n            };\n            \n            let result = checker.check_velocity(user_id, &action);\n            assert!(result.allowed);\n        }\n        \n        // Send excessive requests\n        for _ in 0..20 {\n            let action = UserAction {\n                action_type: "api_call".to_string(),\n                success: true,\n                metadata: HashMap::new(),\n            };\n            \n            let result = checker.check_velocity(user_id, &action);\n            // Should be blocked after exceeding limit\n        }\n        \n        let final_check = checker.check_velocity(user_id, &UserAction {\n            action_type: "test".to_string(),\n            success: true,\n            metadata: HashMap::new(),\n        });\n        \n        assert!(!final_check.allowed);\n        assert!(!final_check.violations.is_empty());\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/trust-networks",children:"Trust Networks"})," - Device trust integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/hsm-integration",children:"HSM Integration"})," - Hardware attestation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/keystore",children:"Keystore"})," - Secure key management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/extensions/privacy/",children:"Privacy Extension"})," - Privacy-preserving attestation"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);