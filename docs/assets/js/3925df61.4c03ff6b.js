"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[8309],{4010:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"extensions/security/trust-networks","title":"Trust Networks","description":"The Trust extension (v2.0) provides comprehensive trust establishment, peer connections, and reputation management for decentralized networks. It unifies trust protocols, attestations, and peer relationship management.","source":"@site/docs/extensions/security/trust-networks.md","sourceDirName":"extensions/security","slug":"/extensions/security/trust-networks","permalink":"/docs/extensions/security/trust-networks","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/security/trust-networks.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":1,"frontMatter":{"id":"trust-networks","title":"Trust Networks","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Privacy & Obfuscation","permalink":"/docs/extensions/location/privacy-obfuscation"},"next":{"title":"Device Integrity","permalink":"/docs/extensions/security/device-integrity"}}');var r=t(4848),s=t(8453);const o={id:"trust-networks",title:"Trust Networks",sidebar_position:1},a="Trust Networks",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Decentralized Identifiers (DIDs)",id:"decentralized-identifiers-dids",level:2},{value:"DID Structure",id:"did-structure",level:3},{value:"DID Document Management",id:"did-document-management",level:3},{value:"Trust Credentials",id:"trust-credentials",level:2},{value:"Credential Structure",id:"credential-structure",level:3},{value:"Credential Issuance",id:"credential-issuance",level:3},{value:"Reputation Algorithms",id:"reputation-algorithms",level:2},{value:"EigenTrust Implementation",id:"eigentrust-implementation",level:3},{value:"PageRank Reputation",id:"pagerank-reputation",level:3},{value:"Bayesian Trust",id:"bayesian-trust",level:3},{value:"Spatial-Temporal Attestations",id:"spatial-temporal-attestations",level:2},{value:"Attestation Types",id:"attestation-types",level:3},{value:"Attestation Protocol",id:"attestation-protocol",level:3},{value:"Trust Network Management",id:"trust-network-management",level:2},{value:"Peer Connection Management",id:"peer-connection-management",level:3},{value:"Trust Propagation",id:"trust-propagation",level:3},{value:"Integration Examples",id:"integration-examples",level:2},{value:"Trust-Based Access Control",id:"trust-based-access-control",level:3},{value:"Testing &amp; Performance",id:"testing--performance",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"trust-networks",children:"Trust Networks"})}),"\n",(0,r.jsx)(n.p,{children:"The Trust extension (v2.0) provides comprehensive trust establishment, peer connections, and reputation management for decentralized networks. It unifies trust protocols, attestations, and peer relationship management."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The unified trust extension combines multiple trust mechanisms:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DIDs"}),": Decentralized identifiers for peer identity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trust Credentials"}),": Verifiable trust assertions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reputation Algorithms"}),": PageRank, EigenTrust, Bayesian inference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Attestations"}),": Spatial-temporal proofs and claims"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Peer Connections"}),": Network relationship management"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::*;\nuse olocus_core::measure::*;\n\n// Create trust network\nlet trust_config = TrustNetworkConfig {\n    reputation_algorithm: ReputationAlgorithm::EigenTrust {\n        alpha: 0.5,           // Pre-trust weight\n        epsilon: 0.01,        // Convergence threshold\n        max_iterations: 100,\n    },\n    attestation_config: AttestationConfig {\n        spatial_radius: 100.0,     // 100m spatial verification\n        temporal_window: Duration::from_secs(300), // 5 min temporal window\n        required_witnesses: 3,      // Minimum witnesses\n    },\n    connection_config: ConnectionConfig {\n        max_connections: 150,       // Dunbar's number\n        trust_threshold: 0.7,       // Minimum trust for connection\n        attestation_required: true,\n    },\n};\n\nlet trust_network = TrustNetwork::new(trust_config);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"decentralized-identifiers-dids",children:"Decentralized Identifiers (DIDs)"}),"\n",(0,r.jsx)(n.p,{children:"DIDs provide cryptographically verifiable, self-sovereign identities:"}),"\n",(0,r.jsx)(n.h3,{id:"did-structure",children:"DID Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_trust::identity::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Did {\n    pub method: String,           // "olocus"\n    pub method_specific_id: String, // Base58-encoded public key\n}\n\nimpl Did {\n    pub fn new(public_key: &PublicKey) -> Self {\n        let encoded_key = bs58::encode(&public_key.as_bytes()).into_string();\n        Self {\n            method: "olocus".to_string(),\n            method_specific_id: encoded_key,\n        }\n    }\n    \n    pub fn to_string(&self) -> String {\n        format!("did:{}:{}", self.method, self.method_specific_id)\n    }\n    \n    pub fn from_string(did_string: &str) -> Result<Self, DidError> {\n        let parts: Vec<&str> = did_string.split(\':\').collect();\n        if parts.len() != 3 || parts[0] != "did" {\n            return Err(DidError::InvalidFormat);\n        }\n        \n        Ok(Self {\n            method: parts[1].to_string(),\n            method_specific_id: parts[2].to_string(),\n        })\n    }\n    \n    pub fn resolve(&self) -> Result<DidDocument, DidError> {\n        // Resolve DID to DID Document\n        let public_key_bytes = bs58::decode(&self.method_specific_id)\n            .into_vec()\n            .map_err(|_| DidError::InvalidEncoding)?;\n            \n        let public_key = PublicKey::from_bytes(&public_key_bytes)?;\n        \n        Ok(DidDocument {\n            did: self.clone(),\n            public_keys: vec![DidPublicKey {\n                id: format!("{}#key-1", self.to_string()),\n                key_type: KeyType::Ed25519VerificationKey2020,\n                public_key,\n            }],\n            authentication: vec![format!("{}#key-1", self.to_string())],\n            created: SystemTime::now(),\n            updated: SystemTime::now(),\n        })\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"did-document-management",children:"DID Document Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, Clone)]\npub struct DidDocument {\n    pub did: Did,\n    pub public_keys: Vec<DidPublicKey>,\n    pub authentication: Vec<String>,     // Key IDs for authentication\n    pub service_endpoints: Vec<ServiceEndpoint>,\n    pub created: SystemTime,\n    pub updated: SystemTime,\n}\n\n#[derive(Debug, Clone)]\npub struct DidPublicKey {\n    pub id: String,                      // Key identifier\n    pub key_type: KeyType,\n    pub public_key: PublicKey,\n}\n\n#[derive(Debug, Clone)]\npub struct ServiceEndpoint {\n    pub id: String,\n    pub service_type: String,            // "TrustNetwork", "Messaging", etc.\n    pub endpoint: String,                // URL or address\n}\n\nimpl DidDocument {\n    pub fn add_service_endpoint(&mut self, endpoint: ServiceEndpoint) {\n        self.service_endpoints.push(endpoint);\n        self.updated = SystemTime::now();\n    }\n    \n    pub fn rotate_key(&mut self, old_key_id: &str, new_key: DidPublicKey) -> Result<()> {\n        // Remove old key\n        self.public_keys.retain(|k| k.id != old_key_id);\n        \n        // Add new key\n        self.public_keys.push(new_key.clone());\n        \n        // Update authentication if needed\n        if let Some(pos) = self.authentication.iter().position(|id| id == old_key_id) {\n            self.authentication[pos] = new_key.id;\n        }\n        \n        self.updated = SystemTime::now();\n        Ok(())\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"trust-credentials",children:"Trust Credentials"}),"\n",(0,r.jsx)(n.p,{children:"Trust credentials are verifiable claims about trust relationships:"}),"\n",(0,r.jsx)(n.h3,{id:"credential-structure",children:"Credential Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_trust::credentials::*;\n\n#[derive(Debug, Clone)]\npub struct TrustCredential {\n    pub id: CredentialId,\n    pub issuer: Did,                     // Who issued the credential\n    pub subject: Did,                    // Who the credential is about\n    pub claim: TrustClaim,              // The trust assertion\n    pub evidence: Vec<Evidence>,         // Supporting evidence\n    pub valid_from: SystemTime,\n    pub valid_until: Option<SystemTime>,\n    pub proof: CredentialProof,          // Cryptographic proof\n}\n\n#[derive(Debug, Clone)]\npub enum TrustClaim {\n    DirectTrust {\n        score: f64,                      // Trust score [0.0, 1.0]\n        confidence: f64,                 // Confidence in assessment\n        context: TrustContext,           // Context of trust\n    },\n    Recommendation {\n        recommends: Did,                 // Recommended party\n        score: f64,                      // Recommendation strength\n        reason: String,                  // Human-readable reason\n    },\n    Attestation {\n        claim_type: AttestationType,     // What is being attested\n        claim_value: serde_json::Value,  // The claim content\n        spatial_proof: Option<SpatialProof>,\n        temporal_proof: Option<TemporalProof>,\n    },\n    Reputation {\n        domain: String,                  // Reputation domain (e.g., "file-sharing")\n        score: f64,                      // Normalized reputation score\n        interactions: u32,               // Number of interactions\n        last_updated: SystemTime,\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum TrustContext {\n    General,                             // General-purpose trust\n    Financial,                           // Financial transactions\n    DataSharing,                         // Data sharing context\n    LocationSharing,                     // Location sharing\n    Communication,                       // Messaging/communication\n    Emergency,                           // Emergency situations\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"credential-issuance",children:"Credential Issuance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'impl TrustCredentialIssuer {\n    pub fn issue_trust_credential(\n        &self,\n        issuer_private_key: &PrivateKey,\n        subject: Did,\n        claim: TrustClaim,\n        evidence: Vec<Evidence>\n    ) -> Result<TrustCredential> {\n        let credential_id = CredentialId::generate();\n        let issuer_did = Did::new(&issuer_private_key.public_key());\n        \n        let credential = TrustCredential {\n            id: credential_id,\n            issuer: issuer_did,\n            subject,\n            claim,\n            evidence,\n            valid_from: SystemTime::now(),\n            valid_until: None,\n            proof: CredentialProof::Placeholder, // Will be filled by signing\n        };\n        \n        // Create cryptographic proof\n        let proof = self.create_proof(&credential, issuer_private_key)?;\n        \n        Ok(TrustCredential {\n            proof,\n            ..credential\n        })\n    }\n    \n    fn create_proof(&self, credential: &TrustCredential, private_key: &PrivateKey) -> Result<CredentialProof> {\n        // Serialize credential without proof for signing\n        let mut credential_for_signing = credential.clone();\n        credential_for_signing.proof = CredentialProof::Placeholder;\n        \n        let serialized = serde_json::to_vec(&credential_for_signing)?;\n        let signature = private_key.sign(&serialized)?;\n        \n        Ok(CredentialProof::Ed25519Signature2020 {\n            created: SystemTime::now(),\n            verification_method: format!("{}#key-1", credential.issuer.to_string()),\n            signature: signature.as_bytes().to_vec(),\n        })\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"reputation-algorithms",children:"Reputation Algorithms"}),"\n",(0,r.jsx)(n.p,{children:"Multiple reputation algorithms for different network characteristics:"}),"\n",(0,r.jsx)(n.h3,{id:"eigentrust-implementation",children:"EigenTrust Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::reputation::eigentrust::*;\n\npub struct EigenTrustAlgorithm {\n    alpha: f64,                          // Pre-trust weight\n    epsilon: f64,                        // Convergence threshold\n    max_iterations: usize,\n}\n\nimpl ReputationAlgorithm for EigenTrustAlgorithm {\n    fn calculate_reputation(&self, network: &TrustNetwork) -> Result<ReputationScores> {\n        let peers: Vec<Did> = network.get_all_peers();\n        let n = peers.len();\n        \n        if n == 0 {\n            return Ok(ReputationScores::empty());\n        }\n        \n        // Build normalized trust matrix\n        let trust_matrix = self.build_trust_matrix(network, &peers)?;\n        \n        // Initialize reputation vector with uniform distribution\n        let mut reputation = vec![1.0 / n as f64; n];\n        let pre_trust = vec![1.0 / n as f64; n]; // Uniform pre-trust\n        \n        // Iterative computation\n        for iteration in 0..self.max_iterations {\n            let prev_reputation = reputation.clone();\n            \n            // r = (1 - \u03b1) * C^T * r + \u03b1 * p\n            reputation = self.matrix_vector_multiply(&trust_matrix, &prev_reputation);\n            \n            for i in 0..n {\n                reputation[i] = (1.0 - self.alpha) * reputation[i] + self.alpha * pre_trust[i];\n            }\n            \n            // Check convergence\n            let diff: f64 = reputation.iter()\n                .zip(prev_reputation.iter())\n                .map(|(new, old)| (new - old).abs())\n                .sum();\n                \n            if diff < self.epsilon {\n                break;\n            }\n        }\n        \n        // Convert to reputation scores\n        let mut scores = ReputationScores::new();\n        for (i, &score) in reputation.iter().enumerate() {\n            scores.insert(peers[i].clone(), score);\n        }\n        \n        Ok(scores)\n    }\n    \n    fn build_trust_matrix(&self, network: &TrustNetwork, peers: &[Did]) -> Result<Vec<Vec<f64>>> {\n        let n = peers.len();\n        let mut matrix = vec![vec![0.0; n]; n];\n        \n        for (i, trustor) in peers.iter().enumerate() {\n            let mut row_sum = 0.0;\n            \n            // Get trust values for this peer\n            for (j, trustee) in peers.iter().enumerate() {\n                if i != j {\n                    let trust_value = network.get_direct_trust(trustor, trustee)\n                        .unwrap_or(0.0);\n                    matrix[i][j] = trust_value.max(0.0); // Ensure non-negative\n                    row_sum += matrix[i][j];\n                }\n            }\n            \n            // Normalize row (make stochastic)\n            if row_sum > 0.0 {\n                for j in 0..n {\n                    matrix[i][j] /= row_sum;\n                }\n            } else {\n                // No outgoing trust - distribute uniformly\n                for j in 0..n {\n                    if i != j {\n                        matrix[i][j] = 1.0 / (n - 1) as f64;\n                    }\n                }\n            }\n        }\n        \n        Ok(matrix)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pagerank-reputation",children:"PageRank Reputation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::reputation::pagerank::*;\n\npub struct PageRankReputation {\n    damping_factor: f64,                 // Usually 0.85\n    epsilon: f64,\n    max_iterations: usize,\n}\n\nimpl ReputationAlgorithm for PageRankReputation {\n    fn calculate_reputation(&self, network: &TrustNetwork) -> Result<ReputationScores> {\n        let peers: Vec<Did> = network.get_all_peers();\n        let n = peers.len();\n        \n        if n == 0 {\n            return Ok(ReputationScores::empty());\n        }\n        \n        // Build adjacency matrix from trust relationships\n        let adjacency = self.build_adjacency_matrix(network, &peers)?;\n        \n        // Calculate out-degrees\n        let out_degrees: Vec<f64> = adjacency.iter()\n            .map(|row| row.iter().sum::<f64>())\n            .collect();\n            \n        // Initialize PageRank scores\n        let mut pagerank = vec![1.0 / n as f64; n];\n        \n        for iteration in 0..self.max_iterations {\n            let prev_pagerank = pagerank.clone();\n            \n            for i in 0..n {\n                let mut sum = 0.0;\n                \n                for j in 0..n {\n                    if adjacency[j][i] > 0.0 && out_degrees[j] > 0.0 {\n                        sum += adjacency[j][i] * prev_pagerank[j] / out_degrees[j];\n                    }\n                }\n                \n                pagerank[i] = (1.0 - self.damping_factor) / n as f64 + \n                              self.damping_factor * sum;\n            }\n            \n            // Check convergence\n            let diff: f64 = pagerank.iter()\n                .zip(prev_pagerank.iter())\n                .map(|(new, old)| (new - old).abs())\n                .sum();\n                \n            if diff < self.epsilon {\n                break;\n            }\n        }\n        \n        let mut scores = ReputationScores::new();\n        for (i, &score) in pagerank.iter().enumerate() {\n            scores.insert(peers[i].clone(), score);\n        }\n        \n        Ok(scores)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bayesian-trust",children:"Bayesian Trust"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::reputation::bayesian::*;\n\npub struct BayesianTrust {\n    prior_alpha: f64,                    // Prior successful interactions\n    prior_beta: f64,                     // Prior failed interactions\n}\n\nimpl ReputationAlgorithm for BayesianTrust {\n    fn calculate_reputation(&self, network: &TrustNetwork) -> Result<ReputationScores> {\n        let mut scores = ReputationScores::new();\n        \n        for peer in network.get_all_peers() {\n            let interactions = network.get_interaction_history(&peer)?;\n            \n            // Count positive and negative interactions\n            let (positive, negative) = self.count_interactions(&interactions);\n            \n            // Update Beta distribution parameters\n            let alpha = self.prior_alpha + positive as f64;\n            let beta = self.prior_beta + negative as f64;\n            \n            // Expected value of Beta distribution\n            let reputation = alpha / (alpha + beta);\n            \n            // Optionally weight by confidence (higher for more interactions)\n            let confidence = self.calculate_confidence(alpha, beta);\n            let weighted_reputation = reputation * confidence.sqrt();\n            \n            scores.insert(peer, weighted_reputation);\n        }\n        \n        Ok(scores)\n    }\n    \n    fn count_interactions(&self, interactions: &[Interaction]) -> (u32, u32) {\n        let mut positive = 0;\n        let mut negative = 0;\n        \n        for interaction in interactions {\n            match interaction.outcome {\n                InteractionOutcome::Positive => positive += 1,\n                InteractionOutcome::Negative => negative += 1,\n                InteractionOutcome::Neutral => {}, // Don't count neutral\n            }\n        }\n        \n        (positive, negative)\n    }\n    \n    fn calculate_confidence(&self, alpha: f64, beta: f64) -> f64 {\n        // Wilson score interval width as confidence measure\n        let n = alpha + beta;\n        let p = alpha / n;\n        \n        if n < 1.0 {\n            return 0.0;\n        }\n        \n        // 95% confidence interval\n        let z = 1.96; // z-score for 95% confidence\n        let denominator = 1.0 + z * z / n;\n        let centre_adjusted_probability = p + z * z / (2.0 * n);\n        let adjusted_standard_deviation = ((p * (1.0 - p) + z * z / (4.0 * n)) / n).sqrt();\n        \n        let lower_bound = (centre_adjusted_probability - z * adjusted_standard_deviation) / denominator;\n        let upper_bound = (centre_adjusted_probability + z * adjusted_standard_deviation) / denominator;\n        \n        // Confidence is inverse of interval width\n        1.0 / (upper_bound - lower_bound + f64::EPSILON)\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"spatial-temporal-attestations",children:"Spatial-Temporal Attestations"}),"\n",(0,r.jsx)(n.p,{children:"Enhanced attestation protocol for location and time verification:"}),"\n",(0,r.jsx)(n.h3,{id:"attestation-types",children:"Attestation Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::attestation::*;\n\n#[derive(Debug, Clone)]\npub enum AttestationType {\n    Presence {\n        location: Coordinate,\n        radius: f64,                     // Verification radius (meters)\n        timestamp: SystemTime,\n        duration: Option<Duration>,      // How long they were there\n    },\n    Proximity {\n        other_party: Did,               // Who they were near\n        distance: f64,                  // How close (meters)\n        timestamp: SystemTime,\n        confidence: f64,                // Confidence in measurement\n    },\n    Movement {\n        path: Vec<Coordinate>,          // Movement trajectory\n        start_time: SystemTime,\n        end_time: SystemTime,\n        mode: MovementMode,             // Walking, driving, etc.\n    },\n    Identity {\n        verified_attributes: HashMap<String, String>,\n        verification_method: VerificationMethod,\n        confidence_level: f64,\n    },\n    Interaction {\n        interaction_type: InteractionType,\n        other_parties: Vec<Did>,\n        outcome: InteractionOutcome,\n        timestamp: SystemTime,\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum MovementMode {\n    Walking,\n    Cycling,\n    Driving,\n    PublicTransport,\n    Unknown,\n}\n\n#[derive(Debug, Clone)]\npub enum InteractionType {\n    Meeting,\n    Transaction,\n    DataSharing,\n    Communication,\n    ServiceProvision,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"attestation-protocol",children:"Attestation Protocol"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::attestation::protocol::*;\n\npub struct AttestationProtocol {\n    config: AttestationConfig,\n    witness_registry: WitnessRegistry,\n}\n\nimpl AttestationProtocol {\n    pub async fn create_attestation(\n        &self,\n        subject: Did,\n        claim: AttestationType,\n        witnesses: Vec<Did>\n    ) -> Result<Attestation> {\n        \n        // Validate witnesses\n        self.validate_witnesses(&witnesses, &claim).await?;\n        \n        // Create attestation challenge\n        let challenge = AttestationChallenge::generate(&claim);\n        \n        // Collect witness responses\n        let witness_responses = self.collect_witness_responses(\n            &witnesses,\n            &challenge,\n            &claim\n        ).await?;\n        \n        // Verify spatial-temporal constraints\n        self.verify_spatiotemporal_constraints(&claim, &witness_responses)?;\n        \n        // Create final attestation\n        let attestation = Attestation {\n            id: AttestationId::generate(),\n            subject,\n            claim,\n            witnesses: witness_responses,\n            created_at: SystemTime::now(),\n            validity_period: self.calculate_validity_period(&claim),\n            confidence_score: self.calculate_confidence(&witness_responses),\n        };\n        \n        Ok(attestation)\n    }\n    \n    async fn validate_witnesses(\n        &self,\n        witnesses: &[Did],\n        claim: &AttestationType\n    ) -> Result<()> {\n        if witnesses.len() < self.config.required_witnesses {\n            return Err(AttestationError::InsufficientWitnesses {\n                required: self.config.required_witnesses,\n                provided: witnesses.len(),\n            });\n        }\n        \n        match claim {\n            AttestationType::Presence { location, radius, timestamp, .. } => {\n                // Check if witnesses were spatially and temporally capable\n                for witness in witnesses {\n                    let witness_location = self.witness_registry\n                        .get_location_at_time(witness, *timestamp)\n                        .await?;\n                        \n                    if let Some(loc) = witness_location {\n                        let distance = Coordinate::haversine_distance(\n                            location.latitude, location.longitude,\n                            loc.latitude, loc.longitude\n                        );\n                        \n                        if distance > radius + self.config.witness_proximity_margin {\n                            return Err(AttestationError::WitnessOutOfRange {\n                                witness: witness.clone(),\n                                distance,\n                                max_distance: radius + self.config.witness_proximity_margin,\n                            });\n                        }\n                    }\n                }\n            },\n            _ => {} // Other validations as needed\n        }\n        \n        Ok(())\n    }\n    \n    fn verify_spatiotemporal_constraints(\n        &self,\n        claim: &AttestationType,\n        responses: &[WitnessResponse]\n    ) -> Result<()> {\n        match claim {\n            AttestationType::Presence { location, radius, timestamp, .. } => {\n                let mut confirmations = 0;\n                \n                for response in responses {\n                    if let WitnessResponseType::PresenceConfirmation { \n                        observed_location, \n                        observation_time,\n                        confidence \n                    } = &response.response_type {\n                        \n                        // Check spatial consistency\n                        let distance = Coordinate::haversine_distance(\n                            location.latitude, location.longitude,\n                            observed_location.latitude, observed_location.longitude\n                        );\n                        \n                        if distance <= *radius {\n                            // Check temporal consistency\n                            let time_diff = observation_time.duration_since(*timestamp)\n                                .unwrap_or_else(|_| timestamp.duration_since(*observation_time).unwrap_or_default());\n                                \n                            if time_diff <= self.config.temporal_window && *confidence >= 0.7 {\n                                confirmations += 1;\n                            }\n                        }\n                    }\n                }\n                \n                if confirmations < self.config.required_confirmations {\n                    return Err(AttestationError::InsufficientConfirmations {\n                        required: self.config.required_confirmations,\n                        received: confirmations,\n                    });\n                }\n            },\n            _ => {} // Other constraint checks\n        }\n        \n        Ok(())\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"trust-network-management",children:"Trust Network Management"}),"\n",(0,r.jsx)(n.h3,{id:"peer-connection-management",children:"Peer Connection Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_trust::network::*;\n\npub struct TrustNetwork {\n    connections: HashMap<Did, PeerConnection>,\n    trust_relationships: HashMap<(Did, Did), TrustRelationship>,\n    reputation_scores: ReputationScores,\n    attestations: Vec<Attestation>,\n}\n\n#[derive(Debug, Clone)]\npub struct PeerConnection {\n    pub peer_did: Did,\n    pub connection_type: ConnectionType,\n    pub established_at: SystemTime,\n    pub last_interaction: SystemTime,\n    pub trust_score: f64,\n    pub attestations_given: u32,\n    pub attestations_received: u32,\n    pub interaction_history: Vec<Interaction>,\n}\n\n#[derive(Debug, Clone)]\npub enum ConnectionType {\n    Direct,           // Direct peer relationship\n    Transitive,       // Connected through mutual connections\n    Temporary,        // Short-term connection\n}\n\nimpl TrustNetwork {\n    pub fn add_peer_connection(\n        &mut self,\n        local_did: &Did,\n        peer_did: Did,\n        connection_type: ConnectionType\n    ) -> Result<()> {\n        // Check if we've reached maximum connections\n        if self.connections.len() >= self.config.max_connections {\n            return Err(TrustError::MaxConnectionsReached);\n        }\n        \n        // Check trust threshold for direct connections\n        if matches!(connection_type, ConnectionType::Direct) {\n            let reputation = self.reputation_scores.get(&peer_did).unwrap_or(&0.0);\n            if *reputation < self.config.trust_threshold {\n                return Err(TrustError::InsufficientTrust {\n                    peer: peer_did,\n                    trust_score: *reputation,\n                    required: self.config.trust_threshold,\n                });\n            }\n        }\n        \n        let connection = PeerConnection {\n            peer_did: peer_did.clone(),\n            connection_type,\n            established_at: SystemTime::now(),\n            last_interaction: SystemTime::now(),\n            trust_score: self.reputation_scores.get(&peer_did).unwrap_or(&0.5).clone(),\n            attestations_given: 0,\n            attestations_received: 0,\n            interaction_history: Vec::new(),\n        };\n        \n        self.connections.insert(peer_did, connection);\n        Ok(())\n    }\n    \n    pub fn record_interaction(\n        &mut self,\n        local_did: &Did,\n        peer_did: &Did,\n        interaction: Interaction\n    ) -> Result<()> {\n        // Update connection\n        if let Some(connection) = self.connections.get_mut(peer_did) {\n            connection.last_interaction = interaction.timestamp;\n            connection.interaction_history.push(interaction.clone());\n            \n            // Update trust score based on interaction outcome\n            match interaction.outcome {\n                InteractionOutcome::Positive => {\n                    connection.trust_score = (connection.trust_score + 0.1).min(1.0);\n                },\n                InteractionOutcome::Negative => {\n                    connection.trust_score = (connection.trust_score - 0.2).max(0.0);\n                },\n                InteractionOutcome::Neutral => {\n                    // No change\n                }\n            }\n        }\n        \n        // Update global trust relationship\n        let relationship_key = (local_did.clone(), peer_did.clone());\n        let relationship = self.trust_relationships.entry(relationship_key)\n            .or_insert_with(|| TrustRelationship::new(local_did.clone(), peer_did.clone()));\n            \n        relationship.add_interaction(interaction);\n        \n        Ok(())\n    }\n    \n    pub fn prune_inactive_connections(&mut self, inactive_threshold: Duration) -> usize {\n        let current_time = SystemTime::now();\n        let initial_count = self.connections.len();\n        \n        self.connections.retain(|_, connection| {\n            let inactive_duration = current_time.duration_since(connection.last_interaction)\n                .unwrap_or_default();\n                \n            // Keep direct connections longer than transitive ones\n            let threshold = match connection.connection_type {\n                ConnectionType::Direct => inactive_threshold * 3,\n                ConnectionType::Transitive => inactive_threshold,\n                ConnectionType::Temporary => inactive_threshold / 2,\n            };\n            \n            inactive_duration < threshold\n        });\n        \n        initial_count - self.connections.len()\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"trust-propagation",children:"Trust Propagation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl TrustNetwork {\n    pub fn propagate_trust(&self, source: &Did, max_hops: usize) -> HashMap<Did, f64> {\n        let mut trust_scores = HashMap::new();\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        \n        // Initialize with direct connections\n        queue.push_back((source.clone(), 1.0, 0));\n        visited.insert(source.clone());\n        \n        while let Some((current_did, current_trust, hops)) = queue.pop_front() {\n            if hops >= max_hops {\n                continue;\n            }\n            \n            // Get current peer's connections\n            if let Some(connection) = self.connections.get(&current_did) {\n                for (peer_did, relationship) in &self.trust_relationships {\n                    if peer_did.0 == current_did && !visited.contains(&peer_did.1) {\n                        let propagated_trust = current_trust * relationship.trust_score * 0.8; // Decay factor\n                        \n                        if propagated_trust > 0.1 { // Minimum threshold\n                            trust_scores.insert(peer_did.1.clone(), propagated_trust);\n                            queue.push_back((peer_did.1.clone(), propagated_trust, hops + 1));\n                            visited.insert(peer_did.1.clone());\n                        }\n                    }\n                }\n            }\n        }\n        \n        trust_scores\n    }\n    \n    pub fn find_trust_path(&self, from: &Did, to: &Did, max_hops: usize) -> Option<TrustPath> {\n        let mut queue = VecDeque::new();\n        let mut visited = HashMap::new();\n        \n        queue.push_back(TrustPath {\n            nodes: vec![from.clone()],\n            total_trust: 1.0,\n        });\n        \n        while let Some(current_path) = queue.pop_front() {\n            let current_node = current_path.nodes.last().unwrap();\n            \n            if current_node == to {\n                return Some(current_path);\n            }\n            \n            if current_path.nodes.len() >= max_hops {\n                continue;\n            }\n            \n            // Explore neighbors\n            for (relationship_key, relationship) in &self.trust_relationships {\n                if relationship_key.0 == *current_node {\n                    let next_node = &relationship_key.1;\n                    \n                    if !current_path.nodes.contains(next_node) { // Avoid cycles\n                        let path_trust = current_path.total_trust * relationship.trust_score;\n                        \n                        if path_trust > 0.01 { // Minimum path trust\n                            let mut new_path = current_path.clone();\n                            new_path.nodes.push(next_node.clone());\n                            new_path.total_trust = path_trust;\n                            \n                            queue.push_back(new_path);\n                        }\n                    }\n                }\n            }\n        }\n        \n        None\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,r.jsx)(n.h3,{id:"trust-based-access-control",children:"Trust-Based Access Control"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_trust::access::*;\n\npub struct TrustBasedAccessControl {\n    trust_network: TrustNetwork,\n    access_policies: HashMap<ResourceId, AccessPolicy>,\n}\n\nimpl TrustBasedAccessControl {\n    pub fn check_access(\n        &self,\n        requester: &Did,\n        resource: &ResourceId,\n        operation: &Operation\n    ) -> AccessDecision {\n        let policy = match self.access_policies.get(resource) {\n            Some(p) => p,\n            None => return AccessDecision::Deny("No policy found".to_string()),\n        };\n        \n        // Get trust score for requester\n        let trust_score = self.trust_network.reputation_scores\n            .get(requester)\n            .unwrap_or(&0.0);\n            \n        // Check trust threshold\n        if *trust_score < policy.min_trust_score {\n            return AccessDecision::Deny(format!(\n                "Insufficient trust: {} < {}",\n                trust_score, policy.min_trust_score\n            ));\n        }\n        \n        // Check attestation requirements\n        if policy.requires_attestation {\n            let attestations = self.trust_network.get_attestations_for(requester);\n            if !self.has_valid_attestation(&attestations, &policy.required_attestation_type) {\n                return AccessDecision::Deny("Required attestation not found".to_string());\n            }\n        }\n        \n        // Check operation-specific requirements\n        match operation {\n            Operation::Read => {\n                if trust_score >= &policy.read_threshold {\n                    AccessDecision::Allow\n                } else {\n                    AccessDecision::Deny("Insufficient trust for read operation".to_string())\n                }\n            },\n            Operation::Write => {\n                if trust_score >= &policy.write_threshold &&\n                   self.check_reputation_stability(requester) {\n                    AccessDecision::Allow\n                } else {\n                    AccessDecision::Deny("Insufficient trust or unstable reputation".to_string())\n                }\n            },\n            Operation::Delete => {\n                if trust_score >= &policy.delete_threshold &&\n                   self.has_administrative_attestation(requester) {\n                    AccessDecision::Allow\n                } else {\n                    AccessDecision::Deny("Insufficient privileges for delete operation".to_string())\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing--performance",children:"Testing & Performance"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod trust_tests {\n    use super::*;\n    \n    #[test]\n    fn test_eigentrust_convergence() {\n        let mut network = create_test_network();\n        \n        // Add some trust relationships\n        network.add_trust_relationship(\n            &did("alice"),\n            &did("bob"),\n            0.8\n        );\n        network.add_trust_relationship(\n            &did("bob"),\n            &did("charlie"),\n            0.9\n        );\n        \n        let algorithm = EigenTrustAlgorithm {\n            alpha: 0.5,\n            epsilon: 0.01,\n            max_iterations: 100,\n        };\n        \n        let scores = algorithm.calculate_reputation(&network).unwrap();\n        \n        // Charlie should have highest reputation (trusted by Bob, who is trusted by Alice)\n        assert!(scores.get(&did("charlie")).unwrap() > scores.get(&did("alice")).unwrap());\n    }\n    \n    #[test]\n    fn test_attestation_spatial_verification() {\n        let protocol = AttestationProtocol::new(AttestationConfig::default());\n        \n        let claim = AttestationType::Presence {\n            location: Coordinate::new(37.7749, -122.4194), // San Francisco\n            radius: 50.0,\n            timestamp: SystemTime::now(),\n            duration: Some(Duration::from_mins(30)),\n        };\n        \n        // Add witnesses at appropriate locations\n        let witnesses = vec![\n            did("witness1"), // Close to location\n            did("witness2"), // Close to location  \n            did("witness3"), // Close to location\n        ];\n        \n        let result = tokio_test::block_on(\n            protocol.create_attestation(did("subject"), claim, witnesses)\n        );\n        \n        assert!(result.is_ok());\n    }\n}\n\nfn create_test_network() -> TrustNetwork {\n    TrustNetwork::new(TrustNetworkConfig::default())\n}\n\nfn did(name: &str) -> Did {\n    // Create test DID from name\n    let private_key = PrivateKey::generate_for_testing(name);\n    Did::new(&private_key.public_key())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/device-integrity",children:"Device Integrity"})," - Device attestation integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/hsm-integration",children:"HSM Integration"})," - Hardware-backed trust"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/extensions/security/post-quantum",children:"Post-Quantum Cryptography"})," - Future-proof trust"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/extensions/enterprise/credentials/",children:"Credentials Extension"})," - W3C VC integration"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);