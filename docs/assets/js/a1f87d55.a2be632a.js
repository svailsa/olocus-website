"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[16],{1959:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/infrastructure/metrics","title":"Metrics Collection and Export","description":"The Metrics extension provides comprehensive instrumentation, collection, and export capabilities for monitoring Olocus Protocol performance, health, and operational metrics. It supports multiple export formats and sampling strategies for integration with existing monitoring infrastructure.","source":"@site/docs/extensions/infrastructure/metrics.md","sourceDirName":"extensions/infrastructure","slug":"/extensions/infrastructure/metrics","permalink":"/docs/extensions/infrastructure/metrics","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/infrastructure/metrics.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":5,"frontMatter":{"id":"metrics","title":"Metrics Collection and Export","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"HTTP REST API for Block Operations","permalink":"/docs/extensions/infrastructure/http-api"},"next":{"title":"Query Engine","permalink":"/docs/extensions/infrastructure/query-engine"}}');var s=t(4848),i=t(8453);const o={id:"metrics",title:"Metrics Collection and Export",sidebar_position:5},a="Metrics Collection and Export",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Metrics Trait Interface",id:"metrics-trait-interface",level:2},{value:"Core Metrics Traits",id:"core-metrics-traits",level:3},{value:"Prometheus Export",id:"prometheus-export",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Built-in Metrics",id:"built-in-metrics",level:2},{value:"Consensus Metrics",id:"consensus-metrics",level:3},{value:"Network Metrics",id:"network-metrics",level:3},{value:"Storage Metrics",id:"storage-metrics",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Production Monitoring Setup",id:"production-monitoring-setup",level:3},{value:"Development Environment",id:"development-environment",level:3},{value:"Error Handling",id:"error-handling",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"metrics-collection-and-export",children:"Metrics Collection and Export"})}),"\n",(0,s.jsx)(n.p,{children:"The Metrics extension provides comprehensive instrumentation, collection, and export capabilities for monitoring Olocus Protocol performance, health, and operational metrics. It supports multiple export formats and sampling strategies for integration with existing monitoring infrastructure."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Metrics collection enables monitoring of:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Metrics"}),": Latency, throughput, error rates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Health Metrics"}),": Resource utilization, connection status, consensus state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Business Metrics"}),": Block production rates, transaction counts, validator performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System Metrics"}),": Memory usage, CPU utilization, disk I/O"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::*;\n\n// Configure metrics collection\nlet metrics_config = MetricsConfig {\n    export_format: ExportFormat::Prometheus {\n        bind_addr: "0.0.0.0:9090".parse()?,\n        path: "/metrics".to_string(),\n        registry_name: "olocus".to_string(),\n    },\n    sampling_strategy: SamplingStrategy::Adaptive {\n        base_rate: 0.1,\n        max_rate: 1.0,\n        window_size: Duration::from_secs(60),\n    },\n    aggregation_interval: Duration::from_secs(30),\n    retention_period: Duration::from_secs(3600),\n    health_check_interval: Duration::from_secs(10),\n};\n\nlet metrics_registry = MetricsRegistry::new(metrics_config).await?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"metrics-trait-interface",children:"Metrics Trait Interface"}),"\n",(0,s.jsx)(n.h3,{id:"core-metrics-traits",children:"Core Metrics Traits"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use olocus_metrics::traits::*;\nuse olocus_core::*;\n\n#[async_trait::async_trait]\npub trait MetricsCollector: Send + Sync {\n    async fn record_counter(&self, name: &str, value: u64, labels: &[(&str, &str)]) -> Result<()>;\n    async fn record_gauge(&self, name: &str, value: f64, labels: &[(&str, &str)]) -> Result<()>;\n    async fn record_histogram(&self, name: &str, value: f64, labels: &[(&str, &str)]) -> Result<()>;\n    async fn record_timer(&self, name: &str, duration: Duration, labels: &[(&str, &str)]) -> Result<()>;\n    \n    async fn increment_counter(&self, name: &str, labels: &[(&str, &str)]) -> Result<()>;\n    async fn set_gauge(&self, name: &str, value: f64, labels: &[(&str, &str)]) -> Result<()>;\n    async fn observe_histogram(&self, name: &str, value: f64, labels: &[(&str, &str)]) -> Result<()>;\n    \n    fn start_timer(&self, name: &str) -> Timer;\n    async fn get_metrics_snapshot(&self) -> Result<MetricsSnapshot>;\n}\n\n#[async_trait::async_trait]\npub trait ExportFormat: Send + Sync {\n    async fn export_metrics(&self, snapshot: &MetricsSnapshot) -> Result<Vec<u8>>;\n    async fn start_server(&self, registry: Arc<MetricsRegistry>) -> Result<()>;\n    fn content_type(&self) -> &'static str;\n    fn file_extension(&self) -> &'static str;\n}\n\n#[async_trait::async_trait]\npub trait SamplingStrategy: Send + Sync {\n    async fn should_sample(&mut self, metric_name: &str, current_load: f64) -> bool;\n    async fn update_sampling_rate(&mut self, metric_name: &str, new_rate: f64);\n    fn get_current_rate(&self, metric_name: &str) -> f64;\n}\n\n#[derive(Debug, Clone)]\npub struct Timer {\n    pub name: String,\n    pub start_time: Instant,\n    pub labels: Vec<(String, String)>,\n}\n\nimpl Timer {\n    pub fn finish(self, collector: &dyn MetricsCollector) -> Result<Duration> {\n        let duration = self.start_time.elapsed();\n        let labels: Vec<(&str, &str)> = self.labels.iter()\n            .map(|(k, v)| (k.as_str(), v.as_str()))\n            .collect();\n        \n        futures::executor::block_on(\n            collector.record_timer(&self.name, duration, &labels)\n        )?;\n        \n        Ok(duration)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MetricsSnapshot {\n    pub timestamp: SystemTime,\n    pub counters: HashMap<String, CounterMetric>,\n    pub gauges: HashMap<String, GaugeMetric>,\n    pub histograms: HashMap<String, HistogramMetric>,\n    pub timers: HashMap<String, TimerMetric>,\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"prometheus-export",children:"Prometheus Export"}),"\n",(0,s.jsx)(n.p,{children:"Prometheus integration for industry-standard monitoring:"}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::export::prometheus::*;\nuse prometheus::{Registry, Counter, Gauge, Histogram, Opts};\n\n#[derive(Debug)]\npub struct PrometheusExporter {\n    config: PrometheusConfig,\n    registry: Registry,\n    server_handle: Option<JoinHandle<()>>,\n}\n\n#[derive(Debug, Clone)]\npub struct PrometheusConfig {\n    pub bind_addr: SocketAddr,\n    pub path: String,\n    pub registry_name: String,\n    pub namespace: String,\n    pub subsystem: String,\n    pub help_text: bool,\n    pub include_timestamp: bool,\n}\n\nimpl Default for PrometheusConfig {\n    fn default() -> Self {\n        Self {\n            bind_addr: "0.0.0.0:9090".parse().unwrap(),\n            path: "/metrics".to_string(),\n            registry_name: "olocus".to_string(),\n            namespace: "olocus".to_string(),\n            subsystem: "".to_string(),\n            help_text: true,\n            include_timestamp: true,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl ExportFormat for PrometheusExporter {\n    async fn export_metrics(&self, snapshot: &MetricsSnapshot) -> Result<Vec<u8>> {\n        let mut output = Vec::new();\n        \n        // Export counters\n        for (name, metric) in &snapshot.counters {\n            let metric_name = self.format_metric_name(name);\n            \n            if self.config.help_text {\n                writeln!(&mut output, "# HELP {} {}", metric_name, metric.description)?;\n                writeln!(&mut output, "# TYPE {} counter", metric_name)?;\n            }\n            \n            for sample in &metric.samples {\n                let labels = self.format_labels(&sample.labels);\n                writeln!(&mut output, "{}{} {} {}", \n                    metric_name, labels, sample.value, \n                    snapshot.timestamp.duration_since(SystemTime::UNIX_EPOCH)?.as_millis())?;\n            }\n        }\n        \n        // Export gauges\n        for (name, metric) in &snapshot.gauges {\n            let metric_name = self.format_metric_name(name);\n            \n            if self.config.help_text {\n                writeln!(&mut output, "# HELP {} {}", metric_name, metric.description)?;\n                writeln!(&mut output, "# TYPE {} gauge", metric_name)?;\n            }\n            \n            for sample in &metric.samples {\n                let labels = self.format_labels(&sample.labels);\n                writeln!(&mut output, "{}{} {} {}", \n                    metric_name, labels, sample.value,\n                    snapshot.timestamp.duration_since(SystemTime::UNIX_EPOCH)?.as_millis())?;\n            }\n        }\n        \n        // Export histograms\n        for (name, metric) in &snapshot.histograms {\n            let metric_name = self.format_metric_name(name);\n            \n            if self.config.help_text {\n                writeln!(&mut output, "# HELP {} {}", metric_name, metric.description)?;\n                writeln!(&mut output, "# TYPE {} histogram", metric_name)?;\n            }\n            \n            for sample in &metric.samples {\n                let base_labels = &sample.labels;\n                \n                // Export buckets\n                for (bucket, count) in &sample.buckets {\n                    let mut labels = base_labels.clone();\n                    labels.push(("le".to_string(), bucket.to_string()));\n                    let labels_str = self.format_labels(&labels);\n                    writeln!(&mut output, "{}_bucket{} {} {}", \n                        metric_name, labels_str, count,\n                        snapshot.timestamp.duration_since(SystemTime::UNIX_EPOCH)?.as_millis())?;\n                }\n                \n                // Export count and sum\n                let labels_str = self.format_labels(base_labels);\n                writeln!(&mut output, "{}_count{} {} {}", \n                    metric_name, labels_str, sample.count,\n                    snapshot.timestamp.duration_since(SystemTime::UNIX_EPOCH)?.as_millis())?;\n                writeln!(&mut output, "{}_sum{} {} {}", \n                    metric_name, labels_str, sample.sum,\n                    snapshot.timestamp.duration_since(SystemTime::UNIX_EPOCH)?.as_millis())?;\n            }\n        }\n        \n        Ok(output)\n    }\n    \n    async fn start_server(&self, registry: Arc<MetricsRegistry>) -> Result<()> {\n        let bind_addr = self.config.bind_addr;\n        let path = self.config.path.clone();\n        \n        let server = warp::path(path.trim_start_matches(\'/\'))\n            .and(warp::get())\n            .and_then(move || {\n                let registry = registry.clone();\n                async move {\n                    match registry.get_metrics_snapshot().await {\n                        Ok(snapshot) => {\n                            let exporter = PrometheusExporter::new(PrometheusConfig::default());\n                            match exporter.export_metrics(&snapshot).await {\n                                Ok(data) => {\n                                    Ok(warp::reply::with_header(\n                                        data,\n                                        "content-type",\n                                        "text/plain; charset=utf-8"\n                                    ))\n                                }\n                                Err(e) => Err(warp::reject::custom(MetricsError::Export(e.to_string())))\n                            }\n                        }\n                        Err(e) => Err(warp::reject::custom(MetricsError::Collection(e.to_string())))\n                    }\n                }\n            });\n        \n        warp::serve(server).run(bind_addr).await;\n        Ok(())\n    }\n    \n    fn content_type(&self) -> &\'static str {\n        "text/plain; charset=utf-8"\n    }\n    \n    fn file_extension(&self) -> &\'static str {\n        "txt"\n    }\n}\n\nimpl PrometheusExporter {\n    pub fn new(config: PrometheusConfig) -> Self {\n        Self {\n            config,\n            registry: Registry::new(),\n            server_handle: None,\n        }\n    }\n    \n    fn format_metric_name(&self, name: &str) -> String {\n        let mut formatted = name.to_lowercase().replace("-", "_");\n        \n        if !self.config.namespace.is_empty() {\n            formatted = format!("{}_{}", self.config.namespace, formatted);\n        }\n        \n        if !self.config.subsystem.is_empty() {\n            formatted = format!("{}_{}", formatted, self.config.subsystem);\n        }\n        \n        formatted\n    }\n    \n    fn format_labels(&self, labels: &[(String, String)]) -> String {\n        if labels.is_empty() {\n            return String::new();\n        }\n        \n        let formatted_labels: Vec<String> = labels.iter()\n            .map(|(k, v)| format!("{}=\\"{}\\"", k, v.replace("\\"", "\\\\\\"")))\n            .collect();\n        \n        format!("{{{}}}", formatted_labels.join(","))\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::export::prometheus::*;\n\n// Configure Prometheus export\nlet prometheus_config = PrometheusConfig {\n    bind_addr: "0.0.0.0:9090".parse()?,\n    path: "/metrics".to_string(),\n    namespace: "olocus".to_string(),\n    subsystem: "consensus".to_string(),\n    help_text: true,\n    include_timestamp: true,\n};\n\nlet exporter = PrometheusExporter::new(prometheus_config);\n\n// Start metrics server\nlet metrics_registry = Arc::new(MetricsRegistry::new(MetricsConfig::default()).await?);\nexporter.start_server(metrics_registry.clone()).await?;\n\n// Record some metrics\nmetrics_registry.increment_counter("blocks_produced", &[("validator", "node1")]).await?;\nmetrics_registry.set_gauge("memory_usage_bytes", 1024.0 * 1024.0 * 512.0, &[]).await?;\n\n// Start histogram timer\nlet timer = metrics_registry.start_timer("block_processing_duration");\n// ... do block processing ...\ntimer.finish(&*metrics_registry)?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"built-in-metrics",children:"Built-in Metrics"}),"\n",(0,s.jsx)(n.p,{children:"The extension provides built-in metrics for common Olocus Protocol operations:"}),"\n",(0,s.jsx)(n.h3,{id:"consensus-metrics",children:"Consensus Metrics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::builtin::consensus::*;\n\n// Block production metrics\nmetrics.increment_counter("olocus_blocks_produced_total", &[\n    ("validator", validator_id),\n    ("algorithm", "pbft"),\n]);\n\nmetrics.record_histogram("olocus_block_production_duration_seconds", \n    production_time.as_secs_f64(), &[\n    ("validator", validator_id),\n    ("success", "true"),\n]);\n\n// Consensus participation\nmetrics.set_gauge("olocus_consensus_participation_rate", \n    participation_rate, &[\n    ("validator", validator_id),\n]);\n\nmetrics.increment_counter("olocus_votes_cast_total", &[\n    ("validator", validator_id),\n    ("vote_type", "prepare"),\n]);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"network-metrics",children:"Network Metrics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::builtin::network::*;\n\n// Connection metrics\nmetrics.set_gauge("olocus_network_connections_active", \n    active_connections as f64, &[\n    ("transport", "tcp"),\n]);\n\nmetrics.increment_counter("olocus_network_messages_sent_total", &[\n    ("message_type", "block"),\n    ("peer", peer_id),\n]);\n\nmetrics.record_histogram("olocus_network_latency_seconds", \n    latency.as_secs_f64(), &[\n    ("peer", peer_id),\n    ("message_type", "block"),\n]);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"storage-metrics",children:"Storage Metrics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::builtin::storage::*;\n\n// Storage operations\nmetrics.record_timer("olocus_storage_operation_duration", \n    operation_duration, &[\n    ("operation", "write"),\n    ("backend", "rocksdb"),\n]);\n\nmetrics.set_gauge("olocus_storage_size_bytes", \n    storage_size as f64, &[\n    ("backend", "rocksdb"),\n]);\n\nmetrics.increment_counter("olocus_storage_operations_total", &[\n    ("operation", "read"),\n    ("status", "success"),\n]);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Export Format"}),(0,s.jsx)(n.th,{children:"Overhead"}),(0,s.jsx)(n.th,{children:"Latency"}),(0,s.jsx)(n.th,{children:"Bandwidth"}),(0,s.jsx)(n.th,{children:"Compatibility"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Prometheus"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Excellent"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"OpenTelemetry"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"Good"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"StatsD"}),(0,s.jsx)(n.td,{children:"Very Low"}),(0,s.jsx)(n.td,{children:"Very Low"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Good"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"Low"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Excellent"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"production-monitoring-setup",children:"Production Monitoring Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::*;\n\n// High-performance production configuration\nlet config = MetricsConfig {\n    export_format: ExportFormat::Prometheus {\n        bind_addr: "0.0.0.0:9090".parse()?,\n        path: "/metrics".to_string(),\n        registry_name: "olocus_production".to_string(),\n    },\n    sampling_strategy: SamplingStrategy::Adaptive {\n        base_rate: 0.05, // 5% sampling under normal load\n        max_rate: 0.2,   // Maximum 20% sampling\n        window_size: Duration::from_secs(300), // 5-minute window\n    },\n    aggregation_interval: Duration::from_secs(15),\n    retention_period: Duration::from_secs(86400), // 24 hours\n    health_check_interval: Duration::from_secs(30),\n};\n\nlet registry = MetricsRegistry::new(config).await?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"development-environment",children:"Development Environment"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Development configuration with full sampling\nlet config = MetricsConfig {\n    export_format: ExportFormat::Prometheus {\n        bind_addr: "127.0.0.1:9090".parse()?,\n        path: "/metrics".to_string(),\n        registry_name: "olocus_dev".to_string(),\n    },\n    sampling_strategy: SamplingStrategy::Fixed { rate: 1.0 }, // 100% sampling\n    aggregation_interval: Duration::from_secs(5),\n    retention_period: Duration::from_secs(3600), // 1 hour\n    health_check_interval: Duration::from_secs(10),\n};\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use olocus_metrics::error::*;\n\n#[derive(Debug, thiserror::Error)]\npub enum MetricsError {\n    #[error("Collection error: {0}")]\n    Collection(String),\n    \n    #[error("Export error: {0}")]\n    Export(String),\n    \n    #[error("Sampling error: {0}")]\n    Sampling(String),\n    \n    #[error("Health check error: {0}")]\n    HealthCheck(String),\n    \n    #[error("Configuration error: {0}")]\n    Configuration(String),\n    \n    #[error("Network error: {0}")]\n    Network(#[from] NetworkError),\n    \n    #[error("Serialization error: {0}")]\n    Serialization(#[from] serde_json::Error),\n    \n    #[error("IO error: {0}")]\n    Io(#[from] std::io::Error),\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The Metrics extension provides comprehensive observability for Olocus Protocol deployments, enabling monitoring, alerting, and performance optimization through industry-standard metrics formats and adaptive sampling strategies."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);