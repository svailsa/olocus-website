"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[6511],{7826:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"concepts/blocks-and-chains","title":"Blocks and Chains","description":"The fundamental data structures of the Olocus Protocol.","source":"@site/docs/concepts/blocks-and-chains.md","sourceDirName":"concepts","slug":"/concepts/blocks-and-chains","permalink":"/docs/concepts/blocks-and-chains","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/blocks-and-chains.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"blocks-and-chains","title":"Blocks and Chains","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Choosing Extensions","permalink":"/docs/getting-started/choosing-extensions"},"next":{"title":"Universal Measurement Foundation","permalink":"/docs/concepts/measurements"}}');var l=i(4848),r=i(8453);const a={id:"blocks-and-chains",title:"Blocks and Chains",sidebar_position:1},t="Blocks and Chains",c={},o=[{value:"What is a Block?",id:"what-is-a-block",level:2},{value:"Block Structure",id:"block-structure",level:2},{value:"Key Components",id:"key-components",level:2},{value:"1. Header",id:"1-header",level:3},{value:"2. Payload",id:"2-payload",level:3},{value:"3. Signature",id:"3-signature",level:3},{value:"4. Public Key",id:"4-public-key",level:3},{value:"What is a Chain?",id:"what-is-a-chain",level:2},{value:"Chain Properties",id:"chain-properties",level:3},{value:"Creating Blocks",id:"creating-blocks",level:2},{value:"Genesis Block",id:"genesis-block",level:3},{value:"Subsequent Blocks",id:"subsequent-blocks",level:3},{value:"Chain Verification",id:"chain-verification",level:2},{value:"Single Block",id:"single-block",level:3},{value:"Entire Chain",id:"entire-chain",level:3},{value:"Hash Calculation",id:"hash-calculation",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"1. Audit Trail",id:"1-audit-trail",level:3},{value:"2. Sensor Data",id:"2-sensor-data",level:3},{value:"3. Trust Attestations",id:"3-trust-attestations",level:3},{value:"Security Properties",id:"security-properties",level:2},{value:"Tamper Evidence",id:"tamper-evidence",level:3},{value:"Non-Repudiation",id:"non-repudiation",level:3},{value:"Temporal Ordering",id:"temporal-ordering",level:3},{value:"Performance",id:"performance",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Key Management",id:"1-key-management",level:3},{value:"2. Timestamp Accuracy",id:"2-timestamp-accuracy",level:3},{value:"3. Payload Size",id:"3-payload-size",level:3},{value:"4. Chain Length",id:"4-chain-length",level:3},{value:"Example: Simple Event Chain",id:"example-simple-event-chain",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"blocks-and-chains",children:"Blocks and Chains"})}),"\n",(0,l.jsx)(n.p,{children:"The fundamental data structures of the Olocus Protocol."}),"\n",(0,l.jsx)(n.h2,{id:"what-is-a-block",children:"What is a Block?"}),"\n",(0,l.jsx)(n.p,{children:"A block is a cryptographically signed container for data with these properties:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Immutable"}),": Once created, cannot be modified"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Verifiable"}),": Signature proves authenticity"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Timestamped"}),": Records when it was created"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Linked"}),": References previous blocks to form chains"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"block-structure",children:"Block Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"pub struct Block<P: BlockPayload> {\n    pub header: BlockHeader,\n    pub payload: P,\n    pub signature: Signature,\n    pub public_key: VerifyingKey,\n}\n\npub struct BlockHeader {\n    pub version: u16,         // Protocol version (0x0105)\n    pub index: u64,           // Position in chain\n    pub timestamp: i64,       // Unix timestamp\n    pub previous: [u8; 32],   // Hash of previous block\n    pub payload_hash: [u8; 32], // SHA-256 of payload\n    pub payload_type: u32,    // Type identifier\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,l.jsx)(n.h3,{id:"1-header",children:"1. Header"}),"\n",(0,l.jsx)(n.p,{children:"Contains metadata about the block:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Version"}),": Protocol version for compatibility"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Index"}),": Sequential position in the chain (0, 1, 2...)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Timestamp"}),": When the block was created"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Previous"}),": Links to the previous block's hash"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Payload Hash"}),": Integrity check for the payload"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Payload Type"}),": Identifies the type of data"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"2-payload",children:"2. Payload"}),"\n",(0,l.jsxs)(n.p,{children:["The actual data being stored. Can be any type that implements ",(0,l.jsx)(n.code,{children:"BlockPayload"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"pub trait BlockPayload {\n    fn to_bytes(&self) -> Vec<u8>;\n    fn from_bytes(bytes: &[u8]) -> Result<Self>;\n    fn payload_type() -> u32;\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"3-signature",children:"3. Signature"}),"\n",(0,l.jsx)(n.p,{children:"Ed25519 signature proving:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The block was created by the holder of the private key"}),"\n",(0,l.jsx)(n.li,{children:"The block hasn't been tampered with"}),"\n",(0,l.jsx)(n.li,{children:"Non-repudiation: creator cannot deny creating it"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"4-public-key",children:"4. Public Key"}),"\n",(0,l.jsx)(n.p,{children:"The Ed25519 public key used to verify the signature."}),"\n",(0,l.jsx)(n.h2,{id:"what-is-a-chain",children:"What is a Chain?"}),"\n",(0,l.jsx)(n.p,{children:"A chain is a sequence of blocks where each block references the previous one:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"[Genesis] <- [Block 1] <- [Block 2] <- [Block 3] <- ...\n"})}),"\n",(0,l.jsx)(n.h3,{id:"chain-properties",children:"Chain Properties"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Genesis Block"}),": First block with index 0 and no previous hash"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Sequential Indices"}),": Each block's index is previous + 1"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Hash Linking"}),": Each block contains hash of previous"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Chronological"}),": Timestamps must be monotonically increasing"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Verifiable"}),": Can verify entire chain from genesis to tip"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"creating-blocks",children:"Creating Blocks"}),"\n",(0,l.jsx)(n.h3,{id:"genesis-block",children:"Genesis Block"}),"\n",(0,l.jsx)(n.p,{children:"The first block in any chain:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{Block, generate_key, current_timestamp};\n\nlet (signing_key, _) = generate_key();\nlet genesis = Block::genesis(\n    my_payload,\n    &signing_key,\n    current_timestamp()\n);\n\n// Genesis block has:\n// - index: 0\n// - previous: [0; 32] (all zeros)\n"})}),"\n",(0,l.jsx)(n.h3,{id:"subsequent-blocks",children:"Subsequent Blocks"}),"\n",(0,l.jsx)(n.p,{children:"Adding to an existing chain:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let block2 = Block::next(\n    &genesis,           // Previous block\n    new_payload,        // New data\n    &signing_key,       // Can be same or different key\n    current_timestamp()\n)?;\n\n// Automatically sets:\n// - index: 1 (genesis.index + 1)\n// - previous: hash of genesis block\n"})}),"\n",(0,l.jsx)(n.h2,{id:"chain-verification",children:"Chain Verification"}),"\n",(0,l.jsx)(n.h3,{id:"single-block",children:"Single Block"}),"\n",(0,l.jsx)(n.p,{children:"Verify a block's signature and structure:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"use olocus_core::verify_block;\n\n// Verify genesis (no previous)\nverify_block(&genesis, None)?;\n\n// Verify chain block (with previous)\nverify_block(&block2, Some(&genesis))?;\n"})}),"\n",(0,l.jsx)(n.h3,{id:"entire-chain",children:"Entire Chain"}),"\n",(0,l.jsx)(n.p,{children:"Verify all blocks and their connections:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"use olocus_core::verify_chain;\n\nlet chain = vec![genesis, block2, block3];\nverify_chain(&chain)?;\n\n// Verifies:\n// \u2713 All signatures valid\n// \u2713 Indices increment properly\n// \u2713 Previous hashes match\n// \u2713 Timestamps increase\n// \u2713 No gaps or forks\n"})}),"\n",(0,l.jsx)(n.h2,{id:"hash-calculation",children:"Hash Calculation"}),"\n",(0,l.jsx)(n.p,{children:"Blocks are identified by their SHA-256 hash:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"let hash = block.hash();  // [u8; 32]\n\n// Hash includes:\n// - All header fields\n// - Payload hash\n// - Public key\n// - Signature\n"})}),"\n",(0,l.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,l.jsx)(n.h3,{id:"1-audit-trail",children:"1. Audit Trail"}),"\n",(0,l.jsx)(n.p,{children:"Immutable record of events:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct AuditEntry {\n    action: String,\n    user: String,\n    timestamp: u64,\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"2-sensor-data",children:"2. Sensor Data"}),"\n",(0,l.jsx)(n.p,{children:"Timestamped measurements:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct SensorReading {\n    temperature: f32,\n    humidity: f32,\n    location: (f64, f64),\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"3-trust-attestations",children:"3. Trust Attestations"}),"\n",(0,l.jsx)(n.p,{children:"Cryptographic proofs:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct Attestation {\n    claim: String,\n    witness: PublicKey,\n    evidence: Vec<u8>,\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"security-properties",children:"Security Properties"}),"\n",(0,l.jsx)(n.h3,{id:"tamper-evidence",children:"Tamper Evidence"}),"\n",(0,l.jsx)(n.p,{children:"Any modification breaks the chain:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Changing payload invalidates payload hash"}),"\n",(0,l.jsx)(n.li,{children:"Changing header invalidates signature"}),"\n",(0,l.jsx)(n.li,{children:"Changing any block breaks all subsequent links"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"non-repudiation",children:"Non-Repudiation"}),"\n",(0,l.jsx)(n.p,{children:"Signatures prove who created each block:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cannot deny creating a signed block"}),"\n",(0,l.jsx)(n.li,{children:"Cannot forge someone else's signature"}),"\n",(0,l.jsx)(n.li,{children:"Public key identifies the creator"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"temporal-ordering",children:"Temporal Ordering"}),"\n",(0,l.jsx)(n.p,{children:"Timestamps and indices ensure order:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Cannot insert blocks in the past"}),"\n",(0,l.jsx)(n.li,{children:"Cannot reorder blocks"}),"\n",(0,l.jsx)(n.li,{children:"Maintains chronological sequence"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Operation"}),(0,l.jsx)(n.th,{children:"Time"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Create block"}),(0,l.jsx)(n.td,{children:"<1ms"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Verify block"}),(0,l.jsx)(n.td,{children:"<1ms"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Calculate hash"}),(0,l.jsx)(n.td,{children:"<100\u03bcs"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Verify chain (1000 blocks)"}),(0,l.jsx)(n.td,{children:"<1s"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(n.h3,{id:"1-key-management",children:"1. Key Management"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Keep signing keys secure"}),"\n",(0,l.jsx)(n.li,{children:"Consider key rotation"}),"\n",(0,l.jsx)(n.li,{children:"Different keys for different trust domains"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"2-timestamp-accuracy",children:"2. Timestamp Accuracy"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Use reliable time sources"}),"\n",(0,l.jsx)(n.li,{children:"Consider NTP synchronization"}),"\n",(0,l.jsx)(n.li,{children:"Account for clock drift"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"3-payload-size",children:"3. Payload Size"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Keep payloads reasonable (<16MB)"}),"\n",(0,l.jsx)(n.li,{children:"Consider off-chain storage for large data"}),"\n",(0,l.jsx)(n.li,{children:"Use hashes for external references"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"4-chain-length",children:"4. Chain Length"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Consider periodic snapshots"}),"\n",(0,l.jsx)(n.li,{children:"Implement pruning strategies"}),"\n",(0,l.jsx)(n.li,{children:"Use merkle trees for aggregation"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"example-simple-event-chain",children:"Example: Simple Event Chain"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use olocus_core::*;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Clone, Serialize, Deserialize)]\nstruct Event {\n    id: String,\n    action: String,\n    metadata: HashMap<String, String>,\n}\n\nimpl BlockPayload for Event {\n    fn to_bytes(&self) -> Vec<u8> {\n        serde_json::to_vec(self).unwrap()\n    }\n    \n    fn from_bytes(bytes: &[u8]) -> Result<Self> {\n        Ok(serde_json::from_slice(bytes)?)\n    }\n    \n    fn payload_type() -> u32 {\n        0x0001  // Event type\n    }\n}\n\nfn main() -> Result<()> {\n    let (key, _) = generate_key();\n    let mut chain = Vec::new();\n    \n    // Create genesis with first event\n    let event1 = Event {\n        id: "evt_001".into(),\n        action: "system_start".into(),\n        metadata: HashMap::new(),\n    };\n    \n    let genesis = Block::genesis(event1, &key, current_timestamp());\n    chain.push(genesis.clone());\n    \n    // Add more events\n    for i in 2..=10 {\n        let event = Event {\n            id: format!("evt_{:03}", i),\n            action: format!("action_{}", i),\n            metadata: HashMap::new(),\n        };\n        \n        let block = Block::next(\n            chain.last().unwrap(),\n            event,\n            &key,\n            current_timestamp()\n        )?;\n        \n        chain.push(block);\n    }\n    \n    // Verify entire chain\n    verify_chain(&chain)?;\n    println!("Chain valid! {} blocks", chain.len());\n    \n    Ok(())\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./measurements",children:"Understanding Measurements"})," - Data with uncertainty"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./cryptographic-primitives",children:"Cryptographic Primitives"})," - Security foundations"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"./wire-format",children:"Wire Format"})," - Serialization and transport"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"../api/block-operations",children:"Block Operations API"})," - Detailed API reference"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var s=i(6540);const l={},r=s.createContext(l);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);