"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[4778],{2370:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"concepts/algorithm-negotiation","title":"Algorithm Negotiation","description":"Algorithm negotiation in Olocus Protocol allows peers to establish secure communication channels while preventing downgrade attacks and ensuring mutual algorithm support. The system combines cryptographic preferences with security policies to select the best available algorithms for each connection.","source":"@site/docs/concepts/algorithm-negotiation.md","sourceDirName":"concepts","slug":"/concepts/algorithm-negotiation","permalink":"/docs/concepts/algorithm-negotiation","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/algorithm-negotiation.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"algorithm-negotiation","title":"Algorithm Negotiation","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Wire Format","permalink":"/docs/concepts/wire-format"},"next":{"title":"Downgrade Protection","permalink":"/docs/concepts/downgrade-protection"}}');var t=i(4848),s=i(8453);const l={id:"algorithm-negotiation",title:"Algorithm Negotiation",sidebar_position:1},o="Algorithm Negotiation",c={},d=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Algorithm Categories",id:"algorithm-categories",level:3},{value:"Security Levels",id:"security-levels",level:3},{value:"Algorithm Status",id:"algorithm-status",level:3},{value:"Supported Algorithms",id:"supported-algorithms",level:2},{value:"Signature Algorithms",id:"signature-algorithms",level:3},{value:"Hash Algorithms",id:"hash-algorithms",level:3},{value:"Key Exchange Algorithms",id:"key-exchange-algorithms",level:3},{value:"Encryption Algorithms",id:"encryption-algorithms",level:3},{value:"Negotiation Process",id:"negotiation-process",level:2},{value:"1. Preference Declaration",id:"1-preference-declaration",level:3},{value:"2. Preference Signing",id:"2-preference-signing",level:3},{value:"3. Algorithm Selection",id:"3-algorithm-selection",level:3},{value:"Security Requirements",id:"security-requirements",level:2},{value:"Minimum Security Policies",id:"minimum-security-policies",level:3},{value:"Algorithm Deprecation",id:"algorithm-deprecation",level:3},{value:"Downgrade Protection",id:"downgrade-protection",level:2},{value:"1. Protocol Version Checking",id:"1-protocol-version-checking",level:3},{value:"2. Signed Preferences",id:"2-signed-preferences",level:3},{value:"3. Strict Ordering",id:"3-strict-ordering",level:3},{value:"4. Negotiation Commitment",id:"4-negotiation-commitment",level:3},{value:"5. Minimum Security Requirements",id:"5-minimum-security-requirements",level:3},{value:"6. Forbidden Algorithm Lists",id:"6-forbidden-algorithm-lists",level:3},{value:"7. Handshake Transcript Binding",id:"7-handshake-transcript-binding",level:3},{value:"Post-Quantum Transition",id:"post-quantum-transition",level:2},{value:"Hybrid Mode",id:"hybrid-mode",level:3},{value:"Migration Strategies",id:"migration-strategies",level:3},{value:"Implementation Example",id:"implementation-example",level:2},{value:"Basic Negotiation",id:"basic-negotiation",level:3},{value:"Enterprise Security Policy",id:"enterprise-security-policy",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Algorithm Performance Ratings",id:"algorithm-performance-ratings",level:3},{value:"Negotiation Caching",id:"negotiation-caching",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Negotiation Test Vectors",id:"negotiation-test-vectors",level:3},{value:"Interoperability Testing",id:"interoperability-testing",level:3},{value:"Future Extensions",id:"future-extensions",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"algorithm-negotiation",children:"Algorithm Negotiation"})}),"\n",(0,t.jsx)(n.p,{children:"Algorithm negotiation in Olocus Protocol allows peers to establish secure communication channels while preventing downgrade attacks and ensuring mutual algorithm support. The system combines cryptographic preferences with security policies to select the best available algorithms for each connection."}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"algorithm-categories",children:"Algorithm Categories"}),"\n",(0,t.jsx)(n.p,{children:"The protocol supports negotiation for four algorithm categories:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signature Algorithms"})," - Digital signature schemes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hash Algorithms"})," - Cryptographic hash functions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Key Exchange"})," - Key agreement protocols"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Encryption"})," - Symmetric encryption ciphers"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"security-levels",children:"Security Levels"}),"\n",(0,t.jsx)(n.p,{children:"All algorithms are classified by NIST-equivalent security levels:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level128"}),": 128-bit security (minimum acceptable)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level192"}),": 192-bit security"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level256"}),": 256-bit security (recommended)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PQLevel3"}),": Post-quantum Level 3 (AES-192 equivalent)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PQLevel5"}),": Post-quantum Level 5 (AES-256 equivalent)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"algorithm-status",children:"Algorithm Status"}),"\n",(0,t.jsx)(n.p,{children:"Algorithms have a lifecycle status indicating their suitability:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recommended"}),": Preferred for new deployments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Acceptable"}),": Usable but not preferred"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deprecating"}),": Being phased out (with sunset date)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deprecated"}),": Should not be used"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Broken"}),": MUST NOT be used"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"supported-algorithms",children:"Supported Algorithms"}),"\n",(0,t.jsx)(n.h3,{id:"signature-algorithms",children:"Signature Algorithms"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Security Level"}),(0,t.jsx)(n.th,{children:"Quantum Resistant"}),(0,t.jsx)(n.th,{children:"Status"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Ed25519"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Ed448"}),(0,t.jsx)(n.td,{children:"Level256"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Dilithium3"}),(0,t.jsx)(n.td,{children:"PQLevel3"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Dilithium5"}),(0,t.jsx)(n.td,{children:"PQLevel5"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Falcon-512"}),(0,t.jsx)(n.td,{children:"PQLevel3"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"hash-algorithms",children:"Hash Algorithms"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Security Level"}),(0,t.jsx)(n.th,{children:"Quantum Resistant"}),(0,t.jsx)(n.th,{children:"Status"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"SHA-256"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"SHA-384"}),(0,t.jsx)(n.td,{children:"Level192"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"SHA-512"}),(0,t.jsx)(n.td,{children:"Level256"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"SHA3-256"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"BLAKE3"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"key-exchange-algorithms",children:"Key Exchange Algorithms"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Security Level"}),(0,t.jsx)(n.th,{children:"Quantum Resistant"}),(0,t.jsx)(n.th,{children:"Status"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"X25519"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"X448"}),(0,t.jsx)(n.td,{children:"Level256"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Kyber768"}),(0,t.jsx)(n.td,{children:"PQLevel3"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Kyber1024"}),(0,t.jsx)(n.td,{children:"PQLevel5"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"encryption-algorithms",children:"Encryption Algorithms"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Algorithm"}),(0,t.jsx)(n.th,{children:"Security Level"}),(0,t.jsx)(n.th,{children:"Quantum Resistant"}),(0,t.jsx)(n.th,{children:"Status"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"AES-256-GCM"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"AES-128-GCM"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"ChaCha20-Poly1305"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Recommended"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"XChaCha20-Poly1305"}),(0,t.jsx)(n.td,{children:"Level128"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Acceptable"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"negotiation-process",children:"Negotiation Process"}),"\n",(0,t.jsx)(n.h3,{id:"1-preference-declaration",children:"1. Preference Declaration"}),"\n",(0,t.jsx)(n.p,{children:"Each peer creates signed algorithm preferences:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct AlgorithmPreferences {\n    /// Ordered preference list (best first)\n    pub signature_algorithms: Vec<AlgorithmId>,\n    pub hash_algorithms: Vec<AlgorithmId>,\n    pub key_exchange_algorithms: Vec<AlgorithmId>,\n    pub encryption_algorithms: Vec<AlgorithmId>,\n    \n    /// Security constraints\n    pub min_security_level: SecurityLevel,\n    pub allow_deprecated: bool,\n    \n    /// Protocol version bounds\n    pub protocol_version: u16,\n    pub min_protocol_version: u16,\n    pub max_protocol_version: u16,\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-preference-signing",children:"2. Preference Signing"}),"\n",(0,t.jsx)(n.p,{children:"Preferences are cryptographically signed to prevent tampering:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct SignedAlgorithmPreferences {\n    pub preferences: AlgorithmPreferences,\n    pub signature: Vec<u8>,      // 64 bytes\n    pub signer_key: Vec<u8>,     // 32 bytes  \n    pub timestamp: i64,          // Unix timestamp\n    pub nonce: Vec<u8>,          // Replay protection\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-algorithm-selection",children:"3. Algorithm Selection"}),"\n",(0,t.jsx)(n.p,{children:"The negotiation algorithm follows these steps:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate preferences"}),": Verify signatures and timestamps"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Check protocol versions"}),": Ensure compatibility"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Apply security minimums"}),": Filter by security level"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Select common algorithms"}),": Choose from intersection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rank by preferences"}),": Use initiator's preference order"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generate transcript"}),": Create negotiation record"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Example negotiation\nlet result = negotiate_algorithms(\n    &initiator_preferences,\n    &responder_preferences,\n    &security_requirements\n)?;\n\n// Result contains selected algorithms\nlet selected = NegotiationResult {\n    signature_algorithm: AlgorithmId::Ed25519,\n    hash_algorithm: AlgorithmId::Sha256,\n    key_exchange_algorithm: AlgorithmId::X25519,\n    encryption_algorithm: AlgorithmId::Aes256Gcm,\n    security_level: SecurityLevel::Level128,\n    protocol_version: 1,\n    negotiation_transcript: vec![...], // For handshake binding\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"security-requirements",children:"Security Requirements"}),"\n",(0,t.jsx)(n.h3,{id:"minimum-security-policies",children:"Minimum Security Policies"}),"\n",(0,t.jsx)(n.p,{children:"Organizations can enforce minimum security requirements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct SecurityRequirements {\n    /// Minimum acceptable security level\n    pub min_security_level: SecurityLevel,\n    \n    /// Require post-quantum algorithms\n    pub require_post_quantum: bool,\n    \n    /// Algorithms that MUST NOT be used\n    pub forbidden_algorithms: HashSet<AlgorithmId>,\n    \n    /// Required algorithms (at least one must be supported)\n    pub required_algorithms: Vec<AlgorithmId>,\n    \n    /// Minimum protocol version\n    pub min_protocol_version: u16,\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"algorithm-deprecation",children:"Algorithm Deprecation"}),"\n",(0,t.jsx)(n.p,{children:"The protocol tracks algorithm lifecycle and deprecation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct AlgorithmMetadata {\n    pub id: AlgorithmId,\n    pub security_level: SecurityLevel,\n    pub status: AlgorithmStatus,\n    pub quantum_resistant: bool,\n    pub performance_rating: u8,    // 1-10 scale\n    pub introduced_version: String,\n    pub deprecated_version: Option<String>,\n    pub references: Vec<String>,   // RFCs, papers, etc.\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"downgrade-protection",children:"Downgrade Protection"}),"\n",(0,t.jsx)(n.p,{children:"The negotiation includes multiple layers of downgrade protection:"}),"\n",(0,t.jsx)(n.h3,{id:"1-protocol-version-checking",children:"1. Protocol Version Checking"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"if peer_version < min_protocol_version {\n    return Err(Error::ProtocolVersionTooOld);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-signed-preferences",children:"2. Signed Preferences"}),"\n",(0,t.jsx)(n.p,{children:"Algorithm preferences are signed to prevent tampering during transit."}),"\n",(0,t.jsx)(n.h3,{id:"3-strict-ordering",children:"3. Strict Ordering"}),"\n",(0,t.jsx)(n.p,{children:"The initiator's preference order is authoritative to prevent preference manipulation."}),"\n",(0,t.jsx)(n.h3,{id:"4-negotiation-commitment",children:"4. Negotiation Commitment"}),"\n",(0,t.jsx)(n.p,{children:"All offered algorithms are cryptographically committed in the negotiation transcript."}),"\n",(0,t.jsx)(n.h3,{id:"5-minimum-security-requirements",children:"5. Minimum Security Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Security policies enforce baseline algorithm strength requirements."}),"\n",(0,t.jsx)(n.h3,{id:"6-forbidden-algorithm-lists",children:"6. Forbidden Algorithm Lists"}),"\n",(0,t.jsx)(n.p,{children:"Explicitly blocked algorithms cannot be negotiated."}),"\n",(0,t.jsx)(n.h3,{id:"7-handshake-transcript-binding",children:"7. Handshake Transcript Binding"}),"\n",(0,t.jsx)(n.p,{children:"The negotiation transcript MUST be included in subsequent handshake messages."}),"\n",(0,t.jsx)(n.h2,{id:"post-quantum-transition",children:"Post-Quantum Transition"}),"\n",(0,t.jsx)(n.p,{children:"The protocol supports gradual migration to post-quantum cryptography:"}),"\n",(0,t.jsx)(n.h3,{id:"hybrid-mode",children:"Hybrid Mode"}),"\n",(0,t.jsx)(n.p,{children:"Combine classical and post-quantum algorithms:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Example hybrid preferences\nlet hybrid_prefs = AlgorithmPreferences {\n    signature_algorithms: vec![\n        AlgorithmId::Dilithium3,     // PQ first choice\n        AlgorithmId::Ed25519,        // Classical fallback\n    ],\n    key_exchange_algorithms: vec![\n        AlgorithmId::Kyber768,       // PQ first choice\n        AlgorithmId::X25519,         // Classical fallback\n    ],\n    min_security_level: SecurityLevel::PQLevel3,\n    // ...\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"migration-strategies",children:"Migration Strategies"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Additive"}),": Add PQ algorithms alongside classical"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hybrid"}),": Combine classical + PQ in single operation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Full PQ"}),": Require only post-quantum algorithms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Classical Only"}),": Legacy mode for older systems"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,t.jsx)(n.h3,{id:"basic-negotiation",children:"Basic Negotiation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use olocus_core::algorithm_negotiation::*;\n\n// Create preferences\nlet initiator_prefs = AlgorithmPreferences {\n    signature_algorithms: vec![AlgorithmId::Ed25519],\n    hash_algorithms: vec![AlgorithmId::Sha256],\n    key_exchange_algorithms: vec![AlgorithmId::X25519],\n    encryption_algorithms: vec![AlgorithmId::Aes256Gcm],\n    min_security_level: SecurityLevel::Level128,\n    allow_deprecated: false,\n    protocol_version: 1,\n    min_protocol_version: 1,\n    max_protocol_version: 1,\n};\n\n// Sign preferences\nlet signed_prefs = sign_algorithm_preferences(\n    &initiator_prefs,\n    &signing_key,\n    &nonce\n)?;\n\n// Perform negotiation\nlet result = negotiate_algorithms(\n    &signed_prefs,\n    &responder_signed_prefs,\n    &security_requirements\n)?;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"enterprise-security-policy",children:"Enterprise Security Policy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Define organizational security requirements\nlet enterprise_policy = SecurityRequirements {\n    min_security_level: SecurityLevel::Level192,\n    require_post_quantum: true,\n    forbidden_algorithms: [\n        AlgorithmId::Md5,        // Broken\n        AlgorithmId::Sha1,       // Deprecated\n    ].into(),\n    required_algorithms: vec![\n        AlgorithmId::Dilithium3,  // Must support PQ\n    ],\n    min_protocol_version: 2,      // Require v2+\n};\n\n// This will reject connections that don't meet policy\nlet result = negotiate_with_policy(\n    &initiator_prefs,\n    &responder_prefs, \n    &enterprise_policy\n)?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Negotiation can fail for various security reasons:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub enum NegotiationError {\n    NoCommonAlgorithm,           // No mutual support\n    PeerSecurityTooLow,          // Below minimum level\n    ProtocolVersionMismatch,     // Version incompatibility\n    RequiredAlgorithmMissing,    // Policy violation\n    PostQuantumRequired,         // PQ mandate not met\n    DowngradeAttemptDetected,    // Security attack\n    PreferencesTooOld,           // Timestamp validation\n    InvalidSignature,            // Tampered preferences\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"algorithm-performance-ratings",children:"Algorithm Performance Ratings"}),"\n",(0,t.jsx)(n.p,{children:"Each algorithm includes a performance rating (1-10 scale) to guide selection when multiple options meet security requirements:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ed25519"}),": 9/10 (very fast)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dilithium3"}),": 6/10 (moderate)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SHA-256"}),": 8/10 (fast)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BLAKE3"}),": 10/10 (fastest)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AES-256-GCM"}),": 9/10 (hardware accelerated)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ChaCha20-Poly1305"}),": 7/10 (software optimized)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"negotiation-caching",children:"Negotiation Caching"}),"\n",(0,t.jsx)(n.p,{children:"Successful negotiations can be cached to avoid repeated cryptographic operations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Cache negotiation result for this peer combination\nlet cache_key = (initiator_key, responder_key, preferences_hash);\nnegotiation_cache.insert(cache_key, result.clone());\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,t.jsx)(n.h3,{id:"negotiation-test-vectors",children:"Negotiation Test Vectors"}),"\n",(0,t.jsx)(n.p,{children:"The protocol includes comprehensive test vectors covering:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Successful negotiations"}),"\n",(0,t.jsx)(n.li,{children:"Security policy enforcement"}),"\n",(0,t.jsx)(n.li,{children:"Downgrade attack prevention"}),"\n",(0,t.jsx)(n.li,{children:"Post-quantum transitions"}),"\n",(0,t.jsx)(n.li,{children:"Error conditions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"interoperability-testing",children:"Interoperability Testing"}),"\n",(0,t.jsx)(n.p,{children:"Cross-implementation testing ensures consistent negotiation behavior across different Olocus Protocol implementations."}),"\n",(0,t.jsx)(n.h2,{id:"future-extensions",children:"Future Extensions"}),"\n",(0,t.jsx)(n.p,{children:"The negotiation framework is designed for extensibility:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"New algorithm categories"})," (e.g., zero-knowledge proofs)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enhanced security levels"})," (e.g., quantum security levels)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic algorithm updates"})," (e.g., emergency deprecation)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance-based selection"})," (e.g., bandwidth-constrained environments)"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);