"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5287],{3744:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"extensions/creating-extensions","title":"Creating Custom Extensions","description":"Learn how to build your own extensions for the Olocus Protocol using the standard enum/trait hybrid pattern.","source":"@site/docs/extensions/creating-extensions.md","sourceDirName":"extensions","slug":"/extensions/creating-extensions","permalink":"/docs/extensions/creating-extensions","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/creating-extensions.md","tags":[],"version":"current","lastUpdatedAt":1764937116000,"sidebarPosition":100,"frontMatter":{"id":"creating-extensions","title":"Creating Custom Extensions","sidebar_position":100},"sidebar":"docsSidebar","previous":{"title":"Extensions Overview","permalink":"/docs/extensions/overview"}}');var r=t(4848),a=t(8453);const i={id:"creating-extensions",title:"Creating Custom Extensions",sidebar_position:100},o="Creating Custom Extensions",l={},c=[{value:"Extension Architecture",id:"extension-architecture",level:2},{value:"Basic Extension Template",id:"basic-extension-template",level:2},{value:"1. Define Your Payload",id:"1-define-your-payload",level:3},{value:"2. Create the Trait",id:"2-create-the-trait",level:3},{value:"3. Create the Enum",id:"3-create-the-enum",level:3},{value:"4. Define Error Types",id:"4-define-error-types",level:3},{value:"Integration with Core",id:"integration-with-core",level:2},{value:"Using with Measurements",id:"using-with-measurements",level:3},{value:"Creating Blocks",id:"creating-blocks",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Custom Implementations",id:"custom-implementations",level:3},{value:"Composability",id:"composability",level:3},{value:"Testing Your Extension",id:"testing-your-extension",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Follow the Pattern",id:"1-follow-the-pattern",level:3},{value:"2. Document Thoroughly",id:"2-document-thoroughly",level:3},{value:"3. Version Your Payloads",id:"3-version-your-payloads",level:3},{value:"4. Handle Errors Gracefully",id:"4-handle-errors-gracefully",level:3},{value:"5. Provide Defaults",id:"5-provide-defaults",level:3},{value:"Publishing Your Extension",id:"publishing-your-extension",level:2},{value:"1. Create a Crate",id:"1-create-a-crate",level:3},{value:"2. Add to Registry",id:"2-add-to-registry",level:3},{value:"3. Document Usage",id:"3-document-usage",level:3},{value:"Example: Weather Extension",id:"example-weather-extension",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"creating-custom-extensions",children:"Creating Custom Extensions"})}),"\n",(0,r.jsx)(n.p,{children:"Learn how to build your own extensions for the Olocus Protocol using the standard enum/trait hybrid pattern."}),"\n",(0,r.jsx)(n.h2,{id:"extension-architecture",children:"Extension Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Every Olocus extension follows the same pattern:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trait"})," for custom implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enum"})," for built-in implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Payload"})," type implementing ",(0,r.jsx)(n.code,{children:"BlockPayload"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error"})," types in the standard range"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-extension-template",children:"Basic Extension Template"}),"\n",(0,r.jsx)(n.h3,{id:"1-define-your-payload",children:"1. Define Your Payload"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{BlockPayload, Error};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct MyExtensionPayload {\n    pub data: String,\n    pub timestamp: u64,\n    pub metadata: HashMap<String, String>,\n}\n\nimpl BlockPayload for MyExtensionPayload {\n    fn to_bytes(&self) -> Vec<u8> {\n        serde_json::to_vec(self).unwrap()\n    }\n    \n    fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {\n        serde_json::from_slice(bytes)\n            .map_err(|e| Error::Deserialization(e.to_string()))\n    }\n    \n    fn payload_type() -> u32 {\n        0x8000  // Choose unique ID in 0x8000-0xFFFF range\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-create-the-trait",children:"2. Create the Trait"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use async_trait::async_trait;\n\n#[async_trait]\npub trait MyExtensionProcessor: Send + Sync {\n    /// Process data according to your extension's logic\n    async fn process(\n        &self,\n        input: &[u8]\n    ) -> Result<MyExtensionPayload, MyExtensionError>;\n    \n    /// Validate data according to your rules\n    fn validate(&self, payload: &MyExtensionPayload) -> bool;\n    \n    /// Get processor metadata\n    fn metadata(&self) -> ProcessorMetadata;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-create-the-enum",children:"3. Create the Enum"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub enum BuiltInProcessor {\n    /// Basic processor with default settings\n    Basic {\n        timeout: Duration,\n        retry_count: u32,\n    },\n    \n    /// Advanced processor with caching\n    Advanced {\n        cache_size: usize,\n        ttl: Duration,\n        compression: bool,\n    },\n    \n    /// High-performance processor\n    Performance {\n        thread_pool_size: usize,\n        queue_capacity: usize,\n    },\n    \n    // Future: QuantumProcessor\n    // Future: AIProcessor\n}\n\n#[async_trait]\nimpl MyExtensionProcessor for BuiltInProcessor {\n    async fn process(&self, input: &[u8]) -> Result<MyExtensionPayload, MyExtensionError> {\n        match self {\n            Self::Basic { timeout, retry_count } => {\n                // Implementation\n            },\n            Self::Advanced { cache_size, ttl, compression } => {\n                // Implementation\n            },\n            Self::Performance { thread_pool_size, queue_capacity } => {\n                // Implementation\n            },\n        }\n    }\n    \n    fn validate(&self, payload: &MyExtensionPayload) -> bool {\n        // Validation logic\n        true\n    }\n    \n    fn metadata(&self) -> ProcessorMetadata {\n        ProcessorMetadata {\n            name: "Built-in Processor".to_string(),\n            version: "1.0.0".to_string(),\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-define-error-types",children:"4. Define Error Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum MyExtensionError {\n    #[error("Processing failed: {0}")]\n    ProcessingFailed(String),\n    \n    #[error("Validation failed: {0}")]\n    ValidationFailed(String),\n    \n    #[error("Timeout after {0:?}")]\n    Timeout(Duration),\n    \n    #[error("Resource exhausted: {0}")]\n    ResourceExhausted(String),\n}\n\n// Map to protocol error codes (choose range like 2000-2099)\nimpl MyExtensionError {\n    pub fn error_code(&self) -> u16 {\n        match self {\n            Self::ProcessingFailed(_) => 2000,\n            Self::ValidationFailed(_) => 2001,\n            Self::Timeout(_) => 2002,\n            Self::ResourceExhausted(_) => 2003,\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-core",children:"Integration with Core"}),"\n",(0,r.jsx)(n.h3,{id:"using-with-measurements",children:"Using with Measurements"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{Measurement, Value, Uncertainty};\n\nimpl MyExtensionPayload {\n    /// Convert to measurement for standardized handling\n    pub fn to_measurement(&self) -> Measurement {\n        Measurement {\n            value: Value::Object(\n                self.metadata.iter()\n                    .map(|(k, v)| (k.clone(), Value::String(v.clone())))\n                    .collect()\n            ),\n            uncertainty: Uncertainty::Unknown,\n            provenance: Provenance::default(),\n            validity: ValidityWindow::perpetual(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-blocks",children:"Creating Blocks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{Block, generate_key, current_timestamp};\n\nfn create_extension_block(\n    processor: &impl MyExtensionProcessor,\n    input: &[u8],\n    previous: Option<&Block<impl BlockPayload>>,\n) -> Result<Block<MyExtensionPayload>, Error> {\n    // Process data\n    let payload = processor.process(input).await?;\n    \n    // Validate\n    if !processor.validate(&payload) {\n        return Err(Error::ValidationFailed);\n    }\n    \n    // Create block\n    let key = generate_key();\n    let block = if let Some(prev) = previous {\n        Block::next(prev, payload, &key, current_timestamp())?\n    } else {\n        Block::genesis(payload, &key, current_timestamp())\n    };\n    \n    Ok(block)\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,r.jsx)(n.h3,{id:"custom-implementations",children:"Custom Implementations"}),"\n",(0,r.jsx)(n.p,{children:"Users can implement the trait for their specific needs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct CustomProcessor {\n    api_endpoint: String,\n    auth_token: String,\n}\n\n#[async_trait]\nimpl MyExtensionProcessor for CustomProcessor {\n    async fn process(&self, input: &[u8]) -> Result<MyExtensionPayload, MyExtensionError> {\n        // Call external API\n        let response = reqwest::Client::new()\n            .post(&self.api_endpoint)\n            .bearer_auth(&self.auth_token)\n            .body(input.to_vec())\n            .send()\n            .await?;\n        \n        // Parse response into payload\n        Ok(MyExtensionPayload {\n            data: response.text().await?,\n            timestamp: current_timestamp(),\n            metadata: HashMap::new(),\n        })\n    }\n    \n    // Other trait methods...\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"composability",children:"Composability"}),"\n",(0,r.jsx)(n.p,{children:"Extensions can work together:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_location::LocationPayload;\nuse olocus_trust::TrustAttestation;\n\npub struct EnhancedPayload {\n    pub base: MyExtensionPayload,\n    pub location: Option<LocationPayload>,\n    pub attestation: Option<TrustAttestation>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-your-extension",children:"Testing Your Extension"}),"\n",(0,r.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_payload_serialization() {\n        let payload = MyExtensionPayload {\n            data: "test".to_string(),\n            timestamp: 1234567890,\n            metadata: HashMap::new(),\n        };\n        \n        let bytes = payload.to_bytes();\n        let decoded = MyExtensionPayload::from_bytes(&bytes).unwrap();\n        \n        assert_eq!(payload.data, decoded.data);\n    }\n    \n    #[tokio::test]\n    async fn test_processor() {\n        let processor = BuiltInProcessor::Basic {\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n        };\n        \n        let input = b"test data";\n        let result = processor.process(input).await.unwrap();\n        \n        assert!(processor.validate(&result));\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[tokio::test]\nasync fn test_full_workflow() {\n    // Create processor\n    let processor = BuiltInProcessor::Advanced {\n        cache_size: 100,\n        ttl: Duration::from_secs(60),\n        compression: true,\n    };\n    \n    // Process data\n    let payload = processor.process(b"input").await.unwrap();\n    \n    // Create block\n    let key = generate_key();\n    let block = Block::genesis(payload, &key, current_timestamp());\n    \n    // Verify block\n    verify_block(&block, None).unwrap();\n    \n    // Encode/decode\n    let wire = WireFormat::json();\n    let encoded = wire.encode(&block).unwrap();\n    let decoded: Block<MyExtensionPayload> = wire.decode(&encoded).unwrap();\n    \n    assert_eq!(block.hash(), decoded.hash());\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-follow-the-pattern",children:"1. Follow the Pattern"}),"\n",(0,r.jsx)(n.p,{children:"Always use the enum/trait hybrid pattern for maximum flexibility."}),"\n",(0,r.jsx)(n.h3,{id:"2-document-thoroughly",children:"2. Document Thoroughly"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// My extension for processing special data.\n/// \n/// # Example\n/// ```\n/// use my_extension::*;\n/// \n/// let processor = BuiltInProcessor::Basic { \n///     timeout: Duration::from_secs(30),\n///     retry_count: 3 \n/// };\n/// ```\npub struct MyExtension;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-version-your-payloads",children:"3. Version Your Payloads"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Serialize, Deserialize)]\n#[serde(tag = "version")]\npub enum MyPayload {\n    #[serde(rename = "1.0")]\n    V1 { data: String },\n    \n    #[serde(rename = "2.0")]\n    V2 { data: String, metadata: HashMap<String, String> },\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-handle-errors-gracefully",children:"4. Handle Errors Gracefully"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl From<reqwest::Error> for MyExtensionError {\n    fn from(err: reqwest::Error) -> Self {\n        MyExtensionError::ProcessingFailed(err.to_string())\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-provide-defaults",children:"5. Provide Defaults"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl Default for BuiltInProcessor {\n    fn default() -> Self {\n        Self::Basic {\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"publishing-your-extension",children:"Publishing Your Extension"}),"\n",(0,r.jsx)(n.h3,{id:"1-create-a-crate",children:"1. Create a Crate"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[package]\nname = "olocus-myextension"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\nolocus-core = { git = "https://codeberg.org/olocus/protocol.git" }\nserde = { version = "1.0", features = ["derive"] }\nasync-trait = "0.1"\nthiserror = "1.0"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-add-to-registry",children:"2. Add to Registry"}),"\n",(0,r.jsx)(n.p,{children:"Submit a PR to add your extension to the official registry."}),"\n",(0,r.jsx)(n.h3,{id:"3-document-usage",children:"3. Document Usage"}),"\n",(0,r.jsx)(n.p,{children:"Provide clear examples and documentation for users."}),"\n",(0,r.jsx)(n.h2,{id:"example-weather-extension",children:"Example: Weather Extension"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example of a weather data extension:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_core::*;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct WeatherPayload {\n    pub temperature: Measurement,\n    pub humidity: Measurement,\n    pub pressure: Measurement,\n    pub location: Value,\n    pub timestamp: u64,\n}\n\nimpl BlockPayload for WeatherPayload {\n    fn to_bytes(&self) -> Vec<u8> {\n        serde_json::to_vec(self).unwrap()\n    }\n    \n    fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {\n        serde_json::from_slice(bytes)\n            .map_err(|e| Error::Deserialization(e.to_string()))\n    }\n    \n    fn payload_type() -> u32 {\n        0x8001  // Weather extension type\n    }\n}\n\nimpl WeatherPayload {\n    pub fn new(\n        temp_celsius: f64,\n        humidity_percent: f64,\n        pressure_hpa: f64,\n        lat: f64,\n        lon: f64,\n    ) -> Self {\n        Self {\n            temperature: Measurement {\n                value: Value::Float(temp_celsius),\n                uncertainty: Uncertainty::Gaussian { std_dev: 0.1 },\n                provenance: Provenance::default(),\n                validity: ValidityWindow::new(\n                    current_timestamp() as i64,\n                    Some((current_timestamp() + 3600) as i64)\n                ),\n            },\n            humidity: Measurement {\n                value: Value::Float(humidity_percent),\n                uncertainty: Uncertainty::Gaussian { std_dev: 1.0 },\n                provenance: Provenance::default(),\n                validity: ValidityWindow::new(\n                    current_timestamp() as i64,\n                    Some((current_timestamp() + 3600) as i64)\n                ),\n            },\n            pressure: Measurement {\n                value: Value::Float(pressure_hpa),\n                uncertainty: Uncertainty::Gaussian { std_dev: 0.5 },\n                provenance: Provenance::default(),\n                validity: ValidityWindow::new(\n                    current_timestamp() as i64,\n                    Some((current_timestamp() + 3600) as i64)\n                ),\n            },\n            location: Value::Point2D {\n                lat: Coordinate::latitude_to_fixed(lat),\n                lon: Coordinate::longitude_to_fixed(lon),\n            },\n            timestamp: current_timestamp(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./overview",children:"Browse Existing Extensions"})," - Learn from existing implementations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/svailsa/olocus-website/discussions",children:"Join the Community"})," - Share your extension"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../api/core",children:"API Reference"})," - Deep dive into protocol details"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);