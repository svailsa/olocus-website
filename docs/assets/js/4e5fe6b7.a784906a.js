"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[9443],{1590:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/wire-format","title":"Wire Format","description":"The Olocus Protocol wire format is designed for flexibility, efficiency, and extensibility. It supports multiple encoding formats and compression methods, allowing applications to choose the optimal representation for their specific needs.","source":"@site/docs/concepts/wire-format.md","sourceDirName":"concepts","slug":"/concepts/wire-format","permalink":"/docs/concepts/wire-format","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/concepts/wire-format.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"wire-format","title":"Wire Format","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Cryptographic Primitives","permalink":"/docs/concepts/cryptographic-primitives"},"next":{"title":"Algorithm Negotiation","permalink":"/docs/concepts/algorithm-negotiation"}}');var r=s(4848),t=s(8453);const o={id:"wire-format",title:"Wire Format",sidebar_position:1},l="Wire Format",d={},c=[{value:"Supported Formats",id:"supported-formats",level:2},{value:"Encoding Formats",id:"encoding-formats",level:3},{value:"Compression Methods",id:"compression-methods",level:3},{value:"WireFormat Structure",id:"wireformat-structure",level:2},{value:"Creating Wire Formats",id:"creating-wire-formats",level:3},{value:"Content Type Negotiation",id:"content-type-negotiation",level:2},{value:"Compression Suffixes",id:"compression-suffixes",level:3},{value:"Content Type Parsing",id:"content-type-parsing",level:3},{value:"Encoding Process",id:"encoding-process",level:2},{value:"Binary Format (Default)",id:"binary-format-default",level:2},{value:"Block Structure",id:"block-structure",level:3},{value:"Header Layout (86 bytes)",id:"header-layout-86-bytes",level:3},{value:"JSON Format",id:"json-format",level:2},{value:"Hex Encoding",id:"hex-encoding",level:3},{value:"MessagePack Format",id:"messagepack-format",level:2},{value:"Protobuf Format",id:"protobuf-format",level:2},{value:"SSZ Format",id:"ssz-format",level:2},{value:"Compression Methods",id:"compression-methods-1",level:2},{value:"Zstd Compression",id:"zstd-compression",level:3},{value:"LZ4 Compression",id:"lz4-compression",level:3},{value:"Gzip Compression",id:"gzip-compression",level:3},{value:"No Compression",id:"no-compression",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Format Selection Guidelines",id:"format-selection-guidelines",level:2},{value:"When to Use Each Format",id:"when-to-use-each-format",level:3},{value:"Decision Matrix",id:"decision-matrix",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Memory Management",id:"memory-management",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Version Compatibility",id:"version-compatibility",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"wire-format",children:"Wire Format"})}),"\n",(0,r.jsx)(n.p,{children:"The Olocus Protocol wire format is designed for flexibility, efficiency, and extensibility. It supports multiple encoding formats and compression methods, allowing applications to choose the optimal representation for their specific needs."}),"\n",(0,r.jsx)(n.h2,{id:"supported-formats",children:"Supported Formats"}),"\n",(0,r.jsx)(n.p,{children:"The protocol supports 5 encoding formats and 4 compression methods, providing 20 possible combinations:"}),"\n",(0,r.jsx)(n.h3,{id:"encoding-formats",children:"Encoding Formats"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary"})," (default) - Compact binary representation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JSON"})," - Human-readable for debugging and web APIs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MessagePack"})," - Efficient binary serialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protobuf"})," - Language-neutral structured data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SSZ"})," - Simple Serialize (Ethereum-compatible)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"compression-methods",children:"Compression Methods"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"None"})," (default) - No compression"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zstd"})," - Best compression ratio, good speed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LZ4"})," - Fastest compression, good ratio"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gzip"})," - Widely supported, moderate compression"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"wireformat-structure",children:"WireFormat Structure"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"WireFormat"})," type combines encoding and compression:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct WireFormat {\n    pub encoding: EncodingFormat,\n    pub compression: CompressionMethod,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-wire-formats",children:"Creating Wire Formats"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Common presets\nlet binary = WireFormat::binary();        // Binary + None\nlet json = WireFormat::json();            // JSON + None\nlet msgpack = WireFormat::msgpack();      // MessagePack + None\n\n// Custom combinations\nlet compressed_binary = WireFormat::new(\n    EncodingFormat::Binary, \n    CompressionMethod::Zstd\n);\nlet compressed_json = WireFormat::new(\n    EncodingFormat::Json, \n    CompressionMethod::Gzip\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"content-type-negotiation",children:"Content Type Negotiation"}),"\n",(0,r.jsx)(n.p,{children:"Each wire format has an associated content type for HTTP-style negotiation:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Format"}),(0,r.jsx)(n.th,{children:"Content Type"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Binary"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"application/x-olocus-block"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"application/json"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MessagePack"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"application/x-msgpack"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Protobuf"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"application/x-protobuf"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"SSZ"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"application/x-ssz"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"compression-suffixes",children:"Compression Suffixes"}),"\n",(0,r.jsx)(n.p,{children:"Compression is indicated by adding a suffix:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zstd"}),": ",(0,r.jsx)(n.code,{children:"application/x-olocus-block+zstd"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LZ4"}),": ",(0,r.jsx)(n.code,{children:"application/json+lz4"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gzip"}),": ",(0,r.jsx)(n.code,{children:"application/x-msgpack+gzip"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"content-type-parsing",children:"Content Type Parsing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Parse content type to wire format\nlet format = WireFormat::from_content_type("application/json+gzip")?;\nassert_eq!(format.encoding, EncodingFormat::Json);\nassert_eq!(format.compression, CompressionMethod::Gzip);\n\n// Generate content type from format\nlet content_type = format.content_type(); // "application/json+gzip"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"encoding-process",children:"Encoding Process"}),"\n",(0,r.jsx)(n.p,{children:"The wire format encoding follows a two-stage process:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serialize"})," the block using the specified encoding format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compress"})," the serialized data using the specified compression method"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Encode a block\nlet block = /* your block */;\nlet format = WireFormat::new(EncodingFormat::Json, CompressionMethod::Zstd);\nlet encoded = format.encode(&block)?;\n\n// Decode back to block\nlet decoded: Block<MyPayload> = format.decode(&encoded)?;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"binary-format-default",children:"Binary Format (Default)"}),"\n",(0,r.jsx)(n.p,{children:"The binary format is the most compact and efficient:"}),"\n",(0,r.jsx)(n.h3,{id:"block-structure",children:"Block Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Header (86B)    \u2502 Payload \u2502 Signature \u2502 Public Key  \u2502\n\u2502                 \u2502 (var)   \u2502 (64B)     \u2502 (32B)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"header-layout-86-bytes",children:"Header Layout (86 bytes)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Offset  Field          Size   Description\n0-1     version        2B     Protocol version (little-endian)\n2-9     index          8B     Block index (little-endian)\n10-17   timestamp      8B     Unix timestamp (little-endian)\n18-49   previous       32B    Previous block hash\n50-81   payload_hash   32B    SHA-256 of payload\n82-85   payload_type   4B     Payload type ID (little-endian)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"json-format",children:"JSON Format"}),"\n",(0,r.jsx)(n.p,{children:"JSON format provides human-readable representation for debugging and web APIs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "header": {\n    "version": 1,\n    "index": 42,\n    "timestamp": 1640995200,\n    "previous": "a1b2c3d4...",\n    "payload_hash": "e5f6789a...",\n    "payload_type": 1001\n  },\n  "payload": "SGVsbG8gV29ybGQ=",\n  "signature": "3045022100...",\n  "public_key": "04ab5c8f..."\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hex-encoding",children:"Hex Encoding"}),"\n",(0,r.jsx)(n.p,{children:"Binary fields (hashes, signatures, keys) are hex-encoded for readability:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[serde(with = "hex")]\nsignature: [u8; 64],\n'})}),"\n",(0,r.jsx)(n.h2,{id:"messagepack-format",children:"MessagePack Format"}),"\n",(0,r.jsx)(n.p,{children:"MessagePack provides efficient binary serialization while maintaining structure:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Smaller than JSON"}),": Typically 20-50% size reduction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Faster parsing"}),": No text parsing overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema evolution"}),": Better support for optional fields"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type preservation"}),": Maintains integer vs string distinction"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// MessagePack is more compact than JSON\nlet json_size = json_format.encode(&block)?.len();\nlet msgpack_size = msgpack_format.encode(&block)?.len();\nassert!(msgpack_size < json_size);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"protobuf-format",children:"Protobuf Format"}),"\n",(0,r.jsx)(n.p,{children:"Simplified protobuf-style encoding using length-delimited fields:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Field 1: Header\n  tag: 1 (1 byte)\n  length: header_len (4 bytes LE)\n  data: header_bytes\n\nField 2: Payload\n  tag: 2 (1 byte)\n  length: payload_len (4 bytes LE)\n  data: payload_bytes\n\nField 3: Signature\n  tag: 3 (1 byte)\n  length: 64 (4 bytes LE)\n  data: signature_bytes\n\nField 4: Public Key\n  tag: 4 (1 byte)  \n  length: 32 (4 bytes LE)\n  data: pubkey_bytes\n"})}),"\n",(0,r.jsx)(n.h2,{id:"ssz-format",children:"SSZ Format"}),"\n",(0,r.jsx)(n.p,{children:"SSZ (Simple Serialize) is compatible with Ethereum ecosystem:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fixed-length encoding"}),": Predictable size calculations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Merkle tree friendly"}),": Easy to compute hash trees"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-copy deserialization"}),": Direct memory mapping possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Canonical representation"}),": Same data always produces same bytes"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The Olocus binary format is SSZ-compatible by design."}),"\n",(0,r.jsx)(n.h2,{id:"compression-methods-1",children:"Compression Methods"}),"\n",(0,r.jsx)(n.h3,{id:"zstd-compression",children:"Zstd Compression"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best overall compression"}),": Typically 60-80% size reduction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Good speed"}),": Faster than gzip, slower than LZ4"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tunable"}),": Compression levels 1-22"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional dependency"}),": Falls back to LZ4 if unavailable"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'// Enable zstd feature in Cargo.toml\n[features]\ncompression-zstd = ["zstd"]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"lz4-compression",children:"LZ4 Compression"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fastest compression"}),": Minimal CPU overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Good compression"}),": 40-60% size reduction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always available"}),": No optional dependencies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Streaming friendly"}),": Low memory usage"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"gzip-compression",children:"Gzip Compression"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Widely supported"}),": Available everywhere"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Moderate compression"}),": Similar to zstd level 3"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Slower"}),": More CPU intensive than zstd/LZ4"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HTTP compatible"}),": Standard Content-Encoding"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"no-compression",children:"No Compression"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fastest processing"}),": Zero compression overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Largest size"}),": Full data transmission"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low latency"}),": No compression/decompression delay"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple debugging"}),": Raw data inspection"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.p,{children:"Typical performance on modern hardware with 1KB payloads:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Format + Compression"}),(0,r.jsx)(n.th,{children:"Encode (ops/sec)"}),(0,r.jsx)(n.th,{children:"Decode (ops/sec)"}),(0,r.jsx)(n.th,{children:"Size (bytes)"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Binary + None"}),(0,r.jsx)(n.td,{children:"50,000"}),(0,r.jsx)(n.td,{children:"60,000"}),(0,r.jsx)(n.td,{children:"1,200"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Binary + LZ4"}),(0,r.jsx)(n.td,{children:"45,000"}),(0,r.jsx)(n.td,{children:"55,000"}),(0,r.jsx)(n.td,{children:"800"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Binary + Zstd"}),(0,r.jsx)(n.td,{children:"35,000"}),(0,r.jsx)(n.td,{children:"40,000"}),(0,r.jsx)(n.td,{children:"600"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON + None"}),(0,r.jsx)(n.td,{children:"15,000"}),(0,r.jsx)(n.td,{children:"12,000"}),(0,r.jsx)(n.td,{children:"1,800"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"JSON + Gzip"}),(0,r.jsx)(n.td,{children:"12,000"}),(0,r.jsx)(n.td,{children:"10,000"}),(0,r.jsx)(n.td,{children:"900"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"MessagePack + LZ4"}),(0,r.jsx)(n.td,{children:"25,000"}),(0,r.jsx)(n.td,{children:"30,000"}),(0,r.jsx)(n.td,{children:"700"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"format-selection-guidelines",children:"Format Selection Guidelines"}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each-format",children:"When to Use Each Format"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary + None"}),": Default choice for minimal overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary + LZ4"}),": High-throughput applications needing compression"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Binary + Zstd"}),": Storage optimization with acceptable CPU cost"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JSON + None"}),": Debugging, web APIs, human inspection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JSON + Gzip"}),": Web applications needing compression"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MessagePack + LZ4"}),": Efficient structured data with compression"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protobuf + None"}),": Cross-language compatibility"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SSZ + None"}),": Ethereum ecosystem integration"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"decision-matrix",children:"Decision Matrix"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Priority"}),(0,r.jsx)(n.th,{children:"Recommended Format"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Speed"}),(0,r.jsx)(n.td,{children:"Binary + None"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Size"}),(0,r.jsx)(n.td,{children:"Binary + Zstd"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Debug"}),(0,r.jsx)(n.td,{children:"JSON + None"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Web"}),(0,r.jsx)(n.td,{children:"JSON + Gzip"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Cross-platform"}),(0,r.jsx)(n.td,{children:"MessagePack + LZ4"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Ethereum"}),(0,r.jsx)(n.td,{children:"SSZ + None"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.p,{children:"Wire format operations can fail in several ways:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub enum Error {\n    MalformedBlock,      // Invalid structure\n    SerializationError,  // Encoding failure\n    // ... other errors\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero-copy where possible"}),": Binary format allows direct access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Streaming compression"}),": Large payloads don't require full buffering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bounded allocations"}),": Maximum sizes prevent DoS attacks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,r.jsx)(n.p,{children:"All wire format operations are thread-safe:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Immutable data"}),": No shared mutable state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pure functions"}),": Encoding/decoding has no side effects"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent access"}),": Multiple threads can encode/decode simultaneously"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"version-compatibility",children:"Version Compatibility"}),"\n",(0,r.jsx)(n.p,{children:"Wire formats maintain backward compatibility:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Format versioning"}),": Each encoding method has version identifier"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Graceful degradation"}),": Newer features ignored by older parsers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Migration support"}),": Tools to convert between formats"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feature detection"}),": Clients can negotiate supported formats"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);