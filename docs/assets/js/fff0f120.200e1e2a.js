"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[392],{3473:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"api/measurement-api","title":"Measurement API","description":"The Universal Measurement Foundation provides the core primitives for representing any measured data in the Olocus Protocol. It follows a three-layer architecture: Core defines structural types, Schema defines validity constraints, and Domain defines semantic meaning.","source":"@site/docs/api/measurement-api.md","sourceDirName":"api","slug":"/api/measurement-api","permalink":"/docs/api/measurement-api","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/api/measurement-api.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":1,"frontMatter":{"id":"measurement-api","title":"Measurement API","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Cryptographic Operations","permalink":"/docs/api/cryptographic-operations"},"next":{"title":"Wire Format API","permalink":"/docs/api/wire-format-api"}}');var i=t(4848),r=t(8453);const l={id:"measurement-api",title:"Measurement API",sidebar_position:1},s="Measurement API",o={},u=[{value:"Core Types",id:"core-types",level:2},{value:"Value Enum",id:"value-enum",level:3},{value:"Temporal Types",id:"temporal-types",level:3},{value:"Text and Binary",id:"text-and-binary",level:3},{value:"Identifiers",id:"identifiers",level:3},{value:"Collections",id:"collections",level:3},{value:"Spatial Types",id:"spatial-types",level:3},{value:"Ranges and Patterns",id:"ranges-and-patterns",level:3},{value:"References and Database Records",id:"references-and-database-records",level:3},{value:"Extension Points",id:"extension-points",level:3},{value:"Value Type Checking and Conversion",id:"value-type-checking-and-conversion",level:2},{value:"Measurement Structure",id:"measurement-structure",level:2},{value:"Uncertainty Models",id:"uncertainty-models",level:2},{value:"Uncertainty Operations",id:"uncertainty-operations",level:3},{value:"Provenance Tracking",id:"provenance-tracking",level:2},{value:"Source Types",id:"source-types",level:3},{value:"Validity Windows",id:"validity-windows",level:2},{value:"Validity Decay",id:"validity-decay",level:3},{value:"Coordinate Utilities",id:"coordinate-utilities",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Value Constructors",id:"value-constructors",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"measurement-api",children:"Measurement API"})}),"\n",(0,i.jsx)(n.p,{children:"The Universal Measurement Foundation provides the core primitives for representing any measured data in the Olocus Protocol. It follows a three-layer architecture: Core defines structural types, Schema defines validity constraints, and Domain defines semantic meaning."}),"\n",(0,i.jsx)(n.h2,{id:"core-types",children:"Core Types"}),"\n",(0,i.jsx)(n.h3,{id:"value-enum",children:"Value Enum"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Value"})," enum represents the structural types supported by the protocol. It contains 36 variants covering all fundamental data types across multiple categories:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::Value;\n\n// === Absence ===\nlet none_val = Value::None;\n\n// === Primitives ===\nlet bool_val = Value::Bool(true);\nlet int_val = Value::Int(42);              // Signed 64-bit integer\nlet uint_val = Value::UInt(100);           // Unsigned 64-bit integer  \nlet float_val = Value::Float(3.14159);     // 64-bit floating point\n\n// Decimal for exact precision (value \xd7 10^-scale)\nlet price = Value::Decimal {\n    value: 1999,    // $19.99 stored as 1999 cents\n    scale: 2,       // 2 decimal places\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"temporal-types",children:"Temporal Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Timestamps\nlet unix_timestamp = Value::Timestamp(1609459200); // 2021-01-01 00:00:00 UTC\nlet precise_time = Value::TimestampNanos {\n    seconds: 1609459200,\n    nanos: 123456789,\n};\n\n// Duration\nlet duration = Value::Duration(3600_000_000_000); // 1 hour in nanoseconds\n\n// Structured time\nlet date = Value::Date {\n    year: 2023,\n    month: 12,\n    day: 25,\n};\n\nlet time = Value::Time {\n    hour: 14,\n    minute: 30,\n    second: 0,\n    nanos: 0,\n};\n\nlet datetime = Value::DateTime {\n    year: 2023,\n    month: 12,\n    day: 25,\n    hour: 14,\n    minute: 30,\n    second: 0,\n    nanos: 0,\n    tz_offset_minutes: -480, // PST (-8 hours)\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"text-and-binary",children:"Text and Binary"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// === Text ===\nlet text = Value::String("Hello, Olocus!".to_string());\n\n// === Binary ===\nlet data = Value::Bytes(vec![0x01, 0x02, 0x03, 0x04]);\nlet hash256 = Value::Hash256([0u8; 32]); // SHA-256 hash (common case)\nlet hash512 = Value::Hash512([0u8; 64]); // SHA-512 hash\n\n// === Structured ===\n// Raw JSON document for maximum flexibility\nlet json_doc = Value::Json(br#"{"temperature": 23.5, "unit": "celsius"}"#.to_vec());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"identifiers",children:"Identifiers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// === UUID (Universally Unique Identifier) ===\nlet uuid_bytes = Value::UUID([0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, \n                              0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]);\n\n// Helper constructors\nlet uuid_from_int = Value::uuid_from_u128(0x123456789ABCDEF0123456789ABCDEF0);\nlet uuid_from_array = Value::uuid([1u8; 16]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"collections",children:"Collections"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::collections::{BTreeMap, BTreeSet};\n\n// Arrays (ordered)\nlet readings: Value = vec![1_i64, 2, 3, 4, 5].into();\n\n// Objects (key-value maps)\nlet mut sensor_data = BTreeMap::new();\nsensor_data.insert("temperature".to_string(), Value::Float(23.5));\nsensor_data.insert("humidity".to_string(), Value::Float(65.0));\nsensor_data.insert("unit".to_string(), Value::String("celsius".to_string()));\nlet obj = Value::Object(sensor_data);\n\n// Sets (unique values)\nlet mut tags = BTreeSet::new();\ntags.insert(Value::String("temperature".to_string()));\ntags.insert(Value::String("outdoor".to_string()));\nlet set = Value::Set(tags);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"spatial-types",children:"Spatial Types"}),"\n",(0,i.jsx)(n.p,{children:"All spatial coordinates use fixed-point representation (degrees \xd7 10^7) for ~1cm precision and cross-platform determinism:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::{Value, Coordinate};\n\n// 2D Points\nlet san_francisco = Value::point2d(37.7749, -122.4194);\n// Stored as: Point2D { lat: 377749000, lon: -1224194000 }\n\n// 3D Points with altitude\nlet mount_everest = Value::point3d(27.9881, 86.9250, 8848.86);\n\n// Bounding boxes\nlet bbox = Value::BoundingBox {\n    min_lat: Coordinate::latitude_to_fixed(37.7),\n    min_lon: Coordinate::longitude_to_fixed(-122.5),\n    max_lat: Coordinate::latitude_to_fixed(37.8),\n    max_lon: Coordinate::longitude_to_fixed(-122.4),\n};\n\n// GeoJSON-style geometries\nlet path = Value::linestring(&[\n    (37.7749, -122.4194),  // Start\n    (37.7849, -122.4094),  // End\n]);\n\nlet polygon = Value::polygon(\n    &[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)], // Exterior\n    &[], // No holes\n);\n\nlet multipoint = Value::multipoint(&[\n    (37.7749, -122.4194),\n    (37.7849, -122.4094),\n]);\n\n// Multi-geometry collections\nlet multilinestring = Value::multilinestring(vec![\n    vec![(377749000, -1224194000), (377849000, -1224094000)], // Line 1 (fixed-point)\n    vec![(378000000, -1224000000), (378100000, -1223900000)], // Line 2 (fixed-point)\n]);\n\nlet multipolygon = Value::multipolygon(vec![\n    // Polygon 1: exterior ring, interior holes\n    (vec![(0, 0), (1000000, 0), (1000000, 1000000), (0, 1000000), (0, 0)], vec![]),\n    // Polygon 2: with a hole\n    (vec![(2000000, 0), (3000000, 0), (3000000, 1000000), (2000000, 1000000), (2000000, 0)], \n     vec![vec![(2200000, 200000), (2800000, 200000), (2800000, 800000), (2200000, 800000), (2200000, 200000)]]),\n]);\n\nlet geometry_collection = Value::geometry_collection(vec![\n    Value::point2d(37.7749, -122.4194),\n    Value::linestring(&[(37.7749, -122.4194), (37.7751, -122.4180)]),\n    Value::polygon(&[(0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)], &[]),\n]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ranges-and-patterns",children:"Ranges and Patterns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// === Ranges ===\n// Range with start and end bounds (default: start inclusive, end exclusive)\nlet age_range = Value::range(Value::Int(18), Value::Int(65)); // [18, 65)\nlet price_range = Value::range_inclusive(Value::Float(10.0), Value::Float(100.0)); // [10.0, 100.0]\n\n// Complex ranges with mixed types\nlet time_range = Value::range(\n    Value::Timestamp(1609459200), // 2021-01-01 00:00:00 UTC\n    Value::Timestamp(1640995200), // 2022-01-01 00:00:00 UTC\n);\n\n// === Patterns ===\n// Regular expressions for pattern matching\nlet phone_pattern = Value::regex(r"^\\d{3}-\\d{3}-\\d{4}$");\nlet email_pattern = Value::regex(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");\nlet postal_code = Value::regex(r"^\\d{5}(-\\d{4})?$");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"references-and-database-records",children:"References and Database Records"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// === Block References ===\nlet block_ref = Value::BlockRef([0u8; 32]); // Hash of another block\n\n// Schema references\nlet schema_ref = Value::SchemaRef {\n    namespace: "health".to_string(),\n    name: "heart_rate".to_string(),\n    version: "1.2.0".to_string(),\n};\n\n// === Database Records (SurrealDB-style) ===\nlet user_record = Value::record("users", "user_12345");\nlet sensor_record = Value::record("sensors", "temp_sensor_001");\nlet measurement_record = Value::record("measurements", "measurement_abc123");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"extension-points",children:"Extension Points"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// === Custom Extension Types ===\n// Domain-specific types not covered by core Value variants\nlet custom_extension = Value::Extension {\n    type_id: 0x8001,              // Custom type identifier (0x8000-0xFFFF)\n    data: vec![0x01, 0x02, 0x03], // Serialized custom data\n};\n\n// Extensions can register custom serialization for their type_ids\nlet biometric_data = Value::Extension {\n    type_id: 0x9001,              // Biometric data type\n    data: custom_biometric_serializer.encode(&fingerprint_data),\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"value-type-checking-and-conversion",children:"Value Type Checking and Conversion"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let value = Value::Int(42);\n\n// Type checking (built-in predicates)\nassert!(value.is_numeric());\nassert!(!value.is_temporal());\nassert!(!value.is_spatial());\nassert!(!value.is_geometry());\nassert!(!value.is_collection());\nassert_eq!(value.type_name(), "Int");\n\n// Safe conversion (extract methods)\nif let Some(i) = value.as_int() {\n    println!("Integer value: {}", i);\n}\n\n// New extraction methods for additional types\nlet uuid_val = Value::uuid([1u8; 16]);\nif let Some(uuid_bytes) = uuid_val.as_uuid() {\n    println!("UUID: {:?}", uuid_bytes);\n}\n\nlet regex_val = Value::regex(r"^\\d+$");\nif let Some(pattern) = regex_val.as_regex() {\n    println!("Regex pattern: {}", pattern);\n}\n\nlet record_val = Value::record("users", "123");\nif let Some((table, id)) = record_val.as_record() {\n    println!("Record: {}:{}", table, id);\n}\n\nlet range_val = Value::range(Value::Int(1), Value::Int(10));\nif let Some((start, end, start_inc, end_inc)) = range_val.as_range() {\n    println!("Range: {}{}{}{}", \n             if start_inc { "[" } else { "(" },\n             start.as_int().unwrap(),\n             end.as_int().unwrap(),\n             if end_inc { "]" } else { ")" });\n}\n\nlet line_val = Value::linestring(&[(37.7749, -122.4194), (37.7751, -122.4180)]);\nif let Some(points) = line_val.as_linestring() {\n    println!("LineString with {} points", points.len());\n}\n\nlet poly_val = Value::polygon(&[(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0), (0.0, 0.0)], &[]);\nif let Some((exterior, holes)) = poly_val.as_polygon() {\n    println!("Polygon: {} exterior points, {} holes", exterior.len(), holes.len());\n}\n\nlet multipoint_val = Value::multipoint(&[(37.7749, -122.4194), (37.7751, -122.4180)]);\nif let Some(points) = multipoint_val.as_multipoint() {\n    println!("MultiPoint with {} points", points.len());\n}\n\n// Pattern matching (comprehensive example)\nmatch value {\n    Value::None => println!("No value"),\n    Value::Bool(b) => println!("Boolean: {}", b),\n    Value::Int(i) => println!("Integer: {}", i),\n    Value::UInt(u) => println!("Unsigned integer: {}", u),\n    Value::Float(f) => println!("Float: {}", f),\n    Value::Decimal { value, scale } => println!("Decimal: {} \xd7 10^-{}", value, scale),\n    Value::String(s) => println!("String: {}", s),\n    Value::Bytes(b) => println!("Bytes: {} bytes", b.len()),\n    Value::Hash256(h) => println!("Hash256: {:?}", &h[0..4]),\n    Value::Hash512(h) => println!("Hash512: {:?}", &h[0..4]),\n    Value::UUID(u) => println!("UUID: {:?}", u),\n    Value::Timestamp(t) => println!("Timestamp: {}", t),\n    Value::TimestampNanos { seconds, nanos } => println!("Timestamp: {}.{:09}", seconds, nanos),\n    Value::Duration(d) => println!("Duration: {} ns", d),\n    Value::Date { year, month, day } => println!("Date: {}-{:02}-{:02}", year, month, day),\n    Value::Time { hour, minute, second, nanos } => println!("Time: {:02}:{:02}:{:02}.{:09}", hour, minute, second, nanos),\n    Value::DateTime { year, month, day, hour, minute, second, nanos, tz_offset_minutes } => {\n        println!("DateTime: {}-{:02}-{:02}T{:02}:{:02}:{:02}.{:09}+{:02}:{:02}", \n                 year, month, day, hour, minute, second, nanos, \n                 tz_offset_minutes / 60, tz_offset_minutes % 60);\n    },\n    Value::Array(a) => println!("Array: {} elements", a.len()),\n    Value::Object(o) => println!("Object: {} fields", o.len()),\n    Value::Set(s) => println!("Set: {} unique values", s.len()),\n    Value::Point2D { lat, lon } => println!("Point2D: ({}, {})", lat, lon),\n    Value::Point3D { lat, lon, alt } => println!("Point3D: ({}, {}, {})", lat, lon, alt),\n    Value::BoundingBox { min_lat, min_lon, max_lat, max_lon } => {\n        println!("BoundingBox: ({},{}) to ({},{})", min_lat, min_lon, max_lat, max_lon);\n    },\n    Value::LineString(points) => println!("LineString: {} points", points.len()),\n    Value::Polygon { exterior, holes } => println!("Polygon: {} exterior, {} holes", exterior.len(), holes.len()),\n    Value::MultiPoint(points) => println!("MultiPoint: {} points", points.len()),\n    Value::MultiLineString(lines) => println!("MultiLineString: {} lines", lines.len()),\n    Value::MultiPolygon(polygons) => println!("MultiPolygon: {} polygons", polygons.len()),\n    Value::GeometryCollection(geoms) => println!("GeometryCollection: {} geometries", geoms.len()),\n    Value::BlockRef(hash) => println!("BlockRef: {:?}", &hash[0..4]),\n    Value::SchemaRef { namespace, name, version } => println!("SchemaRef: {}:{}@{}", namespace, name, version),\n    Value::Record { table, id } => println!("Record: {}:{}", table, id),\n    Value::Range { start, end, start_inclusive, end_inclusive } => {\n        println!("Range: {}{:?},{:?}{}", \n                 if *start_inclusive { "[" } else { "(" },\n                 start, end,\n                 if *end_inclusive { "]" } else { ")" });\n    },\n    Value::Regex(pattern) => println!("Regex: {}", pattern),\n    Value::Json(data) => println!("JSON: {} bytes", data.len()),\n    Value::Extension { type_id, data } => println!("Extension: type 0x{:04X}, {} bytes", type_id, data.len()),\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"measurement-structure",children:"Measurement Structure"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"Measurement"})," combines a value with uncertainty, provenance, and validity context:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::{Measurement, Uncertainty, Provenance, Source, ValidityWindow};\n\n// Basic measurement\nlet heart_rate = Measurement::new(Value::Int(72))\n    .with_uncertainty(Uncertainty::gaussian(2.0))\n    .with_source(Source::Sensor {\n        device_id: [0u8; 32],\n        sensor_type: 0x0001, // Heart rate monitor\n        calibration_id: None,\n    })\n    .with_validity(ValidityWindow::seconds(60)); // Valid for 1 minute\n\n// Check if measurement is currently valid\nif heart_rate.is_valid_now() {\n    println!("Measurement is still valid");\n}\n\n// Get validity factor (0.0 to 1.0)\nlet validity = heart_rate.validity_factor_now();\nprintln!("Validity: {:.2}", validity);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"uncertainty-models",children:"Uncertainty Models"}),"\n",(0,i.jsx)(n.p,{children:"Different domains represent uncertainty differently:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Gaussian/normal distribution (physics, engineering)\nlet temp_uncertainty = Uncertainty::gaussian(0.5); // \xb10.5\xb0C std dev\n\n// Confidence intervals (statistics)\nlet gps_uncertainty = Uncertainty::interval(10.0, 0.95); // \xb110m with 95% confidence\n\n// Circular uncertainty (angles, bearings)\nlet compass_uncertainty = Uncertainty::Circular { kappa: 5.0 }; // von Mises distribution\n\n// Discrete categories (classification)\nlet weather_uncertainty = Uncertainty::Categorical {\n    probabilities: vec![\n        (0, 0.7), // 70% chance sunny\n        (1, 0.2), // 20% chance cloudy  \n        (2, 0.1), // 10% chance rainy\n    ],\n};\n\n// Simple confidence score\nlet ai_uncertainty = Uncertainty::confidence(0.85); // 85% confident\n\n// Exact value (theoretical)\nlet math_constant = Uncertainty::Exact;\n\n// Unknown uncertainty (discouraged)\nlet unknown = Uncertainty::Unknown;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"uncertainty-operations",children:"Uncertainty Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Convert any uncertainty to confidence level\nlet confidence = uncertainty.to_confidence(); // 0.0 to 1.0\n\n// Check if uncertainty is quantified\nif uncertainty.is_quantified() {\n    println!("Uncertainty is properly quantified");\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"provenance-tracking",children:"Provenance Tracking"}),"\n",(0,i.jsx)(n.p,{children:"Provenance tracks where measurements came from and how they were processed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Sensor source\nlet sensor_prov = Provenance::sensor([1u8; 32], 0x0001);\n\n// Self-reported source\nlet self_reported = Provenance::self_reported([2u8; 32]);\n\n// Derived from other measurements\nlet derived = Provenance::derived(\n    0x1001, // Algorithm ID\n    vec![[3u8; 32], [4u8; 32]], // Input measurement hashes\n);\n\n// Add transformations\nuse olocus_core::measure::{Transformation, TransformationOp};\n\nlet filtered = sensor_prov.with_transformation(Transformation {\n    operation: TransformationOp::Filter {\n        algorithm: 0x2001,\n        parameters: vec![],\n    },\n    timestamp: 1609459200,\n    actor: [5u8; 32],\n    input_hash: [6u8; 32],\n});\n\nprintln!("Transformations applied: {}", filtered.transformation_count());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"source-types",children:"Source Types"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Hardware sensor\nSource::Sensor {\n    device_id: [0u8; 32],\n    sensor_type: 0x0001,\n    calibration_id: Some([1u8; 32]),\n}\n\n// Computed from other data\nSource::Derived {\n    algorithm_id: 0x1001,\n    inputs: vec![[2u8; 32], [3u8; 32]],\n    parameters: Some(vec![0x01, 0x02]),\n}\n\n// Human input\nSource::SelfReported {\n    reporter_id: [4u8; 32],\n    method: 0x0001, // Web form, voice, etc.\n}\n\n// External oracle\nSource::Oracle {\n    oracle_id: [5u8; 32],\n    query_id: Some([6u8; 32]),\n}\n\n// Consensus of multiple sources\nSource::Consensus {\n    sources: vec![[7u8; 32], [8u8; 32], [9u8; 32]],\n    method: 0x0001, // Majority vote, weighted average, etc.\n    agreement: 0.85, // 85% agreement\n}\n\n// Unknown (discouraged - heavily penalized in trust calculations)\nSource::Unknown\n"})}),"\n",(0,i.jsx)(n.h2,{id:"validity-windows",children:"Validity Windows"}),"\n",(0,i.jsx)(n.p,{children:"Control when measurements are considered valid:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::time::{SystemTime, UNIX_EPOCH};\n\nlet now = SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap()\n    .as_secs();\n\n// Valid for specific duration\nlet short_term = ValidityWindow::new(now, Some(300)); // 5 minutes\n\n// Valid for N seconds from now\nlet real_time = ValidityWindow::seconds(60); // 1 minute\n\n// Indefinitely valid (use with caution)\nlet permanent = ValidityWindow::indefinite();\n\n// With exponential decay\nlet decaying = ValidityWindow::decaying(3600, 1800); // 1 hour validity, 30 min half-life\n\n// Check validity\nassert!(short_term.is_valid_at(now + 100)); // Valid\nassert!(!short_term.is_valid_at(now + 400)); // Expired\n\n// Get validity factor with decay\nlet factor = decaying.validity_at(now + 1800); // Should be ~0.5 (one half-life)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"validity-decay",children:"Validity Decay"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::ValidityDecay;\n\n// Step function (binary: valid/invalid)\nValidityDecay::StepFunction\n\n// Linear decay from 1.0 to 0.0\nValidityDecay::Linear\n\n// Exponential decay with half-life\nValidityDecay::Exponential { half_life: 1800 } // 30 minutes\n\n// Custom decay curve (domain-specific)\nValidityDecay::Custom {\n    curve_id: 0x1001,\n    parameters: vec![],\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"coordinate-utilities",children:"Coordinate Utilities"}),"\n",(0,i.jsx)(n.p,{children:"Fixed-point coordinate system for deterministic spatial calculations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::Coordinate;\n\n// Constants\nassert_eq!(Coordinate::SCALE, 10_000_000.0); // 10^7 scale factor\nassert_eq!(Coordinate::MAX_LAT, 900_000_000); // 90\xb0 \xd7 10^7\nassert_eq!(Coordinate::EARTH_RADIUS_M, 6_371_000.0);\n\n// Conversions\nlet lat_fixed = Coordinate::latitude_to_fixed(37.7749290);  // 377749290\nlet lat_degrees = Coordinate::fixed_to_latitude(377749290); // 37.7749290\n\n// Validation\nCoordinate::validate(377749290, -1224193580).unwrap(); // San Francisco\n\n// Distance calculation (Haversine formula)\nlet distance = Coordinate::haversine_distance(\n    377749290, -1224193580, // San Francisco\n    407589500, -739444400,  // New York\n); // Returns distance in meters\n\n// Bearing calculation (0-360 degrees, 0=north)\nlet bearing = Coordinate::bearing(\n    377749290, -1224193580, // From SF\n    407589500, -739444400,  // To NYC\n); // Returns ~78.5 degrees (northeast)\n\n// Destination point calculation\nlet (dest_lat, dest_lon) = Coordinate::destination_point(\n    377749290, -1224193580, // Start: San Francisco\n    90.0,      // Bearing: due east\n    1000.0,    // Distance: 1km\n);\n\n// Coordinate offsets\nlet lat_offset = Coordinate::meters_to_lat_offset(1000.0); // 1km north\nlet lon_offset = Coordinate::meters_to_lon_offset(1000.0, 377749290); // 1km east at SF latitude\n"})}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::*;\nuse std::collections::BTreeMap;\n\nfn main() -> Result<(), MeasurementError> {\n    // Create a comprehensive measurement\n    let mut sensor_data = BTreeMap::new();\n    sensor_data.insert("temperature".to_string(), Value::Float(23.5));\n    sensor_data.insert("humidity".to_string(), Value::Float(65.0));\n    sensor_data.insert("location".to_string(), Value::point2d(37.7749, -122.4194));\n    \n    let measurement = Measurement::new(Value::Object(sensor_data))\n        .with_uncertainty(Uncertainty::Interval {\n            lower_bound: -0.5,\n            upper_bound: 0.5,\n            confidence: 0.95,\n        })\n        .with_provenance(\n            Provenance::sensor([1u8; 32], 0x0001)\n                .with_transformation(Transformation {\n                    operation: TransformationOp::Filter {\n                        algorithm: 0x2001,\n                        parameters: vec![0x01, 0x02],\n                    },\n                    timestamp: 1609459200,\n                    actor: [2u8; 32],\n                    input_hash: [3u8; 32],\n                })\n                .with_attestation(Attestation {\n                    attestor: [4u8; 32],\n                    claim: AttestationClaim::Witnessed,\n                    signature: [0u8; 64],\n                    timestamp: 1609459200,\n                })\n        )\n        .with_validity(ValidityWindow::decaying(3600, 1800));\n\n    // Validate measurement\n    if measurement.is_valid_now() {\n        println!("Measurement is valid");\n        println!("Confidence: {:.2}", measurement.uncertainty.to_confidence());\n        println!("Sources: {}", measurement.provenance.attestation_count());\n        println!("Validity: {:.2}", measurement.validity_factor_now());\n    }\n\n    // Serialize for storage/transmission\n    let json = serde_json::to_string(&measurement).unwrap();\n    println!("Serialized measurement: {}", json);\n\n    // Deserialize\n    let deserialized: Measurement = serde_json::from_str(&json).unwrap();\n    assert_eq!(measurement, deserialized);\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"value-constructors",children:"Value Constructors"}),"\n",(0,i.jsx)(n.p,{children:"Convenience methods for creating common values:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// === From Rust Primitives ===\nlet v1: Value = 42_i64.into();      // Int\nlet v2: Value = "hello".into();     // String\nlet v3: Value = true.into();        // Bool\nlet v4: Value = 3.14_f64.into();    // Float\nlet v5: Value = 100_u64.into();     // UInt\nlet v6: Value = vec![1_i64, 2, 3].into(); // Array\n\n// === Binary Data ===\nlet bytes: Value = vec![0x01, 0x02, 0x03].into(); // Bytes\nlet hash256: Value = [0u8; 32].into();             // Hash256\n\n// === Temporal Constructors ===\nlet timestamp = Value::Timestamp(1609459200);\nlet precise_time = Value::TimestampNanos { \n    seconds: 1609459200, \n    nanos: 123456789 \n};\nlet duration = Value::Duration(3600_000_000_000); // 1 hour in ns\n\nlet date = Value::Date { year: 2023, month: 12, day: 25 };\nlet time = Value::Time { hour: 14, minute: 30, second: 0, nanos: 0 };\nlet datetime = Value::DateTime {\n    year: 2023, month: 12, day: 25,\n    hour: 14, minute: 30, second: 0, nanos: 0,\n    tz_offset_minutes: -480, // PST\n};\n\n// === Spatial Constructors ===\nlet point = Value::point2d(37.7749, -122.4194);\nlet point3d = Value::point3d(37.7749, -122.4194, 100.0);\n\n// Simple geometry\nlet line = Value::linestring(&[(0.0, 0.0), (1.0, 1.0)]);\nlet polygon = Value::polygon(\n    &[(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0), (0.0, 0.0)],\n    &[] // No holes\n);\nlet multipoint = Value::multipoint(&[(0.0, 0.0), (1.0, 1.0)]);\n\n// Complex geometry (fixed-point coordinates)\nlet multiline = Value::multilinestring(vec![\n    vec![(0, 0), (1000000, 1000000)],        // Line 1\n    vec![(2000000, 0), (3000000, 1000000)],  // Line 2\n]);\n\nlet multipoly = Value::multipolygon(vec![\n    (vec![(0, 0), (1000000, 0), (1000000, 1000000), (0, 1000000), (0, 0)], vec![])\n]);\n\nlet geom_collection = Value::geometry_collection(vec![\n    Value::point2d(37.7749, -122.4194),\n    Value::linestring(&[(37.7749, -122.4194), (37.7751, -122.4180)]),\n]);\n\n// === Identifier Constructors ===\nlet uuid1 = Value::uuid([1u8; 16]);\nlet uuid2 = Value::uuid_from_u128(0x123456789ABCDEF0123456789ABCDEF0);\n\n// === Pattern and Range Constructors ===\nlet regex = Value::regex(r"^\\d{3}-\\d{3}-\\d{4}$");\nlet range = Value::range(Value::Int(1), Value::Int(100));          // [1, 100)\nlet range_inc = Value::range_inclusive(Value::Int(1), Value::Int(100)); // [1, 100]\n\n// === Database Reference Constructors ===\nlet user_record = Value::record("users", "user_123");\nlet sensor_record = Value::record("sensors", "temp_001");\n\n// === Structured Data ===\nlet json_doc = Value::Json(br#"{"temperature": 23.5, "unit": "celsius"}"#.to_vec());\n\n// Collections\nlet mut object = std::collections::BTreeMap::new();\nobject.insert("temperature".to_string(), Value::Float(23.5));\nobject.insert("location".to_string(), Value::point2d(37.7749, -122.4194));\nlet sensor_reading = Value::Object(object);\n\nlet mut tags = std::collections::BTreeSet::new();\ntags.insert(Value::String("outdoor".to_string()));\ntags.insert(Value::String("temperature".to_string()));\nlet tag_set = Value::Set(tags);\n\n// === Decimal Constructor ===\nlet price = Value::Decimal { value: 1999, scale: 2 }; // $19.99\n\n// === Block and Schema References ===\nlet block_ref = Value::BlockRef([0u8; 32]);\nlet schema_ref = Value::SchemaRef {\n    namespace: "health".to_string(),\n    name: "heart_rate".to_string(),\n    version: "1.2.0".to_string(),\n};\n\n// === Extension Constructor ===\nlet custom_extension = Value::Extension {\n    type_id: 0x8001,\n    data: vec![0x01, 0x02, 0x03, 0x04],\n};\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::MeasurementError;\n\n// Value validation\nmatch Coordinate::validate(lat_fixed, lon_fixed) {\n    Ok(()) => println!("Coordinates valid"),\n    Err(MeasurementError::ValueOutOfRange { min, max, actual }) => {\n        println!("Coordinate out of range: {} not in {}..{}", actual, min, max);\n    }\n    Err(e) => println!("Other error: {}", e),\n}\n\n// Uncertainty validation\nlet uncertainty = Uncertainty::confidence(1.5); // Invalid: > 1.0\n// This would create ConfidenceOutOfRange error\n\n// Provenance validation\nlet circular = Provenance::derived(0x1001, vec![[1u8; 32]]);\n// If input hash references a measurement derived from this one,\n// would create CircularProvenance error\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed-Point Arithmetic"}),": Spatial calculations use integer math for speed and determinism"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Efficient Serialization"}),": Values serialize to compact binary or JSON format"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory Layout"}),": Enums are optimized for minimal memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Collection Types"}),": BTreeMap/BTreeSet ensure deterministic iteration order"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./core",children:"Core API Overview"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./block-operations",children:"Block Operations API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./wire-format-api",children:"Wire Format API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./error-handling",children:"Error Handling"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var a=t(6540);const i={},r=a.createContext(i);function l(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);