"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[743],{8015:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"architecture/formal-verification","title":"Formal Verification","description":"The Olocus Protocol includes comprehensive formal verification to ensure security properties are mathematically proven rather than just tested. This document outlines the verification approach, tools, and verified properties.","source":"@site/docs/architecture/formal-verification.md","sourceDirName":"architecture","slug":"/architecture/formal-verification","permalink":"/docs/architecture/formal-verification","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/architecture/formal-verification.md","tags":[],"version":"current","lastUpdatedAt":1764941993000,"sidebarPosition":4,"frontMatter":{"id":"formal-verification","title":"Formal Verification","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Security Model","permalink":"/docs/architecture/security-model"},"next":{"title":"Scalability Roadmap","permalink":"/docs/architecture/scalability-roadmap"}}');var t=n(4848),s=n(8453);const l={id:"formal-verification",title:"Formal Verification",sidebar_position:4},o="Formal Verification",c={},a=[{value:"Verification Philosophy",id:"verification-philosophy",level:2},{value:"Why Formal Verification?",id:"why-formal-verification",level:3},{value:"Verification Strategy",id:"verification-strategy",level:3},{value:"Verification Levels",id:"verification-levels",level:2},{value:"FV-L1: Symbolic Protocol Analysis",id:"fv-l1-symbolic-protocol-analysis",level:3},{value:"FV-L2: Implementation Verification",id:"fv-l2-implementation-verification",level:3},{value:"FV-L3: Computational Security",id:"fv-l3-computational-security",level:3},{value:"Core Protocol Properties",id:"core-protocol-properties",level:2},{value:"Chain Integrity Properties",id:"chain-integrity-properties",level:3},{value:"Property FV-CHAIN-01: Hash Continuity",id:"property-fv-chain-01-hash-continuity",level:4},{value:"Property FV-CHAIN-02: Index Monotonicity",id:"property-fv-chain-02-index-monotonicity",level:4},{value:"Property FV-CHAIN-03: Timestamp Ordering",id:"property-fv-chain-03-timestamp-ordering",level:4},{value:"Property FV-CHAIN-04: Payload Integrity",id:"property-fv-chain-04-payload-integrity",level:4},{value:"Property FV-CHAIN-05: Genesis Validity",id:"property-fv-chain-05-genesis-validity",level:4},{value:"Signature Properties",id:"signature-properties",level:3},{value:"Property FV-SIG-01: Signature Validity",id:"property-fv-sig-01-signature-validity",level:4},{value:"Property FV-SIG-02: Non-repudiation",id:"property-fv-sig-02-non-repudiation",level:4},{value:"Property FV-SIG-03: Key Binding (Single-Signer)",id:"property-fv-sig-03-key-binding-single-signer",level:4},{value:"Algorithm Negotiation Properties",id:"algorithm-negotiation-properties",level:3},{value:"Property FV-NEG-01: Downgrade Resistance",id:"property-fv-neg-01-downgrade-resistance",level:4},{value:"Property FV-NEG-02: Preference Authenticity",id:"property-fv-neg-02-preference-authenticity",level:4},{value:"Property FV-NEG-03: Transcript Binding",id:"property-fv-neg-03-transcript-binding",level:4},{value:"Property FV-NEG-04: Freshness",id:"property-fv-neg-04-freshness",level:4},{value:"Property FV-NEG-05: Forbidden Exclusion",id:"property-fv-neg-05-forbidden-exclusion",level:4},{value:"Security Properties",id:"security-properties",level:2},{value:"Authentication Properties",id:"authentication-properties",level:3},{value:"Block Authenticity",id:"block-authenticity",level:4},{value:"Chain Authenticity",id:"chain-authenticity",level:4},{value:"Secrecy Properties",id:"secrecy-properties",level:3},{value:"Private Key Secrecy",id:"private-key-secrecy",level:4},{value:"Nonce Secrecy",id:"nonce-secrecy",level:4},{value:"Agreement Properties",id:"agreement-properties",level:3},{value:"Chain Agreement",id:"chain-agreement",level:4},{value:"Algorithm Agreement",id:"algorithm-agreement",level:4},{value:"Tamarin Models",id:"tamarin-models",level:2},{value:"Core Protocol Model",id:"core-protocol-model",level:3},{value:"Algorithm Negotiation Model",id:"algorithm-negotiation-model",level:3},{value:"Attestation Protocol Model",id:"attestation-protocol-model",level:3},{value:"Implementation Verification",id:"implementation-verification",level:2},{value:"hax Integration",id:"hax-integration",level:3},{value:"Functional Specifications",id:"functional-specifications",level:3},{value:"Verified Properties",id:"verified-properties",level:3},{value:"Verification Artifacts",id:"verification-artifacts",level:2},{value:"Generated Proofs",id:"generated-proofs",level:3},{value:"Machine-Checkable Proofs",id:"machine-checkable-proofs",level:3},{value:"Continuous Verification",id:"continuous-verification",level:2},{value:"CI Integration",id:"ci-integration",level:3},{value:"Automated Checking",id:"automated-checking",level:3},{value:"Verification Limitations",id:"verification-limitations",level:2},{value:"Assumptions",id:"assumptions",level:3},{value:"Scope Limitations",id:"scope-limitations",level:3},{value:"Using Formal Verification",id:"using-formal-verification",level:2},{value:"For Protocol Implementers",id:"for-protocol-implementers",level:3},{value:"For Security Auditors",id:"for-security-auditors",level:3},{value:"For High-Assurance Deployments",id:"for-high-assurance-deployments",level:3},{value:"Future Verification Work",id:"future-verification-work",level:2},{value:"Planned Enhancements",id:"planned-enhancements",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"formal-verification",children:"Formal Verification"})}),"\n",(0,t.jsx)(i.p,{children:"The Olocus Protocol includes comprehensive formal verification to ensure security properties are mathematically proven rather than just tested. This document outlines the verification approach, tools, and verified properties."}),"\n",(0,t.jsx)(i.h2,{id:"verification-philosophy",children:"Verification Philosophy"}),"\n",(0,t.jsx)(i.h3,{id:"why-formal-verification",children:"Why Formal Verification?"}),"\n",(0,t.jsx)(i.p,{children:"Traditional testing can only show the presence of bugs, not their absence. Formal verification provides mathematical proofs that critical security properties hold under all possible conditions."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Mathematical Certainty"}),": Properties are proven, not just tested"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Complete Coverage"}),": All possible execution paths analyzed"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Early Detection"}),": Catches subtle bugs before implementation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Security Confidence"}),": Cryptographic guarantees verified"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Regulatory Compliance"}),": Meets high-assurance requirements"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"verification-strategy",children:"Verification Strategy"}),"\n",(0,t.jsx)(i.p,{children:"The protocol uses a multi-level verification approach:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Level"}),(0,t.jsx)(i.th,{children:"Scope"}),(0,t.jsx)(i.th,{children:"Method"}),(0,t.jsx)(i.th,{children:"Tool"}),(0,t.jsx)(i.th,{children:"Confidence"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"FV-L1"})}),(0,t.jsx)(i.td,{children:"Protocol Logic"}),(0,t.jsx)(i.td,{children:"Symbolic Model"}),(0,t.jsx)(i.td,{children:"Tamarin"}),(0,t.jsx)(i.td,{children:"Dolev-Yao Security"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"FV-L2"})}),(0,t.jsx)(i.td,{children:"Core Implementation"}),(0,t.jsx)(i.td,{children:"Type Verification"}),(0,t.jsx)(i.td,{children:"hax/F*"}),(0,t.jsx)(i.td,{children:"Implementation Correctness"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.strong,{children:"FV-L3"})}),(0,t.jsx)(i.td,{children:"Full System"}),(0,t.jsx)(i.td,{children:"Computational Model"}),(0,t.jsx)(i.td,{children:"CryptoVerif"}),(0,t.jsx)(i.td,{children:"Concrete Security Bounds"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"verification-levels",children:"Verification Levels"}),"\n",(0,t.jsx)(i.h3,{id:"fv-l1-symbolic-protocol-analysis",children:"FV-L1: Symbolic Protocol Analysis"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tool"}),": Tamarin Prover"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Scope"}),": Protocol logic and message flows"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Security Model"}),": Dolev-Yao adversary model"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Adversary controls network completely"}),"\n",(0,t.jsx)(i.li,{children:"Can intercept, modify, replay, and inject messages"}),"\n",(0,t.jsx)(i.li,{children:"Cannot break cryptographic primitives"}),"\n",(0,t.jsx)(i.li,{children:"Perfect cryptography assumption"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Verified Properties"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Protocol correctness"}),"\n",(0,t.jsx)(i.li,{children:"Authentication properties"}),"\n",(0,t.jsx)(i.li,{children:"Secrecy properties"}),"\n",(0,t.jsx)(i.li,{children:"Agreement properties"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"fv-l2-implementation-verification",children:"FV-L2: Implementation Verification"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tool"}),": hax + F*/Coq/Lean"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Scope"}),": Rust implementation verification"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Approach"}),": Extract functional models from Rust code and verify in proof assistants"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Properties"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Type safety"}),"\n",(0,t.jsx)(i.li,{children:"Memory safety"}),"\n",(0,t.jsx)(i.li,{children:"Functional correctness"}),"\n",(0,t.jsx)(i.li,{children:"Absence of runtime errors"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"fv-l3-computational-security",children:"FV-L3: Computational Security"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tool"}),": CryptoVerif/hax integration"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Scope"}),": Full system with concrete security bounds"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Properties"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Computational security assumptions"}),"\n",(0,t.jsx)(i.li,{children:"Concrete attack bounds"}),"\n",(0,t.jsx)(i.li,{children:"Side-channel resistance"}),"\n",(0,t.jsx)(i.li,{children:"Implementation security"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"core-protocol-properties",children:"Core Protocol Properties"}),"\n",(0,t.jsx)(i.h3,{id:"chain-integrity-properties",children:"Chain Integrity Properties"}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-chain-01-hash-continuity",children:"Property FV-CHAIN-01: Hash Continuity"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200i > 0. block[i].previous = Hash(block[i-1])\n"})}),"\n",(0,t.jsx)(i.p,{children:"Every block (except genesis) correctly references the previous block's hash."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma chain_continuity:\n  "All b1 b2 #t1 #t2. \n    ChainLink(b1, b2) @ t1 & \n    Block(b1) @ t1 & \n    Block(b2) @ t2\n    ==> \n    b2.previous = hash(b1)"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-chain-02-index-monotonicity",children:"Property FV-CHAIN-02: Index Monotonicity"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200i. block[i+1].index = block[i].index + 1\n"})}),"\n",(0,t.jsx)(i.p,{children:"Block indices form a monotonic sequence."}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-chain-03-timestamp-ordering",children:"Property FV-CHAIN-03: Timestamp Ordering"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200i. block[i+1].timestamp > block[i].timestamp\n"})}),"\n",(0,t.jsx)(i.p,{children:"Timestamps are strictly increasing."}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-chain-04-payload-integrity",children:"Property FV-CHAIN-04: Payload Integrity"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200b. b.payload_hash = Hash(b.payload)\n"})}),"\n",(0,t.jsx)(i.p,{children:"Payload hashes correctly represent payload contents."}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-chain-05-genesis-validity",children:"Property FV-CHAIN-05: Genesis Validity"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"block[0].index = 0 \u2227 block[0].previous = zeros(32)\n"})}),"\n",(0,t.jsx)(i.p,{children:"Genesis blocks have correct initial values."}),"\n",(0,t.jsx)(i.h3,{id:"signature-properties",children:"Signature Properties"}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-sig-01-signature-validity",children:"Property FV-SIG-01: Signature Validity"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200b. Verify(b.public_key, message(b), b.signature) = true\n"})}),"\n",(0,t.jsx)(i.p,{children:"All blocks have valid signatures."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma signature_validity:\n  "All b #t. ValidBlock(b) @ t ==> \n    (Ex sk #t2. SigningKey(sk) @ t2 & \n     Valid(verify(pk(sk), message(b), b.signature)))"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-sig-02-non-repudiation",children:"Property FV-SIG-02: Non-repudiation"}),"\n",(0,t.jsx)(i.p,{children:"An adversary cannot produce valid signatures without the private key."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma signature_non_repudiation:\n  "All b #t. ValidSignature(b) @ t ==> \n    (Ex sk #t2. Honest(sk) @ t2 & \n     SignedWith(b, sk) @ t2)"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-sig-03-key-binding-single-signer",children:"Property FV-SIG-03: Key Binding (Single-Signer)"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"\u2200b. b.public_key = genesis.public_key\n"})}),"\n",(0,t.jsx)(i.p,{children:"All blocks in a chain signed by the same key."}),"\n",(0,t.jsx)(i.h3,{id:"algorithm-negotiation-properties",children:"Algorithm Negotiation Properties"}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-neg-01-downgrade-resistance",children:"Property FV-NEG-01: Downgrade Resistance"}),"\n",(0,t.jsx)(i.p,{children:"Cannot negotiate an algorithm weaker than the minimum requirement."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma no_downgrade:\n  "not (Ex A B alg #t. \n    Negotiated(A, B, alg) @ t &\n    WeakerThan(alg, MinimumRequirement))"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-neg-02-preference-authenticity",children:"Property FV-NEG-02: Preference Authenticity"}),"\n",(0,t.jsx)(i.p,{children:"Algorithm preferences are cryptographically bound to the signer."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma preference_authenticity:\n  "All prefs sig pk #t. \n    SignedPreferences(prefs, sig, pk) @ t ==>\n    (Ex sk #t2. PrivateKey(sk, pk) @ t2 &\n     SignedBy(prefs, sk) @ t2)"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-neg-03-transcript-binding",children:"Property FV-NEG-03: Transcript Binding"}),"\n",(0,t.jsx)(i.p,{children:"Complete negotiation transcript is cryptographically bound to the session."}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-neg-04-freshness",children:"Property FV-NEG-04: Freshness"}),"\n",(0,t.jsx)(i.p,{children:"Nonces prevent replay of old preferences."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tamarin Specification"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma preference_freshness:\n  "All prefs nonce #t1 #t2.\n    UsedPreference(prefs, nonce) @ t1 &\n    UsedPreference(prefs, nonce) @ t2\n    ==> t1 = t2"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"property-fv-neg-05-forbidden-exclusion",children:"Property FV-NEG-05: Forbidden Exclusion"}),"\n",(0,t.jsx)(i.p,{children:"Blacklisted algorithms are never selected."}),"\n",(0,t.jsx)(i.h2,{id:"security-properties",children:"Security Properties"}),"\n",(0,t.jsx)(i.h3,{id:"authentication-properties",children:"Authentication Properties"}),"\n",(0,t.jsx)(i.h4,{id:"block-authenticity",children:"Block Authenticity"}),"\n",(0,t.jsx)(i.p,{children:"Every valid block was created by the holder of the corresponding private key."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma block_authenticity:\n  "All b pk #t. BlockVerified(b, pk) @ t ==>\n    (Ex #t2. BlockCreated(b, pk) @ t2 & t2 < t)"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"chain-authenticity",children:"Chain Authenticity"}),"\n",(0,t.jsx)(i.p,{children:"Every valid chain was created by a single entity (in single-signer mode)."}),"\n",(0,t.jsx)(i.h3,{id:"secrecy-properties",children:"Secrecy Properties"}),"\n",(0,t.jsx)(i.h4,{id:"private-key-secrecy",children:"Private Key Secrecy"}),"\n",(0,t.jsx)(i.p,{children:"Private keys never leak to the adversary."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma private_key_secrecy:\n  "not (Ex sk #t. K(sk) @ t & PrivateKey(sk))"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"nonce-secrecy",children:"Nonce Secrecy"}),"\n",(0,t.jsx)(i.p,{children:"Fresh nonces remain secret until used."}),"\n",(0,t.jsx)(i.h3,{id:"agreement-properties",children:"Agreement Properties"}),"\n",(0,t.jsx)(i.h4,{id:"chain-agreement",children:"Chain Agreement"}),"\n",(0,t.jsx)(i.p,{children:"Honest parties agree on the same chain structure."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma chain_agreement:\n  "All A B chain #t1 #t2.\n    Accepts(A, chain) @ t1 &\n    Accepts(B, chain) @ t2\n    ==> SameChain(A, B, chain)"\n'})}),"\n",(0,t.jsx)(i.h4,{id:"algorithm-agreement",children:"Algorithm Agreement"}),"\n",(0,t.jsx)(i.p,{children:"Parties agree on the negotiated cryptographic algorithms."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:'lemma algorithm_agreement:\n  "All A B alg #t1 #t2.\n    Negotiated(A, B, alg) @ t1 &\n    Negotiated(B, A, alg) @ t2\n    ==> SameAlgorithm(alg)"\n'})}),"\n",(0,t.jsx)(i.h2,{id:"tamarin-models",children:"Tamarin Models"}),"\n",(0,t.jsx)(i.h3,{id:"core-protocol-model",children:"Core Protocol Model"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"File"}),": ",(0,t.jsx)(i.code,{children:"olocus-fv/models/core/protocol.spthy"})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Key Elements"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Block creation and verification rules"}),"\n",(0,t.jsx)(i.li,{children:"Hash chaining mechanics"}),"\n",(0,t.jsx)(i.li,{children:"Signature generation and verification"}),"\n",(0,t.jsx)(i.li,{children:"Adversary capabilities"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Rules"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-tamarin",children:"rule CreateBlock:\n  [ SigningKey(sk), PreviousBlock(prev) ]\n  --[ BlockCreated(block, pk(sk)), Honest(sk) ]->\n  [ Block(block), Out(block) ]\n\nrule VerifyBlock:\n  [ Block(block), In(block) ]\n  --[ BlockVerified(block, block.public_key) ]->\n  [ ValidBlock(block) ]\n"})}),"\n",(0,t.jsx)(i.h3,{id:"algorithm-negotiation-model",children:"Algorithm Negotiation Model"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"File"}),": ",(0,t.jsx)(i.code,{children:"olocus-fv/models/negotiation/downgrade.spthy"})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Focus"}),": Multi-layer downgrade protection"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Adversary Goals"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Force weak algorithm selection"}),"\n",(0,t.jsx)(i.li,{children:"Replay old preferences"}),"\n",(0,t.jsx)(i.li,{children:"Modify preference ordering"}),"\n",(0,t.jsx)(i.li,{children:"Bypass minimum requirements"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"attestation-protocol-model",children:"Attestation Protocol Model"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"File"}),": ",(0,t.jsx)(i.code,{children:"olocus-fv/models/attestation/spatial.spthy"})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Properties"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Spatial proximity proofs"}),"\n",(0,t.jsx)(i.li,{children:"Temporal overlap verification"}),"\n",(0,t.jsx)(i.li,{children:"Trust establishment"}),"\n",(0,t.jsx)(i.li,{children:"Privacy preservation"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"implementation-verification",children:"Implementation Verification"}),"\n",(0,t.jsx)(i.h3,{id:"hax-integration",children:"hax Integration"}),"\n",(0,t.jsx)(i.p,{children:"The protocol implementation includes hax annotations for extraction to F*:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:"#[hax_lib::requires(self.previous.len() == 32)]\n#[hax_lib::ensures(result.len() == 32)]\npub fn compute_block_hash(&self) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(&self.to_bytes());\n    hasher.finalize().into()\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"functional-specifications",children:"Functional Specifications"}),"\n",(0,t.jsx)(i.p,{children:"Critical functions have formal specifications:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-fstar",children:"val block_verify: block -> public_key -> bool\nrequires\n  valid_block block /\\\n  valid_public_key public_key\nensures fun result ->\n  result = true <==> \n  signature_valid block.signature \n                  (message_of_block block) \n                  public_key\n"})}),"\n",(0,t.jsx)(i.h3,{id:"verified-properties",children:"Verified Properties"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Memory Safety"}),": Rust's type system provides memory safety guarantees that are verified through the type checker."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Functional Correctness"}),": Key algorithms are verified to meet their specifications."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"No Runtime Errors"}),": Absence of panics, overflows, and other runtime failures."]}),"\n",(0,t.jsx)(i.h2,{id:"verification-artifacts",children:"Verification Artifacts"}),"\n",(0,t.jsx)(i.h3,{id:"generated-proofs",children:"Generated Proofs"}),"\n",(0,t.jsx)(i.p,{children:"For each verified property, the system generates:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:'pub struct VerificationArtifact {\n    pub property_id: String,           // e.g., "FV-CHAIN-01"\n    pub tool: String,                  // e.g., "Tamarin 1.8.0"\n    pub model_hash: [u8; 32],          // SHA-256 of model file\n    pub proof_status: ProofStatus,     // Verified, Failed, Timeout\n    pub proof_file: Option<String>,    // Path to proof artifact\n    pub verified_at: Timestamp,\n    pub verifier: String,              // Organization/individual\n}\n\npub enum ProofStatus {\n    Verified,                          // Proof completed successfully\n    Failed { reason: String },         // Proof failed with reason\n    Timeout { duration_ms: u64 },      // Proof timed out\n    Unknown,                           // Status not determined\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"machine-checkable-proofs",children:"Machine-Checkable Proofs"}),"\n",(0,t.jsx)(i.p,{children:"All proofs are machine-checkable and can be independently verified:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Tamarin"}),": Generates proof trees in internal format"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"F"}),"*: Produces type derivations and proof terms"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Coq"}),": Creates proof objects in Gallina"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Lean"}),": Generates proof terms in dependent type theory"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"continuous-verification",children:"Continuous Verification"}),"\n",(0,t.jsx)(i.h3,{id:"ci-integration",children:"CI Integration"}),"\n",(0,t.jsx)(i.p,{children:"Verification is integrated into the continuous integration pipeline:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-yaml",children:"# .github/workflows/verification.yml\nname: Formal Verification\n\non: [push, pull_request]\n\njobs:\n  tamarin:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install Tamarin\n        run: |\n          wget https://tamarin-prover.github.io/tamarin-linux\n          chmod +x tamarin-linux\n      - name: Verify Protocol Models\n        run: |\n          ./tamarin-linux prove olocus-fv/models/**/*.spthy\n"})}),"\n",(0,t.jsx)(i.h3,{id:"automated-checking",children:"Automated Checking"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Model Consistency"}),": Verify models match implementation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Property Coverage"}),": Ensure all critical properties are verified"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Proof Validity"}),": Check proof artifacts are current"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Regression Detection"}),": Detect when changes break proofs"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"verification-limitations",children:"Verification Limitations"}),"\n",(0,t.jsx)(i.h3,{id:"assumptions",children:"Assumptions"}),"\n",(0,t.jsx)(i.p,{children:"Formal verification relies on several assumptions:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Cryptographic Assumptions"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Ed25519 signatures are unforgeable"}),"\n",(0,t.jsx)(i.li,{children:"SHA-256 is collision-resistant"}),"\n",(0,t.jsx)(i.li,{children:"Random numbers are truly random"}),"\n",(0,t.jsx)(i.li,{children:"Side-channel attacks are not considered"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Model Assumptions"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Perfect cryptography (symbolic models)"}),"\n",(0,t.jsx)(i.li,{children:"Dolev-Yao adversary model"}),"\n",(0,t.jsx)(i.li,{children:"Bounded computation (for termination)"}),"\n",(0,t.jsx)(i.li,{children:"Abstract protocol semantics"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Implementation Assumptions"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Compiler correctness"}),"\n",(0,t.jsx)(i.li,{children:"Hardware correctness"}),"\n",(0,t.jsx)(i.li,{children:"Operating system security"}),"\n",(0,t.jsx)(i.li,{children:"Library implementation correctness"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"scope-limitations",children:"Scope Limitations"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Not Verified"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Extension implementations (outside core)"}),"\n",(0,t.jsx)(i.li,{children:"Network protocol implementations"}),"\n",(0,t.jsx)(i.li,{children:"Performance characteristics"}),"\n",(0,t.jsx)(i.li,{children:"Usability properties"}),"\n",(0,t.jsx)(i.li,{children:"Business logic correctness"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Partially Verified"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Extension interfaces (signatures only)"}),"\n",(0,t.jsx)(i.li,{children:"Standard library usage"}),"\n",(0,t.jsx)(i.li,{children:"Concurrent execution safety"}),"\n",(0,t.jsx)(i.li,{children:"Memory usage bounds"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"using-formal-verification",children:"Using Formal Verification"}),"\n",(0,t.jsx)(i.h3,{id:"for-protocol-implementers",children:"For Protocol Implementers"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Study Models"}),": Understand the formal specifications"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Run Verification"}),": Execute proofs on your implementation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Maintain Annotations"}),": Keep hax annotations current"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Validate Properties"}),": Ensure your code meets verified properties"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"for-security-auditors",children:"For Security Auditors"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Review Models"}),": Check model accuracy against implementation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Verify Claims"}),": Run independent verification tools"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Test Boundaries"}),": Focus on unverified components"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Check Assumptions"}),": Validate cryptographic and model assumptions"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"for-high-assurance-deployments",children:"For High-Assurance Deployments"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Require Verification"}),": Only use verified implementations"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Monitor Artifacts"}),": Track verification status"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Audit Regularly"}),": Periodic verification review"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Plan Updates"}),": Coordinate verification with updates"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"future-verification-work",children:"Future Verification Work"}),"\n",(0,t.jsx)(i.h3,{id:"planned-enhancements",children:"Planned Enhancements"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Extended Coverage"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Verify more extension properties"}),"\n",(0,t.jsx)(i.li,{children:"Add concurrency verification"}),"\n",(0,t.jsx)(i.li,{children:"Include performance properties"}),"\n",(0,t.jsx)(i.li,{children:"Model resource usage"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Tool Improvements"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Better hax integration"}),"\n",(0,t.jsx)(i.li,{children:"Automated model generation"}),"\n",(0,t.jsx)(i.li,{children:"Faster proof checking"}),"\n",(0,t.jsx)(i.li,{children:"Better error reporting"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"New Properties"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Quantum resistance proofs"}),"\n",(0,t.jsx)(i.li,{children:"Privacy preservation properties"}),"\n",(0,t.jsx)(i.li,{children:"Liveness guarantees"}),"\n",(0,t.jsx)(i.li,{children:"Fairness properties"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The formal verification framework continues to evolve, providing increasingly strong guarantees about the protocol's security and correctness properties."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var r=n(6540);const t={},s=r.createContext(t);function l(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);