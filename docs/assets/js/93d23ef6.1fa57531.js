"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[3909],{2177:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"extensions/infrastructure/network-transport","title":"Network Transport Layers","description":"The Network Transport module provides multiple transport layer implementations for distributed Olocus Protocol communication. Each transport is optimized for different network conditions, security requirements, and performance characteristics.","source":"@site/docs/extensions/infrastructure/network-transport.md","sourceDirName":"extensions/infrastructure","slug":"/extensions/infrastructure/network-transport","permalink":"/docs/extensions/infrastructure/network-transport","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/infrastructure/network-transport.md","tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":2,"frontMatter":{"id":"network-transport","title":"Network Transport Layers","sidebar_position":2}}');var o=t(4848),s=t(8453);const a={id:"network-transport",title:"Network Transport Layers",sidebar_position:2},i="Network Transport Layers",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Transport Trait Interface",id:"transport-trait-interface",level:2},{value:"Core Transport Trait",id:"core-transport-trait",level:3},{value:"TCP Transport",id:"tcp-transport",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"UDP Transport",id:"udp-transport",level:2},{value:"Implementation",id:"implementation-1",level:3},{value:"Usage Example",id:"usage-example-1",level:3},{value:"QUIC Transport",id:"quic-transport",level:2},{value:"Implementation",id:"implementation-2",level:3},{value:"Usage Example",id:"usage-example-2",level:3},{value:"WebSocket Transport",id:"websocket-transport",level:2},{value:"Implementation",id:"implementation-3",level:3},{value:"Usage Example",id:"usage-example-3",level:3},{value:"WebRTC Transport",id:"webrtc-transport",level:2},{value:"Implementation",id:"implementation-4",level:3},{value:"Usage Example",id:"usage-example-4",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Configuration Best Practices",id:"configuration-best-practices",level:2},{value:"Production TCP Settings",id:"production-tcp-settings",level:3},{value:"High-Performance UDP Settings",id:"high-performance-udp-settings",level:3},{value:"Enterprise QUIC Settings",id:"enterprise-quic-settings",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Transport Selection Guidelines",id:"transport-selection-guidelines",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"network-transport-layers",children:"Network Transport Layers"})}),"\n",(0,o.jsx)(n.p,{children:"The Network Transport module provides multiple transport layer implementations for distributed Olocus Protocol communication. Each transport is optimized for different network conditions, security requirements, and performance characteristics."}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Transport layers handle the underlying network communication between Olocus Protocol nodes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"TCP"}),": Reliable, ordered, connection-oriented transport"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"UDP"}),": Fast, connectionless transport for high-throughput scenarios"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"QUIC"}),": Modern multiplexed transport with built-in encryption"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"WebSocket"}),": Browser-compatible bidirectional communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"WebRTC"}),": Peer-to-peer transport with NAT traversal"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::*;\n\n// Configure transport layer\nlet transport_config = TransportConfig {\n    transport: Transport::QUIC {\n        bind_addr: "0.0.0.0:8443".parse()?,\n        cert_path: Some("server.crt".to_string()),\n        key_path: Some("server.key".to_string()),\n        max_concurrent_streams: 100,\n    },\n    timeout_config: TimeoutConfig {\n        connect_timeout: Duration::from_secs(10),\n        read_timeout: Duration::from_secs(30),\n        write_timeout: Duration::from_secs(30),\n    },\n    buffer_config: BufferConfig {\n        send_buffer_size: 64 * 1024,\n        recv_buffer_size: 64 * 1024,\n        max_message_size: 1024 * 1024, // 1MB\n    },\n};\n\nlet transport = NetworkTransport::new(transport_config).await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"transport-trait-interface",children:"Transport Trait Interface"}),"\n",(0,o.jsx)(n.h3,{id:"core-transport-trait",children:"Core Transport Trait"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::transport::traits::*;\nuse olocus_core::*;\n\n#[async_trait::async_trait]\npub trait Transport: Send + Sync {\n    type Connection: Connection + Send + Sync;\n    type Listener: Listener<Connection = Self::Connection> + Send + Sync;\n\n    async fn listen(&self, addr: SocketAddr) -> Result<Self::Listener>;\n    async fn connect(&self, addr: SocketAddr) -> Result<Self::Connection>;\n    async fn connect_timeout(&self, addr: SocketAddr, timeout: Duration) -> Result<Self::Connection>;\n    \n    fn transport_type(&self) -> TransportType;\n    fn supports_multiplexing(&self) -> bool;\n    fn supports_encryption(&self) -> bool;\n}\n\n#[async_trait::async_trait]\npub trait Connection: Send + Sync {\n    async fn send(&mut self, data: &[u8]) -> Result<()>;\n    async fn recv(&mut self) -> Result<Vec<u8>>;\n    async fn send_block(&mut self, block: &Block<impl BlockPayload>) -> Result<()>;\n    async fn recv_block(&mut self) -> Result<Block<serde_json::Value>>;\n    \n    async fn close(&mut self) -> Result<()>;\n    fn peer_addr(&self) -> Result<SocketAddr>;\n    fn local_addr(&self) -> Result<SocketAddr>;\n    fn connection_id(&self) -> ConnectionId;\n}\n\n#[async_trait::async_trait]\npub trait Listener: Send + Sync {\n    type Connection: Connection + Send + Sync;\n    \n    async fn accept(&mut self) -> Result<Self::Connection>;\n    async fn local_addr(&self) -> Result<SocketAddr>;\n    async fn close(&mut self) -> Result<()>;\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TransportType {\n    TCP,\n    UDP,\n    QUIC,\n    WebSocket,\n    WebRTC,\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"tcp-transport",children:"TCP Transport"}),"\n",(0,o.jsx)(n.p,{children:"TCP provides reliable, ordered, connection-oriented communication:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::transport::tcp::*;\n\n#[derive(Debug)]\npub struct TcpTransport {\n    config: TcpConfig,\n}\n\nimpl TcpTransport {\n    pub fn new(config: TcpConfig) -> Self {\n        Self { config }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct TcpConfig {\n    pub keepalive: Option<Duration>,\n    pub nodelay: bool,\n    pub reuse_addr: bool,\n    pub reuse_port: bool,\n    pub ttl: Option<u32>,\n}\n\nimpl Default for TcpConfig {\n    fn default() -> Self {\n        Self {\n            keepalive: Some(Duration::from_secs(30)),\n            nodelay: true,\n            reuse_addr: true,\n            reuse_port: false,\n            ttl: None,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Transport for TcpTransport {\n    type Connection = TcpConnection;\n    type Listener = TcpListener;\n\n    async fn listen(&self, addr: SocketAddr) -> Result<Self::Listener> {\n        let listener = tokio::net::TcpListener::bind(addr).await?;\n        Ok(TcpListener::new(listener, self.config.clone()))\n    }\n\n    async fn connect(&self, addr: SocketAddr) -> Result<Self::Connection> {\n        let stream = tokio::net::TcpStream::connect(addr).await?;\n        self.configure_stream(&stream)?;\n        Ok(TcpConnection::new(stream))\n    }\n\n    fn transport_type(&self) -> TransportType {\n        TransportType::TCP\n    }\n\n    fn supports_multiplexing(&self) -> bool {\n        false\n    }\n\n    fn supports_encryption(&self) -> bool {\n        false // Encryption handled at application layer\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::tcp::*;\n\nlet config = TcpConfig {\n    keepalive: Some(Duration::from_secs(60)),\n    nodelay: true,\n    reuse_addr: true,\n    reuse_port: false,\n    ttl: Some(64),\n};\n\nlet transport = TcpTransport::new(config);\n\n// Server\nlet mut listener = transport.listen("127.0.0.1:8080".parse()?).await?;\ntokio::spawn(async move {\n    while let Ok(mut connection) = listener.accept().await {\n        tokio::spawn(async move {\n            while let Ok(block) = connection.recv_block().await {\n                // Process received block\n                println!("Received block: {}", block.index);\n            }\n        });\n    }\n});\n\n// Client\nlet mut connection = transport.connect("127.0.0.1:8080".parse()?).await?;\nconnection.send_block(&my_block).await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"udp-transport",children:"UDP Transport"}),"\n",(0,o.jsx)(n.p,{children:"UDP provides fast, connectionless communication for high-throughput scenarios:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-1",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::transport::udp::*;\n\n#[derive(Debug)]\npub struct UdpTransport {\n    config: UdpConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct UdpConfig {\n    pub max_packet_size: usize,\n    pub reuse_addr: bool,\n    pub reuse_port: bool,\n    pub multicast_ttl: Option<u32>,\n    pub broadcast: bool,\n}\n\nimpl Default for UdpConfig {\n    fn default() -> Self {\n        Self {\n            max_packet_size: 65507, // Max UDP payload\n            reuse_addr: true,\n            reuse_port: false,\n            multicast_ttl: None,\n            broadcast: false,\n        }\n    }\n}\n\n// UDP requires different semantics due to connectionless nature\n#[async_trait::async_trait]\npub trait DatagramTransport: Send + Sync {\n    async fn bind(&self, addr: SocketAddr) -> Result<UdpSocket>;\n    async fn send_to(&self, socket: &UdpSocket, data: &[u8], addr: SocketAddr) -> Result<()>;\n    async fn recv_from(&self, socket: &UdpSocket) -> Result<(Vec<u8>, SocketAddr)>;\n}\n\n#[derive(Debug)]\npub struct UdpSocket {\n    socket: tokio::net::UdpSocket,\n    config: UdpConfig,\n}\n\nimpl UdpSocket {\n    pub async fn send_block_to(&self, block: &Block<impl BlockPayload>, addr: SocketAddr) -> Result<()> {\n        let data = block.to_wire_format(WireFormat::default())?;\n        if data.len() > self.config.max_packet_size {\n            return Err(NetworkError::PacketTooLarge(data.len()));\n        }\n        self.socket.send_to(&data, addr).await?;\n        Ok(())\n    }\n\n    pub async fn recv_block_from(&self) -> Result<(Block<serde_json::Value>, SocketAddr)> {\n        let mut buffer = vec![0; self.config.max_packet_size];\n        let (len, addr) = self.socket.recv_from(&mut buffer).await?;\n        buffer.truncate(len);\n        \n        let block = Block::from_wire_format(&buffer, WireFormat::default())?;\n        Ok((block, addr))\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example-1",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::udp::*;\n\nlet config = UdpConfig {\n    max_packet_size: 32768, // 32KB\n    reuse_addr: true,\n    broadcast: true,\n    ..Default::default()\n};\n\nlet transport = UdpTransport::new(config);\n\n// Server\nlet socket = transport.bind("127.0.0.1:8080".parse()?).await?;\ntokio::spawn(async move {\n    loop {\n        match socket.recv_block_from().await {\n            Ok((block, peer_addr)) => {\n                println!("Received block {} from {}", block.index, peer_addr);\n                // Send acknowledgment\n                let ack_block = create_ack_block(&block);\n                socket.send_block_to(&ack_block, peer_addr).await?;\n            }\n            Err(e) => eprintln!("UDP receive error: {}", e),\n        }\n    }\n});\n\n// Client  \nlet socket = transport.bind("0.0.0.0:0".parse()?).await?;\nsocket.send_block_to(&my_block, "127.0.0.1:8080".parse()?).await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"quic-transport",children:"QUIC Transport"}),"\n",(0,o.jsx)(n.p,{children:"QUIC provides modern multiplexed transport with built-in encryption and stream management:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-2",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"use olocus_network::transport::quic::*;\nuse quinn::*;\n\n#[derive(Debug)]\npub struct QuicTransport {\n    config: QuicConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct QuicConfig {\n    pub max_concurrent_streams: u32,\n    pub keep_alive_interval: Option<Duration>,\n    pub max_idle_timeout: Duration,\n    pub initial_max_data: u32,\n    pub initial_max_stream_data: u32,\n    pub cert_chain: Option<Vec<u8>>,\n    pub private_key: Option<Vec<u8>>,\n}\n\nimpl Default for QuicConfig {\n    fn default() -> Self {\n        Self {\n            max_concurrent_streams: 100,\n            keep_alive_interval: Some(Duration::from_secs(30)),\n            max_idle_timeout: Duration::from_secs(300),\n            initial_max_data: 1024 * 1024 * 10, // 10MB\n            initial_max_stream_data: 1024 * 1024, // 1MB\n            cert_chain: None,\n            private_key: None,\n        }\n    }\n}\n\npub struct QuicConnection {\n    connection: Connection,\n    config: QuicConfig,\n}\n\nimpl QuicConnection {\n    pub async fn open_stream(&self) -> Result<QuicStream> {\n        let (send, recv) = self.connection.open_bi().await?;\n        Ok(QuicStream::new(send, recv))\n    }\n\n    pub async fn accept_stream(&self) -> Result<QuicStream> {\n        let (send, recv) = self.connection.accept_bi().await?;\n        Ok(QuicStream::new(send, recv))\n    }\n}\n\npub struct QuicStream {\n    send: SendStream,\n    recv: RecvStream,\n}\n\nimpl QuicStream {\n    pub async fn send_block(&mut self, block: &Block<impl BlockPayload>) -> Result<()> {\n        let data = block.to_wire_format(WireFormat::default())?;\n        let length = (data.len() as u32).to_be_bytes();\n        \n        self.send.write_all(&length).await?;\n        self.send.write_all(&data).await?;\n        self.send.finish().await?;\n        Ok(())\n    }\n\n    pub async fn recv_block(&mut self) -> Result<Block<serde_json::Value>> {\n        let mut length_bytes = [0u8; 4];\n        self.recv.read_exact(&mut length_bytes).await?;\n        let length = u32::from_be_bytes(length_bytes) as usize;\n        \n        let mut data = vec![0u8; length];\n        self.recv.read_exact(&mut data).await?;\n        \n        let block = Block::from_wire_format(&data, WireFormat::default())?;\n        Ok(block)\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example-2",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::quic::*;\n\nlet config = QuicConfig {\n    max_concurrent_streams: 200,\n    keep_alive_interval: Some(Duration::from_secs(60)),\n    max_idle_timeout: Duration::from_secs(600),\n    cert_chain: Some(load_cert_chain("server.crt")?),\n    private_key: Some(load_private_key("server.key")?),\n    ..Default::default()\n};\n\nlet transport = QuicTransport::new(config);\n\n// Server\nlet mut listener = transport.listen("127.0.0.1:8443".parse()?).await?;\ntokio::spawn(async move {\n    while let Ok(connection) = listener.accept().await {\n        tokio::spawn(async move {\n            while let Ok(mut stream) = connection.accept_stream().await {\n                tokio::spawn(async move {\n                    while let Ok(block) = stream.recv_block().await {\n                        println!("Received block: {}", block.index);\n                        // Send response on same stream\n                        let response = create_response_block(&block);\n                        stream.send_block(&response).await?;\n                    }\n                });\n            }\n        });\n    }\n});\n\n// Client\nlet connection = transport.connect("127.0.0.1:8443".parse()?).await?;\nlet mut stream = connection.open_stream().await?;\nstream.send_block(&my_block).await?;\nlet response = stream.recv_block().await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"websocket-transport",children:"WebSocket Transport"}),"\n",(0,o.jsx)(n.p,{children:"WebSocket provides browser-compatible bidirectional communication:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-3",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::websocket::*;\nuse tokio_tungstenite::*;\n\n#[derive(Debug)]\npub struct WebSocketTransport {\n    config: WebSocketConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct WebSocketConfig {\n    pub max_frame_size: usize,\n    pub max_message_size: usize,\n    pub compression: bool,\n    pub subprotocol: Option<String>,\n}\n\nimpl Default for WebSocketConfig {\n    fn default() -> Self {\n        Self {\n            max_frame_size: 16 * 1024 * 1024, // 16MB\n            max_message_size: 64 * 1024 * 1024, // 64MB\n            compression: true,\n            subprotocol: Some("olocus-v1".to_string()),\n        }\n    }\n}\n\npub struct WebSocketConnection {\n    ws_stream: WebSocketStream<tokio::net::TcpStream>,\n    config: WebSocketConfig,\n}\n\nimpl WebSocketConnection {\n    pub async fn send_block(&mut self, block: &Block<impl BlockPayload>) -> Result<()> {\n        let data = block.to_wire_format(WireFormat::json())?;\n        let message = Message::Text(String::from_utf8(data)?);\n        self.ws_stream.send(message).await?;\n        Ok(())\n    }\n\n    pub async fn recv_block(&mut self) -> Result<Block<serde_json::Value>> {\n        loop {\n            match self.ws_stream.next().await {\n                Some(Ok(Message::Text(text))) => {\n                    let block = Block::from_wire_format(text.as_bytes(), WireFormat::json())?;\n                    return Ok(block);\n                }\n                Some(Ok(Message::Binary(data))) => {\n                    let block = Block::from_wire_format(&data, WireFormat::default())?;\n                    return Ok(block);\n                }\n                Some(Ok(Message::Ping(data))) => {\n                    self.ws_stream.send(Message::Pong(data)).await?;\n                }\n                Some(Ok(Message::Pong(_))) => {\n                    // Ignore pong messages\n                }\n                Some(Ok(Message::Close(_))) => {\n                    return Err(NetworkError::ConnectionClosed);\n                }\n                Some(Err(e)) => return Err(NetworkError::WebSocket(e)),\n                None => return Err(NetworkError::ConnectionClosed),\n            }\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example-3",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::websocket::*;\n\nlet config = WebSocketConfig {\n    max_message_size: 32 * 1024 * 1024, // 32MB\n    compression: true,\n    subprotocol: Some("olocus-v1".to_string()),\n    ..Default::default()\n};\n\n// Server\nlet transport = WebSocketTransport::new(config.clone());\nlet listener = transport.listen("127.0.0.1:8080".parse()?).await?;\n\ntokio::spawn(async move {\n    while let Ok(mut connection) = listener.accept().await {\n        tokio::spawn(async move {\n            while let Ok(block) = connection.recv_block().await {\n                println!("WebSocket received block: {}", block.index);\n                // Echo block back\n                connection.send_block(&block).await?;\n            }\n        });\n    }\n});\n\n// Client (can be used from browser JavaScript)\nlet connection = transport.connect("ws://127.0.0.1:8080".parse()?).await?;\nconnection.send_block(&my_block).await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"webrtc-transport",children:"WebRTC Transport"}),"\n",(0,o.jsx)(n.p,{children:"WebRTC provides peer-to-peer transport with NAT traversal:"}),"\n",(0,o.jsx)(n.h3,{id:"implementation-4",children:"Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::webrtc::*;\n\n#[derive(Debug)]\npub struct WebRtcTransport {\n    config: WebRtcConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct WebRtcConfig {\n    pub ice_servers: Vec<IceServer>,\n    pub max_message_size: usize,\n    pub ordered: bool,\n    pub max_retransmits: Option<u16>,\n    pub max_packet_lifetime: Option<Duration>,\n}\n\n#[derive(Debug, Clone)]\npub struct IceServer {\n    pub urls: Vec<String>,\n    pub username: Option<String>,\n    pub credential: Option<String>,\n}\n\nimpl Default for WebRtcConfig {\n    fn default() -> Self {\n        Self {\n            ice_servers: vec![\n                IceServer {\n                    urls: vec!["stun:stun.l.google.com:19302".to_string()],\n                    username: None,\n                    credential: None,\n                },\n            ],\n            max_message_size: 16 * 1024, // 16KB (WebRTC limit)\n            ordered: true,\n            max_retransmits: Some(3),\n            max_packet_lifetime: Some(Duration::from_secs(3)),\n        }\n    }\n}\n\npub struct WebRtcConnection {\n    data_channel: Arc<DataChannel>,\n    peer_connection: Arc<PeerConnection>,\n    config: WebRtcConfig,\n}\n\nimpl WebRtcConnection {\n    pub async fn send_block(&self, block: &Block<impl BlockPayload>) -> Result<()> {\n        let data = block.to_wire_format(WireFormat::messagepack())?;\n        \n        // Fragment large blocks\n        const CHUNK_SIZE: usize = 15 * 1024; // Leave room for headers\n        if data.len() > CHUNK_SIZE {\n            let chunks = data.chunks(CHUNK_SIZE);\n            let total_chunks = chunks.len();\n            \n            for (i, chunk) in chunks.enumerate() {\n                let fragment = BlockFragment {\n                    block_hash: block.hash()?,\n                    fragment_id: i as u16,\n                    total_fragments: total_chunks as u16,\n                    data: chunk.to_vec(),\n                };\n                \n                let fragment_data = bincode::serialize(&fragment)?;\n                self.data_channel.send(&fragment_data)?;\n            }\n        } else {\n            self.data_channel.send(&data)?;\n        }\n        \n        Ok(())\n    }\n    \n    pub async fn create_offer(&self) -> Result<SessionDescription> {\n        let offer = self.peer_connection.create_offer().await?;\n        self.peer_connection.set_local_description(offer.clone()).await?;\n        Ok(offer)\n    }\n    \n    pub async fn create_answer(&self, offer: &SessionDescription) -> Result<SessionDescription> {\n        self.peer_connection.set_remote_description(offer.clone()).await?;\n        let answer = self.peer_connection.create_answer().await?;\n        self.peer_connection.set_local_description(answer.clone()).await?;\n        Ok(answer)\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"usage-example-4",children:"Usage Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::webrtc::*;\n\nlet config = WebRtcConfig {\n    ice_servers: vec![\n        IceServer {\n            urls: vec![\n                "stun:stun.l.google.com:19302".to_string(),\n                "turn:myturnserver.com:3478".to_string(),\n            ],\n            username: Some("user".to_string()),\n            credential: Some("password".to_string()),\n        },\n    ],\n    max_message_size: 15 * 1024, // 15KB\n    ordered: true,\n    ..Default::default()\n};\n\n// Peer A (Initiator)\nlet transport_a = WebRtcTransport::new(config.clone());\nlet connection_a = transport_a.create_connection().await?;\nlet offer = connection_a.create_offer().await?;\n\n// Send offer to Peer B via signaling server\nsend_via_signaling_server(offer).await?;\n\n// Peer B (Responder) \nlet transport_b = WebRtcTransport::new(config);\nlet connection_b = transport_b.create_connection().await?;\nlet answer = connection_b.create_answer(&offer).await?;\n\n// Send answer back to Peer A\nsend_via_signaling_server(answer).await?;\n\n// After ICE gathering completes, can send blocks\nconnection_a.send_block(&my_block).await?;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Transport"}),(0,o.jsx)(n.th,{children:"Latency"}),(0,o.jsx)(n.th,{children:"Throughput"}),(0,o.jsx)(n.th,{children:"CPU Usage"}),(0,o.jsx)(n.th,{children:"Memory"}),(0,o.jsx)(n.th,{children:"Use Case"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"TCP"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"Reliable bulk transfer"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"UDP"}),(0,o.jsx)(n.td,{children:"Lowest"}),(0,o.jsx)(n.td,{children:"Highest"}),(0,o.jsx)(n.td,{children:"Lowest"}),(0,o.jsx)(n.td,{children:"Lowest"}),(0,o.jsx)(n.td,{children:"Real-time, loss-tolerant"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"QUIC"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Modern web applications"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"WebSocket"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Browser compatibility"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"WebRTC"}),(0,o.jsx)(n.td,{children:"Medium"}),(0,o.jsx)(n.td,{children:"Low"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"High"}),(0,o.jsx)(n.td,{children:"P2P, NAT traversal"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"configuration-best-practices",children:"Configuration Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"production-tcp-settings",children:"Production TCP Settings"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"let tcp_config = TcpConfig {\n    keepalive: Some(Duration::from_secs(60)),\n    nodelay: true,          // Disable Nagle's algorithm\n    reuse_addr: true,       // Allow port reuse\n    reuse_port: false,      // Avoid in production\n    ttl: Some(64),          // Standard Internet TTL\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"high-performance-udp-settings",children:"High-Performance UDP Settings"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"let udp_config = UdpConfig {\n    max_packet_size: 1400,  // Avoid IP fragmentation\n    reuse_addr: true,\n    broadcast: false,       // Disable unless needed\n    multicast_ttl: None,    // Only set for multicast\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"enterprise-quic-settings",children:"Enterprise QUIC Settings"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"let quic_config = QuicConfig {\n    max_concurrent_streams: 1000,\n    keep_alive_interval: Some(Duration::from_secs(30)),\n    max_idle_timeout: Duration::from_secs(120),\n    initial_max_data: 1024 * 1024 * 100,      // 100MB\n    initial_max_stream_data: 1024 * 1024 * 10, // 10MB\n    cert_chain: Some(load_production_cert()?),\n    private_key: Some(load_production_key()?),\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use olocus_network::transport::error::*;\n\n#[derive(Debug, thiserror::Error)]\npub enum NetworkError {\n    #[error("Connection timeout")]\n    Timeout,\n    \n    #[error("Connection closed by peer")]\n    ConnectionClosed,\n    \n    #[error("Invalid address: {0}")]\n    InvalidAddress(String),\n    \n    #[error("Packet too large: {0} bytes")]\n    PacketTooLarge(usize),\n    \n    #[error("TLS error: {0}")]\n    Tls(#[from] rustls::Error),\n    \n    #[error("WebSocket error: {0}")]\n    WebSocket(#[from] tokio_tungstenite::tungstenite::Error),\n    \n    #[error("QUIC error: {0}")]\n    Quic(#[from] quinn::ConnectionError),\n    \n    #[error("WebRTC error: {0}")]\n    WebRtc(String),\n    \n    #[error("Serialization error: {0}")]\n    Serialization(#[from] bincode::Error),\n    \n    #[error("IO error: {0}")]\n    Io(#[from] std::io::Error),\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"transport-selection-guidelines",children:"Transport Selection Guidelines"}),"\n",(0,o.jsx)(n.p,{children:"Choose the appropriate transport based on your requirements:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"TCP"}),": Default choice for reliable communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"UDP"}),": Real-time applications, broadcasting, multicasting"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"QUIC"}),": Modern applications requiring multiplexing and performance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"WebSocket"}),": Browser-based applications, long-lived connections"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"WebRTC"}),": Peer-to-peer communication, NAT traversal required"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Each transport can be configured independently and used with the same high-level Olocus Protocol APIs."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);