"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[3145],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var o=r(6540);const t={},s=o.createContext(t);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:n},e.children)}},9370:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"api/wire-format-api","title":"Wire Format API","description":"The Wire Format API provides extensible encoding and compression for block serialization. It supports multiple formats and compression methods with automatic content-type negotiation.","source":"@site/docs/api/wire-format-api.md","sourceDirName":"api","slug":"/api/wire-format-api","permalink":"/docs/api/wire-format-api","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/api/wire-format-api.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":3,"frontMatter":{"id":"wire-format-api","title":"Wire Format API","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Measurement API","permalink":"/docs/api/measurement-api"},"next":{"title":"Error Handling","permalink":"/docs/api/error-handling"}}');var t=r(4848),s=r(8453);const a={id:"wire-format-api",title:"Wire Format API",sidebar_position:3},i="Wire Format API",l={},c=[{value:"Overview",id:"overview",level:2},{value:"WireFormat Structure",id:"wireformat-structure",level:2},{value:"Encoding Formats",id:"encoding-formats",level:2},{value:"Binary Format (Default)",id:"binary-format-default",level:3},{value:"JSON Format",id:"json-format",level:3},{value:"MessagePack Format",id:"messagepack-format",level:3},{value:"SSZ Format",id:"ssz-format",level:3},{value:"Protobuf Format",id:"protobuf-format",level:3},{value:"Compression Methods",id:"compression-methods",level:2},{value:"No Compression",id:"no-compression",level:3},{value:"Zstd Compression",id:"zstd-compression",level:3},{value:"LZ4 Compression",id:"lz4-compression",level:3},{value:"Gzip Compression",id:"gzip-compression",level:3},{value:"Encoding and Decoding",id:"encoding-and-decoding",level:2},{value:"Basic Operations",id:"basic-operations",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Content-Type Negotiation",id:"content-type-negotiation",level:2},{value:"Generate Content-Type Headers",id:"generate-content-type-headers",level:3},{value:"Parse Content-Type Headers",id:"parse-content-type-headers",level:3},{value:"Performance Comparison",id:"performance-comparison",level:2},{value:"Size Comparison",id:"size-comparison",level:3},{value:"Compression Efficiency",id:"compression-efficiency",level:3},{value:"Performance Benchmarks",id:"performance-benchmarks",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Custom Payload Types",id:"custom-payload-types",level:3},{value:"Streaming Large Blocks",id:"streaming-large-blocks",level:3},{value:"Format Migration",id:"format-migration",level:3},{value:"HTTP Integration",id:"http-integration",level:2},{value:"Server Implementation",id:"server-implementation",level:3},{value:"Client Implementation",id:"client-implementation",level:3},{value:"Configuration and Feature Flags",id:"configuration-and-feature-flags",level:2},{value:"Cargo Features",id:"cargo-features",level:3},{value:"Runtime Feature Detection",id:"runtime-feature-detection",level:3},{value:"Error Conditions",id:"error-conditions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Format Selection Guidelines",id:"format-selection-guidelines",level:3},{value:"Compression Guidelines",id:"compression-guidelines",level:3},{value:"Implementation Tips",id:"implementation-tips",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"wire-format-api",children:"Wire Format API"})}),"\n",(0,t.jsx)(n.p,{children:"The Wire Format API provides extensible encoding and compression for block serialization. It supports multiple formats and compression methods with automatic content-type negotiation."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The wire format system supports:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"5 Encoding Formats"}),": Binary (default), JSON, MessagePack, SSZ, Protobuf"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"4 Compression Methods"}),": None, Zstd, LZ4, Gzip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"20 Total Combinations"}),": All encoding/compression pairs are supported"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Content Negotiation"}),": HTTP-style content-type headers for format detection"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"wireformat-structure",children:"WireFormat Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use olocus_core::wire_format::{WireFormat, EncodingFormat, CompressionMethod};\n\n// Basic wire format\nlet format = WireFormat::new(\n    EncodingFormat::MessagePack,\n    CompressionMethod::Zstd,\n);\n\n// Convenience constructors\nlet binary = WireFormat::binary();    // Default: Binary + None\nlet json = WireFormat::json();        // JSON + None  \nlet msgpack = WireFormat::msgpack();  // MessagePack + None\n"})}),"\n",(0,t.jsx)(n.h2,{id:"encoding-formats",children:"Encoding Formats"}),"\n",(0,t.jsx)(n.h3,{id:"binary-format-default",children:"Binary Format (Default)"}),"\n",(0,t.jsx)(n.p,{children:"The canonical binary format optimized for performance and space efficiency:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::binary();\nlet encoded = format.encode(&block)?;\n\n// Properties:\n// - Fastest encoding/decoding\n// - Smallest size (no overhead)\n// - SSZ-compatible layout\n// - Deterministic representation\n"})}),"\n",(0,t.jsx)(n.h3,{id:"json-format",children:"JSON Format"}),"\n",(0,t.jsx)(n.p,{children:"Human-readable JSON for debugging and interoperability:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let format = WireFormat::json();\nlet encoded = format.encode(&block)?;\n\n// Verify it\'s valid JSON\nlet json_str = std::str::from_utf8(&encoded)?;\nprintln!("Block as JSON: {}", json_str);\n\n// Properties:\n// - Human readable\n// - Debuggable\n// - Larger size\n// - Hex-encoded binary fields\n'})}),"\n",(0,t.jsx)(n.h3,{id:"messagepack-format",children:"MessagePack Format"}),"\n",(0,t.jsx)(n.p,{children:"Efficient binary JSON alternative:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::msgpack();\nlet encoded = format.encode(&block)?;\n\n// Properties:\n// - Faster than JSON\n// - Smaller than JSON\n// - Binary efficient\n// - Schema-less\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ssz-format",children:"SSZ Format"}),"\n",(0,t.jsx)(n.p,{children:"Simple Serialize format used in Ethereum 2.0:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::SSZ, CompressionMethod::None);\nlet encoded = format.encode(&block)?;\n\n// Properties:\n// - Ethereum ecosystem compatibility\n// - Merkle tree friendly\n// - Fixed-size fields\n// - Zero-copy parsing potential\n"})}),"\n",(0,t.jsx)(n.h3,{id:"protobuf-format",children:"Protobuf Format"}),"\n",(0,t.jsx)(n.p,{children:"Protocol Buffers compatible encoding:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::Protobuf, CompressionMethod::None);\nlet encoded = format.encode(&block)?;\n\n// Properties:\n// - Cross-language compatibility\n// - Schema evolution support\n// - Tag-length-value encoding\n// - Backwards compatibility\n"})}),"\n",(0,t.jsx)(n.h2,{id:"compression-methods",children:"Compression Methods"}),"\n",(0,t.jsx)(n.h3,{id:"no-compression",children:"No Compression"}),"\n",(0,t.jsx)(n.p,{children:"Default mode with no processing overhead:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::Binary, CompressionMethod::None);\n\n// Properties:\n// - Zero overhead\n// - Fastest processing\n// - Largest size\n// - Direct binary representation\n"})}),"\n",(0,t.jsx)(n.h3,{id:"zstd-compression",children:"Zstd Compression"}),"\n",(0,t.jsx)(n.p,{children:"High-performance compression with excellent ratios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Zstd);\n\n// Properties:\n// - Best compression ratio\n// - Fast decompression\n// - Requires 'compression-zstd' feature\n// - Falls back to LZ4 if unavailable\n"})}),"\n",(0,t.jsx)(n.h3,{id:"lz4-compression",children:"LZ4 Compression"}),"\n",(0,t.jsx)(n.p,{children:"Fast compression with reasonable ratios:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Lz4);\n\n// Properties:\n// - Fastest compression\n// - Good decompression speed\n// - Moderate compression ratio\n// - Always available\n"})}),"\n",(0,t.jsx)(n.h3,{id:"gzip-compression",children:"Gzip Compression"}),"\n",(0,t.jsx)(n.p,{children:"Standard compression for HTTP compatibility:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let format = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Gzip);\n\n// Properties:\n// - HTTP standard\n// - Wide compatibility\n// - Slower than LZ4/Zstd\n// - Good compression ratio\n"})}),"\n",(0,t.jsx)(n.h2,{id:"encoding-and-decoding",children:"Encoding and Decoding"}),"\n",(0,t.jsx)(n.h3,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{Block, EmptyPayload, wire_format::WireFormat};\n\n// Create a block\nlet block = Block::genesis(EmptyPayload, &key, timestamp);\n\n// Encode with different formats\nlet binary_data = WireFormat::binary().encode(&block)?;\nlet json_data = WireFormat::json().encode(&block)?;\nlet msgpack_data = WireFormat::msgpack().encode(&block)?;\n\n// Decode back to blocks\nlet decoded_binary: Block<EmptyPayload> = WireFormat::binary().decode(&binary_data)?;\nlet decoded_json: Block<EmptyPayload> = WireFormat::json().decode(&json_data)?;\nlet decoded_msgpack: Block<EmptyPayload> = WireFormat::msgpack().decode(&msgpack_data)?;\n\n// All should be equivalent\nassert_eq!(decoded_binary.header.index, block.header.index);\nassert_eq!(decoded_json.signature, block.signature);\nassert_eq!(decoded_msgpack.public_key, block.public_key);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_core::Error;\n\nmatch format.decode::<MyPayload>(&data) {\n    Ok(block) => {\n        println!("Successfully decoded block {}", block.header.index);\n    }\n    Err(Error::MalformedBlock) => {\n        eprintln!("Invalid block data - corrupted or wrong format");\n    }\n    Err(e) => {\n        eprintln!("Decode error: {}", e);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"content-type-negotiation",children:"Content-Type Negotiation"}),"\n",(0,t.jsx)(n.h3,{id:"generate-content-type-headers",children:"Generate Content-Type Headers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Get content type for HTTP headers\nlet content_type = format.content_type();\n\nmatch format.encoding {\n    EncodingFormat::Binary => {\n        assert_eq!(content_type, "application/x-olocus-block");\n    }\n    EncodingFormat::Json => {\n        assert_eq!(content_type, "application/json");\n    }\n    // ... etc\n}\n\n// With compression\nlet compressed_format = WireFormat::new(\n    EncodingFormat::Json,\n    CompressionMethod::Gzip,\n);\nassert_eq!(compressed_format.content_type(), "application/json+gzip");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"parse-content-type-headers",children:"Parse Content-Type Headers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Parse incoming content type\nif let Some(format) = WireFormat::from_content_type("application/x-msgpack+zstd") {\n    let block = format.decode::<MyPayload>(&data)?;\n    println!("Decoded MessagePack+Zstd block");\n} else {\n    eprintln!("Unsupported content type");\n}\n\n// Common content types\nlet formats = [\n    ("application/x-olocus-block", WireFormat::binary()),\n    ("application/json", WireFormat::json()),\n    ("application/x-msgpack", WireFormat::msgpack()),\n    ("application/json+gzip", WireFormat::new(EncodingFormat::Json, CompressionMethod::Gzip)),\n];\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,t.jsx)(n.h3,{id:"size-comparison",children:"Size Comparison"}),"\n",(0,t.jsx)(n.p,{children:"For typical blocks, expect these relative sizes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Example sizes for a standard block (approximate)\n// Binary:     450 bytes  (baseline)\n// SSZ:        450 bytes  (same as binary)\n// MessagePack: 380 bytes  (-15% vs binary)\n// Protobuf:   490 bytes  (+9% vs binary)\n// JSON:       680 bytes  (+51% vs binary)\n\nfn compare_sizes<P: BlockPayload>(block: &Block<P>) {\n    let binary_size = WireFormat::binary().encode(block).unwrap().len();\n    let json_size = WireFormat::json().encode(block).unwrap().len();\n    let msgpack_size = WireFormat::msgpack().encode(block).unwrap().len();\n    \n    println!("Binary: {} bytes", binary_size);\n    println!("JSON: {} bytes (+{:.1}%)", json_size, \n             (json_size as f64 / binary_size as f64 - 1.0) * 100.0);\n    println!("MessagePack: {} bytes ({:.1}%)", msgpack_size,\n             (msgpack_size as f64 / binary_size as f64 - 1.0) * 100.0);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"compression-efficiency",children:"Compression Efficiency"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Test compression on a larger block\nlet large_block = create_block_with_large_payload(); // 10KB payload\n\nlet uncompressed = WireFormat::binary().encode(&large_block).unwrap();\nlet zstd = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Zstd)\n    .encode(&large_block).unwrap();\nlet lz4 = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Lz4)\n    .encode(&large_block).unwrap();\nlet gzip = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Gzip)\n    .encode(&large_block).unwrap();\n\n// Typical compression ratios (depends on payload):\n// Zstd:  ~60-70% compression\n// Gzip:  ~55-65% compression  \n// LZ4:   ~40-50% compression\n"})}),"\n",(0,t.jsx)(n.h3,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,t.jsx)(n.p,{children:"Target performance for block operations:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Time"}),(0,t.jsx)(n.th,{children:"Notes"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Binary encode"}),(0,t.jsx)(n.td,{children:"< 100\u03bcs"}),(0,t.jsx)(n.td,{children:"Fastest"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Binary decode"}),(0,t.jsx)(n.td,{children:"< 100\u03bcs"}),(0,t.jsx)(n.td,{children:"Fastest"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"MessagePack encode"}),(0,t.jsx)(n.td,{children:"< 200\u03bcs"}),(0,t.jsx)(n.td,{children:"Good balance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"MessagePack decode"}),(0,t.jsx)(n.td,{children:"< 200\u03bcs"}),(0,t.jsx)(n.td,{children:"Good balance"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"JSON encode"}),(0,t.jsx)(n.td,{children:"< 500\u03bcs"}),(0,t.jsx)(n.td,{children:"Human readable"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"JSON decode"}),(0,t.jsx)(n.td,{children:"< 300\u03bcs"}),(0,t.jsx)(n.td,{children:"Parsing overhead"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Zstd compress"}),(0,t.jsx)(n.td,{children:"< 1ms"}),(0,t.jsx)(n.td,{children:"Best ratio"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LZ4 compress"}),(0,t.jsx)(n.td,{children:"< 200\u03bcs"}),(0,t.jsx)(n.td,{children:"Fastest compression"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Gzip compress"}),(0,t.jsx)(n.td,{children:"< 800\u03bcs"}),(0,t.jsx)(n.td,{children:"Standard"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,t.jsx)(n.h3,{id:"custom-payload-types",children:"Custom Payload Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use serde::{Serialize, Deserialize};\nuse olocus_core::BlockPayload;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CustomPayload {\n    pub data: String,\n    pub metrics: Vec<f64>,\n    pub metadata: std::collections::HashMap<String, String>,\n}\n\nimpl BlockPayload for CustomPayload {\n    fn to_bytes(&self) -> Vec<u8> {\n        // Use deterministic serialization\n        rmp_serde::to_vec(self).unwrap()\n    }\n    \n    fn from_bytes(bytes: &[u8]) -> Result<Self, olocus_core::Error> {\n        rmp_serde::from_slice(bytes)\n            .map_err(|_| olocus_core::Error::MalformedBlock)\n    }\n    \n    fn payload_type() -> u32 {\n        0x8001 // Custom type ID\n    }\n}\n\n// Works with all wire formats\nlet block = Block::genesis(custom_payload, &key, timestamp);\nlet formats = [\n    WireFormat::binary(),\n    WireFormat::json(),\n    WireFormat::msgpack(),\n];\n\nfor format in &formats {\n    let encoded = format.encode(&block)?;\n    let decoded: Block<CustomPayload> = format.decode(&encoded)?;\n    assert_eq!(decoded.payload.data, block.payload.data);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"streaming-large-blocks",children:"Streaming Large Blocks"}),"\n",(0,t.jsx)(n.p,{children:"For very large blocks, consider streaming approaches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"use std::io::{Write, Read};\n\nfn stream_encode<P: BlockPayload, W: Write>(\n    block: &Block<P>, \n    format: WireFormat,\n    mut writer: W\n) -> Result<(), Box<dyn std::error::Error>> {\n    let encoded = format.encode(block)?;\n    writer.write_all(&encoded)?;\n    Ok(())\n}\n\nfn stream_decode<P: BlockPayload + From<Vec<u8>>, R: Read>(\n    format: WireFormat,\n    mut reader: R\n) -> Result<Block<P>, Box<dyn std::error::Error>> {\n    let mut buffer = Vec::new();\n    reader.read_to_end(&mut buffer)?;\n    let block = format.decode(&buffer)?;\n    Ok(block)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"format-migration",children:"Format Migration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Convert between formats without re-signing\nfn convert_format<P: BlockPayload + From<Vec<u8>>>(\n    data: &[u8],\n    from: WireFormat,\n    to: WireFormat,\n) -> Result<Vec<u8>, olocus_core::Error> {\n    let block: Block<P> = from.decode(data)?;\n    to.encode(&block)\n}\n\n// Example: JSON to MessagePack\nlet json_data = get_json_block_data();\nlet msgpack_data = convert_format::<EmptyPayload>(\n    &json_data,\n    WireFormat::json(),\n    WireFormat::msgpack(),\n)?;\n"})}),"\n",(0,t.jsx)(n.h2,{id:"http-integration",children:"HTTP Integration"}),"\n",(0,t.jsx)(n.h3,{id:"server-implementation",children:"Server Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use axum::{body::Bytes, extract::Query, http::HeaderMap, response::Response};\nuse std::collections::HashMap;\n\nasync fn submit_block(\n    headers: HeaderMap,\n    body: Bytes,\n) -> Result<Response, StatusCode> {\n    // Parse content type\n    let content_type = headers\n        .get("content-type")\n        .and_then(|v| v.to_str().ok())\n        .unwrap_or("application/x-olocus-block");\n    \n    let format = WireFormat::from_content_type(content_type)\n        .ok_or(StatusCode::UNSUPPORTED_MEDIA_TYPE)?;\n    \n    // Decode block\n    let block: Block<MyPayload> = format\n        .decode(&body)\n        .map_err(|_| StatusCode::BAD_REQUEST)?;\n    \n    // Process block...\n    process_block(block).await?;\n    \n    Ok(Response::new("Block accepted".into()))\n}\n\nasync fn get_block(\n    Query(params): Query<HashMap<String, String>>,\n) -> Result<Response, StatusCode> {\n    let hash = params.get("hash")\n        .ok_or(StatusCode::BAD_REQUEST)?;\n    \n    let block = lookup_block(hash)\n        .ok_or(StatusCode::NOT_FOUND)?;\n    \n    // Default to binary, but could negotiate\n    let format = WireFormat::binary();\n    let encoded = format.encode(&block)\n        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;\n    \n    Response::builder()\n        .header("content-type", format.content_type())\n        .body(encoded.into())\n        .unwrap()\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"client-implementation",children:"Client Implementation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use reqwest::Client;\n\nstruct BlockClient {\n    client: Client,\n    base_url: String,\n    preferred_format: WireFormat,\n}\n\nimpl BlockClient {\n    pub fn new(base_url: String) -> Self {\n        Self {\n            client: Client::new(),\n            base_url,\n            preferred_format: WireFormat::msgpack(), // Efficient default\n        }\n    }\n    \n    pub async fn submit_block<P: BlockPayload>(\n        &self,\n        block: &Block<P>\n    ) -> Result<(), Box<dyn std::error::Error>> {\n        let encoded = self.preferred_format.encode(block)?;\n        \n        let response = self.client\n            .post(&format!("{}/blocks", self.base_url))\n            .header("content-type", self.preferred_format.content_type())\n            .body(encoded)\n            .send()\n            .await?;\n        \n        if response.status().is_success() {\n            Ok(())\n        } else {\n            Err(format!("Server error: {}", response.status()).into())\n        }\n    }\n    \n    pub async fn get_block<P: BlockPayload + From<Vec<u8>>>(\n        &self,\n        hash: &[u8; 32]\n    ) -> Result<Block<P>, Box<dyn std::error::Error>> {\n        let hash_hex = hex::encode(hash);\n        let url = format!("{}/blocks?hash={}", self.base_url, hash_hex);\n        \n        let response = self.client.get(&url).send().await?;\n        let data = response.bytes().await?;\n        \n        // Try to detect format from content-type\n        let content_type = response.headers()\n            .get("content-type")\n            .and_then(|v| v.to_str().ok())\n            .unwrap_or("application/x-olocus-block");\n        \n        let format = WireFormat::from_content_type(content_type)\n            .unwrap_or(WireFormat::binary());\n        \n        Ok(format.decode(&data)?)\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-and-feature-flags",children:"Configuration and Feature Flags"}),"\n",(0,t.jsx)(n.h3,{id:"cargo-features",children:"Cargo Features"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# In Cargo.toml\n[dependencies]\nolocus-core = { version = "1.16.1", features = ["compression-zstd"] }\n\n# Available features:\n# - compression-zstd: Enable Zstd compression (requires libclang)\n# - default: Core functionality only\n'})}),"\n",(0,t.jsx)(n.h3,{id:"runtime-feature-detection",children:"Runtime Feature Detection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Check if Zstd is available\nlet format = WireFormat::new(EncodingFormat::Binary, CompressionMethod::Zstd);\n\n#[cfg(feature = "compression-zstd")]\n{\n    // Zstd is available\n    let compressed = format.encode(&block)?;\n}\n\n#[cfg(not(feature = "compression-zstd"))]\n{\n    // Will automatically fall back to LZ4\n    let compressed = format.encode(&block)?;\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-conditions",children:"Error Conditions"}),"\n",(0,t.jsx)(n.p,{children:"Common error scenarios and handling:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use olocus_core::Error;\n\n// Malformed data\nmatch format.decode::<MyPayload>(&corrupted_data) {\n    Err(Error::MalformedBlock) => {\n        // Data is corrupted, wrong format, or incomplete\n        eprintln!("Block data is malformed");\n    }\n    _ => {}\n}\n\n// Unsupported content type\nif let Some(format) = WireFormat::from_content_type("text/plain") {\n    // This will be None - content type not supported\n} else {\n    eprintln!("Content type \'text/plain\' is not supported");\n}\n\n// Compression errors (rare - usually indicate system issues)\nmatch format.encode(&block) {\n    Err(Error::MalformedBlock) => {\n        // Could indicate compression failure\n        eprintln!("Failed to compress block data");\n    }\n    _ => {}\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"format-selection-guidelines",children:"Format Selection Guidelines"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Binary"}),": Default choice for production systems"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Fastest and most compact"}),"\n",(0,t.jsx)(n.li,{children:"Use for block storage and high-performance networks"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"MessagePack"}),": Good balance of efficiency and flexibility"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use for APIs where some human readability is helpful"}),"\n",(0,t.jsx)(n.li,{children:"Better than JSON for network protocols"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"JSON"}),": Use only for debugging and development"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Human readable but larger and slower"}),"\n",(0,t.jsx)(n.li,{children:"Good for testing and diagnostics"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"SSZ"}),": Use for Ethereum ecosystem integration"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Required for some blockchain interoperability"}),"\n",(0,t.jsx)(n.li,{children:"Merkle-tree friendly"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Protobuf"}),": Use for cross-language systems"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When working with non-Rust systems"}),"\n",(0,t.jsx)(n.li,{children:"Schema evolution requirements"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"compression-guidelines",children:"Compression Guidelines"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"None"}),": Use for small blocks or when CPU is constrained"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LZ4"}),": Good default for real-time systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zstd"}),": Best for storage or when compression ratio matters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Gzip"}),": Use only for HTTP compatibility requirements"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-tips",children:"Implementation Tips"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Cache format instances\nstruct FormatCache {\n    binary: WireFormat,\n    json: WireFormat,\n    msgpack_compressed: WireFormat,\n}\n\nimpl Default for FormatCache {\n    fn default() -> Self {\n        Self {\n            binary: WireFormat::binary(),\n            json: WireFormat::json(),\n            msgpack_compressed: WireFormat::new(\n                EncodingFormat::MessagePack,\n                CompressionMethod::Zstd,\n            ),\n        }\n    }\n}\n\n// Validate round-trip for custom payloads\nfn test_format_roundtrip<P: BlockPayload + From<Vec<u8>> + PartialEq>(\n    block: &Block<P>,\n    format: WireFormat\n) -> bool {\n    if let Ok(encoded) = format.encode(block) {\n        if let Ok(decoded) = format.decode::<P>(&encoded) {\n            return *block == decoded;\n        }\n    }\n    false\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./block-operations",children:"Block Operations API"})," - Working with blocks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./core",children:"Core API Overview"})," - Protocol fundamentals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./error-handling",children:"Error Handling"})," - Error codes and handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../extensions/http",children:"HTTP Extension"})," - HTTP server implementation"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);