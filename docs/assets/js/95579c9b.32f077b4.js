"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[3212],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},8677:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"getting-started/understanding-measurements","title":"Understanding Measurements","description":"The Universal Measurement Foundation is what makes Olocus Protocol unique. Every piece of data can be represented with uncertainty, provenance, and validity.","source":"@site/docs/getting-started/understanding-measurements.md","sourceDirName":"getting-started","slug":"/getting-started/understanding-measurements","permalink":"/docs/getting-started/understanding-measurements","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/getting-started/understanding-measurements.md","tags":[],"version":"current","lastUpdatedAt":1764953024000,"sidebarPosition":4,"frontMatter":{"id":"understanding-measurements","title":"Understanding Measurements","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Building Your First Chain","permalink":"/docs/getting-started/first-chain"},"next":{"title":"Choosing Extensions","permalink":"/docs/getting-started/choosing-extensions"}}');var i=t(4848),r=t(8453);const s={id:"understanding-measurements",title:"Understanding Measurements",sidebar_position:4},o="Understanding Measurements",c={},l=[{value:"Why Measurements Matter",id:"why-measurements-matter",level:2},{value:"Quick Example",id:"quick-example",level:2},{value:"Core Components",id:"core-components",level:2},{value:"1. Value - The What",id:"1-value---the-what",level:3},{value:"2. Uncertainty - The How Sure",id:"2-uncertainty---the-how-sure",level:3},{value:"3. Provenance - The Where From",id:"3-provenance---the-where-from",level:3},{value:"4. Validity - The When",id:"4-validity---the-when",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Weather Sensor",id:"weather-sensor",level:3},{value:"ML Prediction",id:"ml-prediction",level:3},{value:"User-Reported Data",id:"user-reported-data",level:3},{value:"Geographic Data with Extended Geometry",id:"geographic-data-with-extended-geometry",level:3},{value:"Temporal Event Sequences",id:"temporal-event-sequences",level:3},{value:"Financial and Precise Numeric Data",id:"financial-and-precise-numeric-data",level:3},{value:"Structured Data and References",id:"structured-data-and-references",level:3},{value:"Pattern Matching and Validation",id:"pattern-matching-and-validation",level:3},{value:"Custom Domain Extensions",id:"custom-domain-extensions",level:3},{value:"Fixed-Point Coordinates",id:"fixed-point-coordinates",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Include Uncertainty",id:"1-always-include-uncertainty",level:3},{value:"2. Track Provenance",id:"2-track-provenance",level:3},{value:"3. Set Appropriate Validity",id:"3-set-appropriate-validity",level:3},{value:"4. Use Fixed-Point for Geography",id:"4-use-fixed-point-for-geography",level:3},{value:"5. Add Attestations When Available",id:"5-add-attestations-when-available",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Sensor Fusion",id:"sensor-fusion",level:3},{value:"Privacy Obfuscation",id:"privacy-obfuscation",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"understanding-measurements",children:"Understanding Measurements"})}),"\n",(0,i.jsx)(n.p,{children:"The Universal Measurement Foundation is what makes Olocus Protocol unique. Every piece of data can be represented with uncertainty, provenance, and validity."}),"\n",(0,i.jsx)(n.h2,{id:"why-measurements-matter",children:"Why Measurements Matter"}),"\n",(0,i.jsx)(n.p,{children:"In the real world, data is never perfect:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"GPS coordinates have accuracy limitations"}),"\n",(0,i.jsx)(n.li,{children:"Sensor readings have noise"}),"\n",(0,i.jsx)(n.li,{children:"Predictions have confidence levels"}),"\n",(0,i.jsx)(n.li,{children:"Data gets stale over time"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The Olocus Protocol embraces this reality with its measurement system."}),"\n",(0,i.jsx)(n.h2,{id:"quick-example",children:"Quick Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a GPS reading with all its real-world context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_core::{Measurement, Value, Uncertainty, Provenance, Source};\n\nlet gps_reading = Measurement {\n    // The actual location (San Francisco)\n    value: Value::Point2D {\n        lat: 377749000,  // 37.7749\xb0 \xd7 10^7\n        lon: -1224194000, // -122.4194\xb0 \xd7 10^7\n    },\n    \n    // How accurate? (10 meter radius)\n    uncertainty: Uncertainty::Circular {\n        angle: 0.0,\n        radius: 10.0,\n    },\n    \n    // Where did it come from?\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: [0; 32],\n            sensor_type: 0x0001, // GPS\n            calibration_id: None,\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    \n    // How long is it valid?\n    validity: ValidityWindow::new(\n        now,\n        Some(now + 300) // Valid for 5 minutes\n    ),\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,i.jsx)(n.h3,{id:"1-value---the-what",children:"1. Value - The What"}),"\n",(0,i.jsx)(n.p,{children:"The actual data, supporting 36 types across multiple categories:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// === Absence and Primitives ===\nValue::None                      // No value present\nValue::Bool(true)                // Boolean\nValue::Int(42)                   // Signed 64-bit integer\nValue::UInt(100)                 // Unsigned 64-bit integer\nValue::Float(22.5)              // 64-bit floating point\nValue::Decimal { value: 1999, scale: 2 } // Exact precision ($19.99)\n\n// === Text and Binary ===\nValue::String("Hello".to_string()) // UTF-8 string\nValue::Bytes(vec![0x01, 0x02])     // Raw bytes\nValue::Hash256([0u8; 32])          // SHA-256 hash\nValue::Hash512([0u8; 64])          // SHA-512 hash\n\n// === Temporal ===\nValue::Timestamp(1234567890)       // Unix timestamp (seconds)\nValue::TimestampNanos { seconds: 1234567890, nanos: 123456 } // Nanosecond precision\nValue::Duration(3600_000_000_000)  // Duration in nanoseconds\nValue::Date { year: 2023, month: 12, day: 25 }              // Calendar date\nValue::Time { hour: 14, minute: 30, second: 0, nanos: 0 }   // Time of day\nValue::DateTime { year: 2023, month: 12, day: 25, hour: 14, // Full datetime\n                  minute: 30, second: 0, nanos: 0, tz_offset_minutes: -480 }\n\n// === Collections ===\nValue::Array(vec![...])         // Ordered lists\nValue::Object(map)              // Key-value maps (BTreeMap)\nValue::Set(set)                 // Unique values (BTreeSet)\n\n// === Spatial (fixed-point coordinates) ===\nValue::Point2D { lat, lon }     // 2D location\nValue::Point3D { lat, lon, alt } // 3D location with altitude\nValue::BoundingBox { min_lat, min_lon, max_lat, max_lon } // Rectangular area\n\n// === Extended Geometry (GeoJSON-compatible) ===\nValue::LineString(points)       // Path of connected points\nValue::Polygon { exterior, holes } // Polygon with potential holes\nValue::MultiPoint(points)       // Collection of points\nValue::MultiLineString(lines)   // Collection of line strings\nValue::MultiPolygon(polygons)   // Collection of polygons\nValue::GeometryCollection(geoms) // Mixed geometry types\n\n// === Identifiers ===\nValue::UUID([0u8; 16])          // Universally Unique Identifier\n\n// === Ranges and Patterns ===\nValue::Range { start, end, start_inclusive, end_inclusive } // Value ranges\nValue::Regex("^\\d{3}-\\d{3}-\\d{4}$".to_string()) // Regular expressions\n\n// === References ===\nValue::BlockRef([0u8; 32])      // Reference to another block\nValue::SchemaRef { namespace, name, version } // Schema reference\nValue::Record { table, id }     // Database record reference\n\n// === Structured ===\nValue::Json(bytes)              // Raw JSON document\n\n// === Extension Point ===\nValue::Extension { type_id, data } // Custom domain-specific types\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-uncertainty---the-how-sure",children:"2. Uncertainty - The How Sure"}),"\n",(0,i.jsx)(n.p,{children:"Quantify confidence in the measurement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// GPS accuracy (circular error)\nUncertainty::Circular {\n    angle: 0.0,\n    radius: 10.0  // 10 meters\n}\n\n// Temperature sensor (normal distribution)\nUncertainty::Gaussian {\n    std_dev: 0.1  // \xb10.1\xb0C\n}\n\n// Prediction confidence\nUncertainty::Confidence {\n    level: 0.95  // 95% confident\n}\n\n// When you don't know\nUncertainty::Unknown\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-provenance---the-where-from",children:"3. Provenance - The Where From"}),"\n",(0,i.jsx)(n.p,{children:"Track the data's journey:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"Provenance {\n    // Original source\n    source: Source::Sensor {\n        device_id: device_id,\n        sensor_type: 0x0001,\n        calibration_id: Some(cal_id),\n    },\n    \n    // What happened to it\n    transformations: vec![\n        Transformation {\n            operation: TransformationOp::Filter {\n                algorithm: 0x0001, // Kalman\n                parameters: vec![],\n            },\n            timestamp: timestamp,\n            actor: processor_id,\n            input_hash: original_hash,\n        }\n    ],\n    \n    // Who verified it\n    attestations: vec![\n        Attestation {\n            attestor: witness_id,\n            claim: AttestationClaim::Witnessed,\n            signature: signature,\n            timestamp: witness_time,\n        }\n    ],\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-validity---the-when",children:"4. Validity - The When"}),"\n",(0,i.jsx)(n.p,{children:"Define temporal validity:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Valid forever (e.g., historical fact)\nValidityWindow::perpetual()\n\n// Valid for a period\nValidityWindow::new(\n    start_time,\n    Some(end_time)\n)\n\n// Decaying value (e.g., prediction)\nValidityWindow {\n    start: now,\n    end: Some(now + 86400),\n    decay: Some(DecayFunction::Exponential {\n        half_life: 3600  // Loses half value per hour\n    })\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(n.h3,{id:"weather-sensor",children:"Weather Sensor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let temperature = Measurement {\n    value: Value::Float(22.5),\n    uncertainty: Uncertainty::Gaussian { std_dev: 0.1 },\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: sensor_id,\n            sensor_type: 0x0002,\n            calibration_id: Some(cal_id),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::new(now, Some(now + 3600)),\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ml-prediction",children:"ML Prediction"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let prediction = Measurement {\n    value: Value::Float(0.87), // 87% probability\n    uncertainty: Uncertainty::Confidence { level: 0.95 },\n    provenance: Provenance {\n        source: Source::Derived {\n            algorithm_id: 0x2000,\n            input_hashes: vec![data_hash],\n        },\n        transformations: vec![],\n        attestations: vec![validator_attestation],\n    },\n    validity: ValidityWindow::new(now, Some(now + 600)),\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"user-reported-data",children:"User-Reported Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let user_report = Measurement {\n    value: Value::String("Road closed".to_string()),\n    uncertainty: Uncertainty::Unknown,\n    provenance: Provenance {\n        source: Source::SelfReported {\n            reporter_id: user_id,\n            method: 0x0001, // Manual entry\n        },\n        transformations: vec![],\n        attestations: vec![], // Could add witness attestations\n    },\n    validity: ValidityWindow::new(now, Some(now + 7200)),\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"geographic-data-with-extended-geometry",children:"Geographic Data with Extended Geometry"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Delivery route using LineString\nlet delivery_route = Measurement {\n    value: Value::linestring(&[\n        (37.7749, -122.4194), // Start: San Francisco\n        (37.7849, -122.4094), // Waypoint 1\n        (37.7949, -122.3994), // End: Destination\n    ]),\n    uncertainty: Uncertainty::Interval {\n        lower_bound: -5.0,  // \xb15 meter accuracy\n        upper_bound: 5.0,\n        confidence: 0.95,\n    },\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: gps_device_id,\n            sensor_type: 0x0001, // GPS\n            calibration_id: Some(gps_calibration_id),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::new(now, Some(now + 3600)), // Valid for 1 hour\n};\n\n// Service area coverage using Polygon\nlet service_area = Measurement {\n    value: Value::polygon(\n        &[  // Exterior boundary\n            (37.7000, -122.5000),\n            (37.7000, -122.3000),\n            (37.8000, -122.3000),\n            (37.8000, -122.5000),\n            (37.7000, -122.5000), // Close the ring\n        ],\n        &[  // Holes (excluded areas)\n            &[(37.7300, -122.4300), (37.7300, -122.4100), \n              (37.7500, -122.4100), (37.7500, -122.4300), (37.7300, -122.4300)]\n        ]\n    ),\n    uncertainty: Uncertainty::Exact, // Defined boundary\n    provenance: Provenance {\n        source: Source::SelfReported {\n            reporter_id: business_id,\n            method: 0x0002, // Geographic tool\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::indefinite(), // Service area doesn't change often\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"temporal-event-sequences",children:"Temporal Event Sequences"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Precise event timing with nanosecond accuracy\nlet system_event = Measurement {\n    value: Value::TimestampNanos {\n        seconds: 1640995200,    // 2022-01-01 00:00:00 UTC\n        nanos: 123456789,       // Additional nanoseconds\n    },\n    uncertainty: Uncertainty::Interval {\n        lower_bound: -0.001,    // \xb11ms accuracy\n        upper_bound: 0.001,\n        confidence: 0.999,\n    },\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: atomic_clock_id,\n            sensor_type: 0x0010, // Atomic clock\n            calibration_id: Some(nist_calibration_id),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::new(now, Some(now + 1)), // Valid for 1 second\n};\n\n// Date without time (for events, birthdays, etc.)\nlet birth_date = Measurement {\n    value: Value::Date {\n        year: 1990,\n        month: 6,\n        day: 15,\n    },\n    uncertainty: Uncertainty::Exact, // Exact known date\n    provenance: Provenance {\n        source: Source::SelfReported {\n            reporter_id: user_id,\n            method: 0x0001, // Form entry\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::indefinite(), // Birth date doesn't change\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"financial-and-precise-numeric-data",children:"Financial and Precise Numeric Data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Financial transaction using Decimal for exact precision\nlet transaction_amount = Measurement {\n    value: Value::Decimal {\n        value: 1234567,  // $12,345.67 stored as 1234567 cents\n        scale: 2,        // 2 decimal places\n    },\n    uncertainty: Uncertainty::Exact, // Exact financial amount\n    provenance: Provenance {\n        source: Source::Oracle {\n            oracle_id: payment_processor_id,\n            query_id: Some(transaction_id),\n        },\n        transformations: vec![],\n        attestations: vec![\n            Attestation {\n                attestor: bank_id,\n                claim: AttestationClaim::Verified {\n                    reference_id: bank_record_id,\n                },\n                signature: bank_signature,\n                timestamp: transaction_time,\n            }\n        ],\n    },\n    validity: ValidityWindow::new(transaction_time, Some(transaction_time + 86400 * 7)), // Valid for 1 week\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"structured-data-and-references",children:"Structured Data and References"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Complex sensor reading using Object\nlet environmental_reading = Measurement {\n    value: {\n        let mut readings = std::collections::BTreeMap::new();\n        readings.insert("temperature".to_string(), Value::Float(23.5));\n        readings.insert("humidity".to_string(), Value::Float(65.0));\n        readings.insert("pressure".to_string(), Value::Float(1013.25));\n        readings.insert("location".to_string(), Value::point2d(37.7749, -122.4194));\n        readings.insert("device_id".to_string(), Value::UUID(sensor_uuid));\n        Value::Object(readings)\n    },\n    uncertainty: Uncertainty::Gaussian { std_dev: 1.0 }, // Combined uncertainty\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: weather_station_id,\n            sensor_type: 0x0020, // Multi-sensor weather station\n            calibration_id: Some(calibration_id),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::decaying(1800, 600), // Valid for 30 minutes, decays with 10-min half-life\n};\n\n// Reference to related data\nlet analysis_result = Measurement {\n    value: Value::Record {\n        table: "analyses".to_string(),\n        id: "weather_analysis_20240101".to_string(),\n    },\n    uncertainty: Uncertainty::confidence(0.92), // 92% confidence in analysis\n    provenance: Provenance {\n        source: Source::Derived {\n            algorithm_id: 0x3001, // Weather analysis algorithm\n            inputs: vec![environmental_reading_hash],\n            parameters: Some(analysis_params),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::new(now, Some(now + 86400)), // Valid for 24 hours\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"pattern-matching-and-validation",children:"Pattern Matching and Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Data validation using regex patterns\nlet phone_validation = Measurement {\n    value: Value::Regex(r"^\\+1\\d{10}$".to_string()), // US phone number pattern\n    uncertainty: Uncertainty::Exact, // Pattern is exactly defined\n    provenance: Provenance {\n        source: Source::SelfReported {\n            reporter_id: system_admin_id,\n            method: 0x0003, // Configuration\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::indefinite(), // Validation rules are stable\n};\n\n// Value range constraints\nlet temperature_range = Measurement {\n    value: Value::range_inclusive(\n        Value::Float(-40.0),  // Minimum valid temperature\n        Value::Float(85.0),   // Maximum valid temperature\n    ),\n    uncertainty: Uncertainty::Exact, // Range is exactly defined\n    provenance: Provenance {\n        source: Source::Oracle {\n            oracle_id: equipment_spec_id,\n            query_id: Some(sensor_spec_id),\n        },\n        transformations: vec![],\n        attestations: vec![],\n    },\n    validity: ValidityWindow::indefinite(), // Sensor specs don\'t change often\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-domain-extensions",children:"Custom Domain Extensions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Biometric data using Extension type\nlet fingerprint_data = Measurement {\n    value: Value::Extension {\n        type_id: 0x8001,                    // Biometric data type\n        data: biometric_encoder.encode(&fingerprint_template),\n    },\n    uncertainty: Uncertainty::confidence(0.999), // Very high confidence\n    provenance: Provenance {\n        source: Source::Sensor {\n            device_id: fingerprint_scanner_id,\n            sensor_type: 0x0030, // Fingerprint scanner\n            calibration_id: Some(fbi_certification_id),\n        },\n        transformations: vec![\n            Transformation {\n                operation: TransformationOp::Custom {\n                    type_id: 0x8001,        // Biometric processing\n                    parameters: privacy_params,\n                },\n                timestamp: scan_time,\n                actor: biometric_processor_id,\n                input_hash: raw_scan_hash,\n            }\n        ],\n        attestations: vec![\n            Attestation {\n                attestor: security_officer_id,\n                claim: AttestationClaim::DeviceCertified {\n                    certification_id: fbi_cert_id,\n                },\n                signature: officer_signature,\n                timestamp: certification_time,\n            }\n        ],\n    },\n    validity: ValidityWindow::new(scan_time, Some(scan_time + 300)), // Valid for 5 minutes\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fixed-point-coordinates",children:"Fixed-Point Coordinates"}),"\n",(0,i.jsx)(n.p,{children:"For cross-platform consistency, spatial coordinates use fixed-point arithmetic:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Degrees to fixed-point (\xd7 10^7)\nlet lat_fixed = Coordinate::latitude_to_fixed(37.7749);\n// Result: 377749000\n\n// Back to degrees\nlet lat_degrees = Coordinate::fixed_to_latitude(377749000);\n// Result: 37.7749\n\n// Calculate distance\nlet distance = Coordinate::haversine_distance(\n    lat1, lon1,\n    lat2, lon2\n); // Returns meters\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-always-include-uncertainty",children:"1. Always Include Uncertainty"}),"\n",(0,i.jsx)(n.p,{children:"Even if unknown, explicitly state it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"uncertainty: Uncertainty::Unknown\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-track-provenance",children:"2. Track Provenance"}),"\n",(0,i.jsx)(n.p,{children:"Know where your data comes from:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"source: Source::Sensor { ... }\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-set-appropriate-validity",children:"3. Set Appropriate Validity"}),"\n",(0,i.jsx)(n.p,{children:"Data gets stale:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"validity: ValidityWindow::new(now, Some(now + 300))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-use-fixed-point-for-geography",children:"4. Use Fixed-Point for Geography"}),"\n",(0,i.jsx)(n.p,{children:"Ensures consistency across platforms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"lat: Coordinate::latitude_to_fixed(degrees)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-add-attestations-when-available",children:"5. Add Attestations When Available"}),"\n",(0,i.jsx)(n.p,{children:"Third-party verification adds trust:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"attestations: vec![witness_attestation]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"sensor-fusion",children:"Sensor Fusion"}),"\n",(0,i.jsx)(n.p,{children:"Combine multiple measurements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fused = Measurement {\n    value: weighted_average(&measurements),\n    uncertainty: combined_uncertainty(&measurements),\n    provenance: Provenance {\n        source: Source::Derived {\n            algorithm_id: 0x3000, // Sensor fusion\n            input_hashes: measurement_hashes,\n        },\n        ...\n    },\n    ...\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"privacy-obfuscation",children:"Privacy Obfuscation"}),"\n",(0,i.jsx)(n.p,{children:"Add controlled noise:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let obfuscated = Measurement {\n    value: add_noise(original_value, epsilon),\n    uncertainty: Uncertainty::Interval {\n        lower: value - radius,\n        upper: value + radius,\n        confidence: 0.95,\n    },\n    provenance: Provenance {\n        transformations: vec![\n            Transformation {\n                operation: TransformationOp::Obfuscate {\n                    method: 0x0001, // Differential privacy\n                    level: 2,\n                },\n                ...\n            }\n        ],\n        ...\n    },\n    ...\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand measurements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"./choosing-extensions",children:"Choose your extensions"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"../api/measurement-api",children:"Explore the Measurement API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"../extensions/privacy/techniques",children:"Learn about privacy techniques"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"../tutorials/location-tracker",children:"Build a location tracker"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);