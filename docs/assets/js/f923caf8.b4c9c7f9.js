"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[5883],{4182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>_,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"extensions/security/keystore","title":"Keystore Management","description":"The Keystore extension provides secure key derivation, storage, and lifecycle management across multiple platforms with BIP-32/44 support and hardware-backed security.","source":"@site/docs/extensions/security/keystore.md","sourceDirName":"extensions/security","slug":"/extensions/security/keystore","permalink":"/docs/extensions/security/keystore","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/security/keystore.md","tags":[],"version":"current","lastUpdatedAt":null,"sidebarPosition":4,"frontMatter":{"id":"keystore","title":"Keystore Management","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"HSM Integration","permalink":"/docs/extensions/security/hsm-integration"},"next":{"title":"Post-Quantum Cryptography","permalink":"/docs/extensions/security/post-quantum"}}');var i=t(4848),r=t(8453);const o={id:"keystore",title:"Keystore Management",sidebar_position:4},s="Keystore Management",c={},l=[{value:"Overview",id:"overview",level:2},{value:"BIP-32 Hierarchical Deterministic Keys",id:"bip-32-hierarchical-deterministic-keys",level:2},{value:"BIP-32 Implementation",id:"bip-32-implementation",level:3},{value:"BIP-44 Multi-Account Structure",id:"bip-44-multi-account-structure",level:3},{value:"Platform-Specific Secure Storage",id:"platform-specific-secure-storage",level:2},{value:"iOS Keychain Integration",id:"ios-keychain-integration",level:3},{value:"Android Keystore Integration",id:"android-keystore-integration",level:3},{value:"Key Rotation Management",id:"key-rotation-management",level:2},{value:"Automatic Key Rotation",id:"automatic-key-rotation",level:3},{value:"Backup and Recovery",id:"backup-and-recovery",level:3},{value:"Testing &amp; Integration",id:"testing--integration",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"keystore-management",children:"Keystore Management"})}),"\n",(0,i.jsx)(n.p,{children:"The Keystore extension provides secure key derivation, storage, and lifecycle management across multiple platforms with BIP-32/44 support and hardware-backed security."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The Keystore extension offers comprehensive key management capabilities:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key Derivation"}),": BIP-32, BIP-44 hierarchical deterministic wallets"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Secure Storage"}),": iOS Keychain, Android Keystore, Windows DPAPI"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key Rotation"}),": Automatic rotation with configurable policies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Backup & Recovery"}),": Mnemonic phrases, encrypted backups"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Access Control"}),": Biometric authentication, PIN protection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Platform"}),": Unified API across mobile and desktop platforms"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_keystore::*;\n\n// Configure keystore\nlet keystore_config = KeystoreConfig {\n    backend: KeystoreBackend::Platform, // Use platform-specific secure storage\n    derivation_method: KeyDerivationMethod::BIP44 {\n        coin_type: 0,        // Bitcoin coin type\n        account: 0,          // First account\n    },\n    encryption: EncryptionConfig {\n        algorithm: EncryptionAlgorithm::AES256GCM,\n        key_derivation: KeyDerivationFunction::PBKDF2 {\n            iterations: 100000,\n            salt_length: 32,\n        },\n    },\n    rotation_policy: RotationPolicy {\n        enabled: true,\n        interval: Duration::from_days(90),\n        advance_warning: Duration::from_days(7),\n    },\n};\n\nlet keystore = Keystore::new(keystore_config).await?;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"bip-32-hierarchical-deterministic-keys",children:"BIP-32 Hierarchical Deterministic Keys"}),"\n",(0,i.jsx)(n.p,{children:"BIP-32 enables deterministic key derivation from a single master seed:"}),"\n",(0,i.jsx)(n.h3,{id:"bip-32-implementation",children:"BIP-32 Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_keystore::bip32::*;\nuse olocus_keystore::bip39::*;\n\npub struct BIP32KeyDerivation {\n    master_seed: [u8; 64],           // 512-bit master seed\n    master_key: ExtendedKey,         // Master extended key\n    derivation_cache: LruCache<String, DerivedKey>,\n}\n\n#[derive(Debug, Clone)]\npub struct ExtendedKey {\n    pub key: PrivateKey,             // 32-byte private key\n    pub chain_code: [u8; 32],        // 32-byte chain code\n    pub depth: u8,                   // Derivation depth\n    pub parent_fingerprint: [u8; 4], // Parent key fingerprint\n    pub child_index: u32,            // Child key index\n}\n\nimpl KeyDerivationMethod for BIP32KeyDerivation {\n    fn derive_key(&mut self, path: &DerivationPath) -> Result<DerivedKey> {\n        let path_string = path.to_string();\n        \n        // Check cache first\n        if let Some(cached_key) = self.derivation_cache.get(&path_string) {\n            return Ok(cached_key.clone());\n        }\n        \n        // Derive key step by step\n        let mut current_key = self.master_key.clone();\n        \n        for &index in &path.indices {\n            current_key = self.derive_child_key(&current_key, index)?;\n        }\n        \n        let derived_key = DerivedKey {\n            private_key: current_key.key,\n            public_key: current_key.key.public_key(),\n            chain_code: current_key.chain_code,\n            path: path.clone(),\n            fingerprint: self.calculate_fingerprint(&current_key.key.public_key()),\n        };\n        \n        // Cache the result\n        self.derivation_cache.insert(path_string, derived_key.clone());\n        \n        Ok(derived_key)\n    }\n    \n    fn derive_child_key(&self, parent: &ExtendedKey, index: u32) -> Result<ExtendedKey> {\n        let is_hardened = index >= 0x80000000;\n        \n        // Prepare data for HMAC\n        let mut hmac_data = Vec::new();\n        \n        if is_hardened {\n            // Hardened derivation: use private key\n            hmac_data.push(0x00); // Padding byte\n            hmac_data.extend_from_slice(&parent.key.as_bytes());\n        } else {\n            // Non-hardened derivation: use public key\n            hmac_data.extend_from_slice(&parent.key.public_key().as_bytes());\n        }\n        \n        hmac_data.extend_from_slice(&index.to_be_bytes());\n        \n        // HMAC-SHA512 with chain code as key\n        let hmac_result = hmac_sha512(&parent.chain_code, &hmac_data);\n        \n        // Split result: left 32 bytes = key material, right 32 bytes = chain code\n        let key_material = &hmac_result[..32];\n        let chain_code: [u8; 32] = hmac_result[32..].try_into().unwrap();\n        \n        // Derive child private key\n        let child_key = self.add_private_keys(&parent.key, key_material)?;\n        \n        // Calculate parent fingerprint\n        let parent_public = parent.key.public_key();\n        let parent_fingerprint = self.calculate_fingerprint(&parent_public)[..4].try_into().unwrap();\n        \n        Ok(ExtendedKey {\n            key: child_key,\n            chain_code,\n            depth: parent.depth + 1,\n            parent_fingerprint,\n            child_index: index,\n        })\n    }\n    \n    fn from_mnemonic(mnemonic: &str, passphrase: Option<&str>) -> Result<Self> {\n        // Validate mnemonic\n        if !Mnemonic::validate(mnemonic) {\n            return Err(KeystoreError::InvalidMnemonic);\n        }\n        \n        // Generate seed from mnemonic\n        let seed = Mnemonic::to_seed(mnemonic, passphrase.unwrap_or(""));\n        \n        // Generate master key\n        let hmac_result = hmac_sha512(b"Bitcoin seed", &seed);\n        let master_key_bytes = &hmac_result[..32];\n        let master_chain_code: [u8; 32] = hmac_result[32..].try_into().unwrap();\n        \n        let master_private_key = PrivateKey::from_bytes(master_key_bytes)?;\n        \n        let master_key = ExtendedKey {\n            key: master_private_key,\n            chain_code: master_chain_code,\n            depth: 0,\n            parent_fingerprint: [0; 4],\n            child_index: 0,\n        };\n        \n        Ok(Self {\n            master_seed: seed,\n            master_key,\n            derivation_cache: LruCache::new(100),\n        })\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"bip-44-multi-account-structure",children:"BIP-44 Multi-Account Structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use olocus_keystore::bip44::*;\n\npub struct BIP44KeyManager {\n    derivation: BIP32KeyDerivation,\n    coin_type: u32,\n    accounts: HashMap<u32, AccountInfo>,\n}\n\n#[derive(Debug, Clone)]\npub struct AccountInfo {\n    pub account_index: u32,\n    pub external_chain_index: u32,  // Receiving addresses\n    pub internal_chain_index: u32,  // Change addresses\n    pub keys: HashMap<(u32, u32), DerivedKey>, // (chain, index) -> key\n}\n\nimpl BIP44KeyManager {\n    pub fn new(mnemonic: &str, coin_type: u32) -> Result<Self> {\n        let derivation = BIP32KeyDerivation::from_mnemonic(mnemonic, None)?;\n        \n        Ok(Self {\n            derivation,\n            coin_type,\n            accounts: HashMap::new(),\n        })\n    }\n    \n    pub fn derive_account_key(&mut self, account: u32) -> Result<DerivedKey> {\n        // BIP-44 path: m/44'/coin_type'/account'\n        let path = DerivationPath::new(vec![\n            44 | 0x80000000,           // Purpose (hardened)\n            self.coin_type | 0x80000000, // Coin type (hardened)\n            account | 0x80000000,       // Account (hardened)\n        ])?;\n        \n        self.derivation.derive_key(&path)\n    }\n    \n    pub fn derive_address_key(\n        &mut self,\n        account: u32,\n        is_change: bool,\n        index: u32\n    ) -> Result<DerivedKey> {\n        // BIP-44 path: m/44'/coin_type'/account'/change/address_index\n        let change = if is_change { 1 } else { 0 };\n        \n        let path = DerivationPath::new(vec![\n            44 | 0x80000000,           // Purpose (hardened)\n            self.coin_type | 0x80000000, // Coin type (hardened)\n            account | 0x80000000,       // Account (hardened)\n            change,                     // Change (non-hardened)\n            index,                      // Address index (non-hardened)\n        ])?;\n        \n        let derived_key = self.derivation.derive_key(&path)?;\n        \n        // Track key in account info\n        let account_info = self.accounts.entry(account).or_insert_with(|| AccountInfo {\n            account_index: account,\n            external_chain_index: 0,\n            internal_chain_index: 0,\n            keys: HashMap::new(),\n        });\n        \n        account_info.keys.insert((change, index), derived_key.clone());\n        \n        // Update chain index\n        if is_change {\n            account_info.internal_chain_index = account_info.internal_chain_index.max(index + 1);\n        } else {\n            account_info.external_chain_index = account_info.external_chain_index.max(index + 1);\n        }\n        \n        Ok(derived_key)\n    }\n    \n    pub fn get_next_receiving_key(&mut self, account: u32) -> Result<DerivedKey> {\n        let account_info = self.accounts.entry(account).or_insert_with(|| AccountInfo {\n            account_index: account,\n            external_chain_index: 0,\n            internal_chain_index: 0,\n            keys: HashMap::new(),\n        });\n        \n        let index = account_info.external_chain_index;\n        self.derive_address_key(account, false, index)\n    }\n    \n    pub fn get_next_change_key(&mut self, account: u32) -> Result<DerivedKey> {\n        let account_info = self.accounts.entry(account).or_insert_with(|| AccountInfo {\n            account_index: account,\n            external_chain_index: 0,\n            internal_chain_index: 0,\n            keys: HashMap::new(),\n        });\n        \n        let index = account_info.internal_chain_index;\n        self.derive_address_key(account, true, index)\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"platform-specific-secure-storage",children:"Platform-Specific Secure Storage"}),"\n",(0,i.jsx)(n.h3,{id:"ios-keychain-integration",children:"iOS Keychain Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_keystore::ios::*;\nuse security_framework::keychain::*;\n\npub struct IOSKeychainBackend {\n    service_name: String,\n    access_group: Option<String>,\n    accessibility: KeychainAccessibility,\n    require_biometry: bool,\n}\n\n#[derive(Debug, Clone)]\npub enum KeychainAccessibility {\n    WhenUnlocked,                    // Available when device unlocked\n    WhenUnlockedThisDeviceOnly,     // Device-specific, when unlocked\n    AfterFirstUnlock,               // Available after first unlock\n    WhenPasscodeSetThisDeviceOnly,  // Requires passcode, device-specific\n    BiometryAny,                    // Biometry required (Touch ID/Face ID)\n    BiometryCurrentSet,             // Current biometry enrollment required\n}\n\nimpl KeystoreBackend for IOSKeychainBackend {\n    async fn store_key(&self, key_id: &str, key_data: &KeyData) -> Result<()> {\n        let key_label = format!("{}-{}", self.service_name, key_id);\n        \n        // Serialize key data\n        let serialized_key = self.serialize_key_data(key_data)?;\n        \n        // Set up keychain attributes\n        let mut attributes = vec![\n            (kSecClass, kSecClassGenericPassword),\n            (kSecAttrService, self.service_name.as_ref()),\n            (kSecAttrAccount, key_id.as_ref()),\n            (kSecAttrLabel, key_label.as_ref()),\n            (kSecValueData, serialized_key.as_slice()),\n            (kSecAttrAccessible, self.map_accessibility(&self.accessibility)),\n        ];\n        \n        // Add access group if specified\n        if let Some(ref access_group) = self.access_group {\n            attributes.push((kSecAttrAccessGroup, access_group.as_ref()));\n        }\n        \n        // Add biometric requirements\n        if self.require_biometry {\n            let access_control = SecAccessControl::create_with_flags(\n                None,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                kSecAccessControlBiometryAny\n            ).map_err(|e| KeystoreError::BiometrySetupFailed(e.to_string()))?;\n            \n            attributes.push((kSecAttrAccessControl, access_control));\n        }\n        \n        // Store in keychain\n        let status = SecItemAdd(&attributes, None);\n        \n        match status {\n            errSecSuccess => Ok(()),\n            errSecDuplicateItem => {\n                // Update existing item\n                self.update_key(key_id, key_data).await\n            },\n            _ => Err(KeystoreError::StorageFailed(format!("Keychain error: {}", status))),\n        }\n    }\n    \n    async fn retrieve_key(&self, key_id: &str) -> Result<Option<KeyData>> {\n        let query = vec![\n            (kSecClass, kSecClassGenericPassword),\n            (kSecAttrService, self.service_name.as_ref()),\n            (kSecAttrAccount, key_id.as_ref()),\n            (kSecReturnData, kCFBooleanTrue),\n            (kSecMatchLimit, kSecMatchLimitOne),\n        ];\n        \n        // Add biometric prompt if required\n        if self.require_biometry {\n            let context = LAContext::new();\n            context.set_localized_fallback_title("Enter Passcode");\n            \n            let auth_result = context.evaluate_policy(\n                LAPolicy::BiometryDeviceOwnerAuthentication,\n                "Access cryptographic key"\n            ).await;\n            \n            if let Err(e) = auth_result {\n                return Err(KeystoreError::AuthenticationFailed(e.to_string()));\n            }\n        }\n        \n        let mut result: CFTypeRef = std::ptr::null();\n        let status = SecItemCopyMatching(&query, &mut result);\n        \n        match status {\n            errSecSuccess => {\n                let data = unsafe { CFData::wrap_under_get_rule(result as CFDataRef) };\n                let key_bytes = data.bytes();\n                let key_data = self.deserialize_key_data(key_bytes)?;\n                Ok(Some(key_data))\n            },\n            errSecItemNotFound => Ok(None),\n            _ => Err(KeystoreError::RetrievalFailed(format!("Keychain error: {}", status))),\n        }\n    }\n    \n    async fn delete_key(&self, key_id: &str) -> Result<()> {\n        let query = vec![\n            (kSecClass, kSecClassGenericPassword),\n            (kSecAttrService, self.service_name.as_ref()),\n            (kSecAttrAccount, key_id.as_ref()),\n        ];\n        \n        let status = SecItemDelete(&query);\n        \n        match status {\n            errSecSuccess | errSecItemNotFound => Ok(()),\n            _ => Err(KeystoreError::DeletionFailed(format!("Keychain error: {}", status))),\n        }\n    }\n    \n    fn map_accessibility(&self, accessibility: &KeychainAccessibility) -> CFStringRef {\n        match accessibility {\n            KeychainAccessibility::WhenUnlocked => kSecAttrAccessibleWhenUnlocked,\n            KeychainAccessibility::WhenUnlockedThisDeviceOnly => kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            KeychainAccessibility::AfterFirstUnlock => kSecAttrAccessibleAfterFirstUnlock,\n            KeychainAccessibility::WhenPasscodeSetThisDeviceOnly => kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,\n            KeychainAccessibility::BiometryAny => kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n            KeychainAccessibility::BiometryCurrentSet => kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"android-keystore-integration",children:"Android Keystore Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_keystore::android::*;\nuse jni::{JNIEnv, JavaVM, objects::*};\n\npub struct AndroidKeystoreBackend {\n    keystore_alias_prefix: String,\n    require_authentication: bool,\n    authentication_validity_duration: Duration,\n    encryption_required: bool,\n}\n\nimpl KeystoreBackend for AndroidKeystoreBackend {\n    async fn store_key(&self, key_id: &str, key_data: &KeyData) -> Result<()> {\n        let alias = format!("{}{}", self.keystore_alias_prefix, key_id);\n        \n        // Get JNI environment\n        let env = self.get_jni_env()?;\n        \n        if self.encryption_required {\n            // Generate encryption key in Android Keystore\n            self.generate_keystore_key(&env, &alias)?;\n            \n            // Encrypt key data with Keystore key\n            let encrypted_data = self.encrypt_with_keystore_key(&env, &alias, key_data)?;\n            \n            // Store encrypted data in shared preferences or file\n            self.store_encrypted_data(&env, key_id, &encrypted_data).await?;\n        } else {\n            // Store directly in Android Keystore (for supported key types)\n            self.store_key_in_keystore(&env, &alias, key_data)?;\n        }\n        \n        Ok(())\n    }\n    \n    async fn retrieve_key(&self, key_id: &str) -> Result<Option<KeyData>> {\n        let alias = format!("{}{}", self.keystore_alias_prefix, key_id);\n        let env = self.get_jni_env()?;\n        \n        // Check if key exists\n        if !self.keystore_contains_alias(&env, &alias)? {\n            return Ok(None);\n        }\n        \n        if self.encryption_required {\n            // Retrieve encrypted data\n            let encrypted_data = match self.get_encrypted_data(&env, key_id).await? {\n                Some(data) => data,\n                None => return Ok(None),\n            };\n            \n            // Decrypt with Keystore key\n            let key_data = self.decrypt_with_keystore_key(&env, &alias, &encrypted_data)?;\n            Ok(Some(key_data))\n        } else {\n            // Retrieve directly from Android Keystore\n            let key_data = self.retrieve_key_from_keystore(&env, &alias)?;\n            Ok(Some(key_data))\n        }\n    }\n    \n    fn generate_keystore_key(&self, env: &JNIEnv, alias: &str) -> Result<()> {\n        // KeyGenerator for AES keys\n        let key_generator_class = env.find_class("javax/crypto/KeyGenerator")?;\n        let key_generator = env.call_static_method(\n            key_generator_class,\n            "getInstance",\n            "(Ljava/lang/String;Ljava/lang/String;)Ljavax/crypto/KeyGenerator;",\n            &[\n                JValue::Object(env.new_string("AES")?.into()),\n                JValue::Object(env.new_string("AndroidKeyStore")?.into()),\n            ],\n        )?.l()?;\n        \n        // KeyGenParameterSpec.Builder\n        let builder_class = env.find_class("android/security/keystore/KeyGenParameterSpec$Builder")?;\n        let builder = env.new_object(\n            builder_class,\n            "(Ljava/lang/String;I)V",\n            &[\n                JValue::Object(env.new_string(alias)?.into()),\n                JValue::Int(3), // PURPOSE_ENCRYPT | PURPOSE_DECRYPT\n            ],\n        )?;\n        \n        // Set key size\n        env.call_method(\n            builder,\n            "setKeySize",\n            "(I)Landroid/security/keystore/KeyGenParameterSpec$Builder;",\n            &[JValue::Int(256)],\n        )?;\n        \n        // Set encryption padding and mode\n        env.call_method(\n            builder,\n            "setEncryptionPaddings",\n            "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec$Builder;",\n            &[JValue::Object(self.create_string_array(&env, &["PKCS7Padding"])?.into())],\n        )?;\n        \n        env.call_method(\n            builder,\n            "setBlockModes",\n            "([Ljava/lang/String;)Landroid/security/keystore/KeyGenParameterSpec$Builder;",\n            &[JValue::Object(self.create_string_array(&env, &["GCM"])?.into())],\n        )?;\n        \n        // Set authentication requirements\n        if self.require_authentication {\n            env.call_method(\n                builder,\n                "setUserAuthenticationRequired",\n                "(Z)Landroid/security/keystore/KeyGenParameterSpec$Builder;",\n                &[JValue::Bool(1)],\n            )?;\n            \n            env.call_method(\n                builder,\n                "setUserAuthenticationValidityDurationSeconds",\n                "(I)Landroid/security/keystore/KeyGenParameterSpec$Builder;",\n                &[JValue::Int(self.authentication_validity_duration.as_secs() as i32)],\n            )?;\n        }\n        \n        // Build the spec\n        let spec = env.call_method(builder, "build", "()Landroid/security/keystore/KeyGenParameterSpec;", &[])?;\n        \n        // Initialize KeyGenerator with spec\n        env.call_method(\n            key_generator,\n            "init",\n            "(Ljava/security/spec/AlgorithmParameterSpec;)V",\n            &[JValue::Object(spec.l()?)],\n        )?;\n        \n        // Generate the key\n        env.call_method(key_generator, "generateKey", "()Ljavax/crypto/SecretKey;", &[])?;\n        \n        Ok(())\n    }\n    \n    fn encrypt_with_keystore_key(&self, env: &JNIEnv, alias: &str, key_data: &KeyData) -> Result<Vec<u8>> {\n        // Get the key from Keystore\n        let keystore = self.get_keystore(env)?;\n        let secret_key = env.call_method(\n            keystore,\n            "getKey",\n            "(Ljava/lang/String;[C)Ljava/security/Key;",\n            &[\n                JValue::Object(env.new_string(alias)?.into()),\n                JValue::Object(JObject::null()),\n            ],\n        )?.l()?;\n        \n        // Create cipher\n        let cipher_class = env.find_class("javax/crypto/Cipher")?;\n        let cipher = env.call_static_method(\n            cipher_class,\n            "getInstance",\n            "(Ljava/lang/String;)Ljavax/crypto/Cipher;",\n            &[JValue::Object(env.new_string("AES/GCM/PKCS7Padding")?.into())],\n        )?.l()?;\n        \n        // Initialize cipher for encryption\n        env.call_method(\n            cipher,\n            "init",\n            "(ILjava/security/Key;)V",\n            &[JValue::Int(1), JValue::Object(secret_key)], // ENCRYPT_MODE = 1\n        )?;\n        \n        // Serialize and encrypt key data\n        let serialized_data = self.serialize_key_data(key_data)?;\n        let data_array = env.byte_array_from_slice(&serialized_data)?;\n        \n        let encrypted_result = env.call_method(\n            cipher,\n            "doFinal",\n            "([B)[B",\n            &[JValue::Object(data_array.into())],\n        )?.l()?;\n        \n        let encrypted_bytes = env.convert_byte_array(encrypted_result.into_inner())?;\n        Ok(encrypted_bytes)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"key-rotation-management",children:"Key Rotation Management"}),"\n",(0,i.jsx)(n.h3,{id:"automatic-key-rotation",children:"Automatic Key Rotation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_keystore::rotation::*;\n\npub struct KeyRotationManager {\n    keystore: Arc<Keystore>,\n    rotation_scheduler: TaskScheduler,\n    rotation_policies: HashMap<String, RotationPolicy>,\n    notification_manager: NotificationManager,\n}\n\n#[derive(Debug, Clone)]\npub struct RotationPolicy {\n    pub enabled: bool,\n    pub interval: Duration,\n    pub advance_warning: Duration,\n    pub grace_period: Duration,          // Old key remains valid\n    pub backup_before_rotation: bool,\n    pub require_manual_confirmation: bool,\n    pub rotation_triggers: Vec<RotationTrigger>,\n}\n\n#[derive(Debug, Clone)]\npub enum RotationTrigger {\n    TimeInterval,                        // Regular time-based rotation\n    UsageCount(u64),                     // After N operations\n    SecurityEvent,                       // After security incident\n    ComplianceRequirement,               // Regulatory requirement\n    ManualRequest,                       // User-initiated\n}\n\nimpl KeyRotationManager {\n    pub async fn schedule_rotation(&mut self, key_id: &str, policy: RotationPolicy) -> Result<()> {\n        // Get current key info\n        let key_info = self.keystore.get_key_info(key_id).await?\n            .ok_or_else(|| KeystoreError::KeyNotFound(key_id.to_string()))?;\n            \n        let next_rotation = key_info.created_at + policy.interval;\n        let warning_time = next_rotation - policy.advance_warning;\n        \n        // Schedule advance warning\n        self.rotation_scheduler.schedule_task(\n            warning_time,\n            RotationTask::AdvanceWarning {\n                key_id: key_id.to_string(),\n                rotation_time: next_rotation,\n            },\n        ).await?;\n        \n        // Schedule actual rotation\n        if !policy.require_manual_confirmation {\n            self.rotation_scheduler.schedule_task(\n                next_rotation,\n                RotationTask::AutomaticRotation {\n                    key_id: key_id.to_string(),\n                },\n            ).await?;\n        }\n        \n        // Store policy\n        self.rotation_policies.insert(key_id.to_string(), policy);\n        \n        Ok(())\n    }\n    \n    pub async fn rotate_key(&mut self, key_id: &str, reason: RotationReason) -> Result<RotationResult> {\n        let policy = self.rotation_policies.get(key_id)\n            .ok_or_else(|| KeystoreError::RotationPolicyNotFound(key_id.to_string()))?\n            .clone();\n            \n        // Get current key\n        let current_key = self.keystore.get_key_info(key_id).await?\n            .ok_or_else(|| KeystoreError::KeyNotFound(key_id.to_string()))?;\n            \n        // Create backup if required\n        if policy.backup_before_rotation {\n            self.create_rotation_backup(key_id, &current_key).await?;\n        }\n        \n        // Generate new key with same derivation path but incremented version\n        let new_key_spec = KeySpec {\n            key_id: format!("{}-v{}", current_key.base_key_id(), current_key.version + 1),\n            derivation_path: current_key.derivation_path.clone(),\n            algorithm: current_key.algorithm.clone(),\n            usage_policy: current_key.usage_policy.clone(),\n        };\n        \n        let new_key_data = self.keystore.generate_key(&new_key_spec).await?;\n        \n        // Store new key\n        self.keystore.store_key(&new_key_spec.key_id, &new_key_data).await?;\n        \n        // Update key registry\n        let rotation_info = KeyRotationInfo {\n            old_key_id: key_id.to_string(),\n            new_key_id: new_key_spec.key_id.clone(),\n            rotation_time: SystemTime::now(),\n            reason,\n            grace_period_ends: SystemTime::now() + policy.grace_period,\n        };\n        \n        self.keystore.register_key_rotation(&rotation_info).await?;\n        \n        // Mark old key as superseded (but keep it for grace period)\n        self.keystore.update_key_status(key_id, KeyStatus::Superseded).await?;\n        \n        // Schedule grace period expiration\n        self.rotation_scheduler.schedule_task(\n            rotation_info.grace_period_ends,\n            RotationTask::ExpireOldKey {\n                key_id: key_id.to_string(),\n            },\n        ).await?;\n        \n        // Send notifications\n        self.send_rotation_notifications(&rotation_info).await?;\n        \n        // Schedule next rotation for new key\n        self.schedule_rotation(&new_key_spec.key_id, policy).await?;\n        \n        Ok(RotationResult {\n            rotation_info,\n            new_key_data,\n        })\n    }\n    \n    async fn handle_advance_warning(&self, key_id: &str, rotation_time: SystemTime) -> Result<()> {\n        let policy = self.rotation_policies.get(key_id)\n            .ok_or_else(|| KeystoreError::RotationPolicyNotFound(key_id.to_string()))?;\n            \n        if policy.require_manual_confirmation {\n            // Send notification requesting manual confirmation\n            self.notification_manager.send_rotation_warning(RotationWarning {\n                key_id: key_id.to_string(),\n                scheduled_rotation: rotation_time,\n                requires_action: true,\n                message: format!(\n                    "Key {} is scheduled for rotation at {:?}. Manual confirmation required.",\n                    key_id, rotation_time\n                ),\n            }).await?;\n        } else {\n            // Send informational notification\n            self.notification_manager.send_rotation_warning(RotationWarning {\n                key_id: key_id.to_string(),\n                scheduled_rotation: rotation_time,\n                requires_action: false,\n                message: format!(\n                    "Key {} will be automatically rotated at {:?}.",\n                    key_id, rotation_time\n                ),\n            }).await?;\n        }\n        \n        Ok(())\n    }\n    \n    pub async fn emergency_rotation(&mut self, key_id: &str, security_incident: &SecurityIncident) -> Result<RotationResult> {\n        // Log security incident\n        self.log_security_incident(key_id, security_incident).await?;\n        \n        // Perform immediate rotation with no grace period\n        let emergency_policy = RotationPolicy {\n            enabled: true,\n            interval: Duration::ZERO,\n            advance_warning: Duration::ZERO,\n            grace_period: Duration::ZERO,  // No grace period for emergency\n            backup_before_rotation: true,   // Always backup for emergencies\n            require_manual_confirmation: false,\n            rotation_triggers: vec![RotationTrigger::SecurityEvent],\n        };\n        \n        // Temporarily override policy\n        let old_policy = self.rotation_policies.insert(key_id.to_string(), emergency_policy);\n        \n        let result = self.rotate_key(key_id, RotationReason::SecurityIncident {\n            incident_id: security_incident.incident_id.clone(),\n            description: security_incident.description.clone(),\n        }).await?;\n        \n        // Restore old policy for new key\n        if let Some(old_policy) = old_policy {\n            self.rotation_policies.insert(result.rotation_info.new_key_id.clone(), old_policy);\n        }\n        \n        // Immediately revoke old key\n        self.keystore.update_key_status(key_id, KeyStatus::Revoked).await?;\n        \n        // Send emergency notification\n        self.notification_manager.send_emergency_rotation_alert(EmergencyRotationAlert {\n            key_id: key_id.to_string(),\n            new_key_id: result.rotation_info.new_key_id.clone(),\n            incident: security_incident.clone(),\n            rotation_time: result.rotation_info.rotation_time,\n        }).await?;\n        \n        Ok(result)\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"backup-and-recovery",children:"Backup and Recovery"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use olocus_keystore::backup::*;\n\npub struct KeyBackupManager {\n    backup_storage: Arc<dyn BackupStorage>,\n    encryption_key: EncryptionKey,\n    compression_enabled: bool,\n}\n\n#[derive(Debug, Clone)]\npub struct BackupMetadata {\n    pub backup_id: String,\n    pub key_count: u32,\n    pub created_at: SystemTime,\n    pub backup_type: BackupType,\n    pub encryption_algorithm: String,\n    pub compression_used: bool,\n    pub checksum: String,\n}\n\n#[derive(Debug, Clone)]\npub enum BackupType {\n    Full,                               // All keys\n    Incremental,                        // Only changed keys\n    Selective(Vec<String>),             // Specific keys\n}\n\nimpl KeyBackupManager {\n    pub async fn create_full_backup(&self, keystore: &Keystore) -> Result<BackupResult> {\n        let backup_id = format!("backup-{}", Uuid::new_v4());\n        \n        // Get all keys\n        let key_infos = keystore.list_all_keys().await?;\n        let mut backup_data = BackupData {\n            version: BACKUP_FORMAT_VERSION,\n            created_at: SystemTime::now(),\n            keys: Vec::new(),\n            metadata: HashMap::new(),\n        };\n        \n        // Export each key\n        for key_info in key_infos {\n            let key_data = keystore.export_key(&key_info.key_id).await?;\n            \n            backup_data.keys.push(BackupKeyEntry {\n                key_id: key_info.key_id.clone(),\n                key_data,\n                derivation_path: key_info.derivation_path,\n                created_at: key_info.created_at,\n                algorithm: key_info.algorithm,\n                usage_policy: key_info.usage_policy,\n            });\n        }\n        \n        // Serialize backup data\n        let serialized = bincode::serialize(&backup_data)?;\n        \n        // Compress if enabled\n        let data_to_encrypt = if self.compression_enabled {\n            self.compress_data(&serialized)?\n        } else {\n            serialized\n        };\n        \n        // Encrypt backup\n        let encrypted_data = self.encrypt_backup(&data_to_encrypt)?;\n        \n        // Calculate checksum\n        let checksum = sha256::digest(&encrypted_data);\n        \n        // Store backup\n        let metadata = BackupMetadata {\n            backup_id: backup_id.clone(),\n            key_count: backup_data.keys.len() as u32,\n            created_at: backup_data.created_at,\n            backup_type: BackupType::Full,\n            encryption_algorithm: "AES-256-GCM".to_string(),\n            compression_used: self.compression_enabled,\n            checksum,\n        };\n        \n        self.backup_storage.store_backup(&backup_id, &encrypted_data, &metadata).await?;\n        \n        Ok(BackupResult {\n            backup_id,\n            metadata,\n            backup_size: encrypted_data.len(),\n        })\n    }\n    \n    pub async fn restore_from_backup(\n        &self,\n        backup_id: &str,\n        keystore: &mut Keystore,\n        restore_options: &RestoreOptions\n    ) -> Result<RestoreResult> {\n        \n        // Get backup metadata\n        let metadata = self.backup_storage.get_backup_metadata(backup_id).await?\n            .ok_or_else(|| KeystoreError::BackupNotFound(backup_id.to_string()))?;\n            \n        // Retrieve backup data\n        let encrypted_data = self.backup_storage.get_backup_data(backup_id).await?;\n        \n        // Verify checksum\n        let calculated_checksum = sha256::digest(&encrypted_data);\n        if calculated_checksum != metadata.checksum {\n            return Err(KeystoreError::BackupCorrupted {\n                backup_id: backup_id.to_string(),\n                expected_checksum: metadata.checksum,\n                actual_checksum: calculated_checksum,\n            });\n        }\n        \n        // Decrypt backup\n        let decrypted_data = self.decrypt_backup(&encrypted_data)?;\n        \n        // Decompress if needed\n        let serialized_data = if metadata.compression_used {\n            self.decompress_data(&decrypted_data)?\n        } else {\n            decrypted_data\n        };\n        \n        // Deserialize backup data\n        let backup_data: BackupData = bincode::deserialize(&serialized_data)?;\n        \n        // Restore keys\n        let mut restored_keys = Vec::new();\n        let mut failed_keys = Vec::new();\n        \n        for key_entry in backup_data.keys {\n            // Check if key should be restored\n            if !self.should_restore_key(&key_entry, restore_options) {\n                continue;\n            }\n            \n            // Check for conflicts\n            if !restore_options.overwrite_existing {\n                if keystore.key_exists(&key_entry.key_id).await? {\n                    failed_keys.push(RestoreError {\n                        key_id: key_entry.key_id,\n                        error: "Key already exists and overwrite not allowed".to_string(),\n                    });\n                    continue;\n                }\n            }\n            \n            // Restore key\n            match keystore.import_key(&key_entry.key_id, &key_entry.key_data).await {\n                Ok(_) => {\n                    restored_keys.push(key_entry.key_id);\n                },\n                Err(e) => {\n                    failed_keys.push(RestoreError {\n                        key_id: key_entry.key_id,\n                        error: e.to_string(),\n                    });\n                }\n            }\n        }\n        \n        Ok(RestoreResult {\n            backup_id: backup_id.to_string(),\n            restored_keys,\n            failed_keys,\n            restore_time: SystemTime::now(),\n        })\n    }\n    \n    pub async fn create_mnemonic_backup(\n        &self,\n        master_key: &ExtendedKey\n    ) -> Result<MnemonicBackup> {\n        \n        // Generate mnemonic from master key entropy\n        let entropy = &master_key.key.as_bytes()[..16]; // Use first 128 bits\n        let mnemonic = Mnemonic::from_entropy(entropy)?;\n        \n        // Create backup QR code for easy recovery\n        let qr_code = self.generate_backup_qr_code(&mnemonic.phrase())?;\n        \n        Ok(MnemonicBackup {\n            mnemonic_phrase: mnemonic.phrase().to_string(),\n            qr_code,\n            created_at: SystemTime::now(),\n            warning: "Store this mnemonic phrase securely. Anyone with access can recover your keys.".to_string(),\n        })\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"testing--integration",children:"Testing & Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod keystore_tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_bip44_key_derivation() {\n        let mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";\n        let mut manager = BIP44KeyManager::new(mnemonic, 0).unwrap(); // Bitcoin\n        \n        // Derive first receiving address\n        let key1 = manager.derive_address_key(0, false, 0).unwrap();\n        let key2 = manager.derive_address_key(0, false, 1).unwrap();\n        \n        // Keys should be different\n        assert_ne!(key1.private_key.as_bytes(), key2.private_key.as_bytes());\n        \n        // Derivation should be deterministic\n        let key1_again = manager.derive_address_key(0, false, 0).unwrap();\n        assert_eq!(key1.private_key.as_bytes(), key1_again.private_key.as_bytes());\n    }\n    \n    #[tokio::test] \n    async fn test_key_rotation() {\n        let mut keystore = create_test_keystore().await;\n        let mut rotation_manager = KeyRotationManager::new(Arc::new(keystore));\n        \n        let key_id = "test-key";\n        let policy = RotationPolicy {\n            enabled: true,\n            interval: Duration::from_secs(60), // 1 minute for testing\n            advance_warning: Duration::from_secs(30),\n            grace_period: Duration::from_secs(30),\n            backup_before_rotation: true,\n            require_manual_confirmation: false,\n            rotation_triggers: vec![RotationTrigger::TimeInterval],\n        };\n        \n        // Generate initial key\n        let key_spec = KeySpec {\n            key_id: key_id.to_string(),\n            derivation_path: DerivationPath::new(vec![44 | 0x80000000, 0, 0]).unwrap(),\n            algorithm: KeyAlgorithm::Ed25519,\n            usage_policy: KeyUsagePolicy::default(),\n        };\n        \n        rotation_manager.keystore.generate_key(&key_spec).await.unwrap();\n        \n        // Schedule rotation\n        rotation_manager.schedule_rotation(key_id, policy).await.unwrap();\n        \n        // Perform rotation\n        let result = rotation_manager.rotate_key(key_id, RotationReason::Scheduled).await.unwrap();\n        \n        assert_ne!(result.rotation_info.old_key_id, result.rotation_info.new_key_id);\n        assert!(result.rotation_info.new_key_id.contains("-v"));\n    }\n    \n    #[tokio::test]\n    async fn test_backup_and_restore() {\n        let keystore = create_test_keystore().await;\n        let backup_manager = KeyBackupManager::new(create_test_backup_storage()).await;\n        \n        // Generate some test keys\n        for i in 0..5 {\n            let key_spec = KeySpec {\n                key_id: format!("test-key-{}", i),\n                derivation_path: DerivationPath::new(vec![44 | 0x80000000, 0, i]).unwrap(),\n                algorithm: KeyAlgorithm::Ed25519,\n                usage_policy: KeyUsagePolicy::default(),\n            };\n            keystore.generate_key(&key_spec).await.unwrap();\n        }\n        \n        // Create backup\n        let backup_result = backup_manager.create_full_backup(&keystore).await.unwrap();\n        assert_eq!(backup_result.metadata.key_count, 5);\n        \n        // Create new keystore\n        let mut new_keystore = create_empty_keystore().await;\n        \n        // Restore from backup\n        let restore_options = RestoreOptions {\n            overwrite_existing: false,\n            key_filter: None,\n        };\n        \n        let restore_result = backup_manager.restore_from_backup(\n            &backup_result.backup_id,\n            &mut new_keystore,\n            &restore_options\n        ).await.unwrap();\n        \n        assert_eq!(restore_result.restored_keys.len(), 5);\n        assert!(restore_result.failed_keys.is_empty());\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/extensions/security/hsm-integration",children:"HSM Integration"})," - Hardware-backed key storage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/extensions/security/device-integrity",children:"Device Integrity"})," - Secure device attestation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/extensions/security/trust-networks",children:"Trust Networks"})," - Key-based trust establishment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/extensions/security/post-quantum",children:"Post-Quantum Cryptography"})," - Future-proof key algorithms"]}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(6540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);