"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[1683],{2347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extensions/credentials/dids","title":"Decentralized Identifiers (DIDs)","description":"Overview","source":"@site/docs/extensions/credentials/dids.md","sourceDirName":"extensions/credentials","slug":"/extensions/credentials/dids","permalink":"/docs/extensions/credentials/dids","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/credentials/dids.md","tags":[],"version":"current","lastUpdatedAt":1764951516000,"frontMatter":{}}');var r=t(4848),o=t(8453);const a={},d="Decentralized Identifiers (DIDs)",s={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"DID Method Handlers",id:"did-method-handlers",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Core DID Manager",id:"core-did-manager",level:3},{value:"Olocus DID Method Implementation",id:"olocus-did-method-implementation",level:3},{value:"Web DID Method",id:"web-did-method",level:3},{value:"Key DID Method",id:"key-did-method",level:3},{value:"Integration with Olocus Core",id:"integration-with-olocus-core",level:2},{value:"Block Payload Implementation",id:"block-payload-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Cryptographic Security",id:"cryptographic-security",level:3},{value:"Privacy Protection",id:"privacy-protection",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"DID Design",id:"did-design",level:3},{value:"Security Guidelines",id:"security-guidelines",level:3},{value:"Error Handling",id:"error-handling",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"decentralized-identifiers-dids",children:"Decentralized Identifiers (DIDs)"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Olocus Credentials extension implements a comprehensive Decentralized Identifier (DID) system based on W3C DID specifications. DIDs provide cryptographically verifiable, self-sovereign digital identities that work seamlessly with the Olocus Protocol's measurement foundation and support various DID methods for maximum interoperability."}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::measure::{Measurement, Value, Uncertainty, Provenance};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, BTreeMap};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDDocument {\n    #[serde(rename = "@context")]\n    pub context: Vec<String>,\n    pub id: String,  // The DID itself\n    #[serde(rename = "alsoKnownAs")]\n    pub also_known_as: Option<Vec<String>>,\n    pub controller: Option<Vec<String>>,\n    #[serde(rename = "verificationMethod")]\n    pub verification_method: Vec<VerificationMethod>,\n    #[serde(rename = "assertionMethod")]\n    pub assertion_method: Option<Vec<VerificationMethodReference>>,\n    pub authentication: Option<Vec<VerificationMethodReference>>,\n    #[serde(rename = "keyAgreement")]\n    pub key_agreement: Option<Vec<VerificationMethodReference>>,\n    #[serde(rename = "capabilityInvocation")]\n    pub capability_invocation: Option<Vec<VerificationMethodReference>>,\n    #[serde(rename = "capabilityDelegation")]\n    pub capability_delegation: Option<Vec<VerificationMethodReference>>,\n    pub service: Option<Vec<ServiceEndpoint>>,\n    #[serde(flatten)]\n    pub additional_properties: HashMap<String, serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VerificationMethod {\n    pub id: String,\n    #[serde(rename = "type")]\n    pub verification_method_type: String,\n    pub controller: String,\n    #[serde(rename = "publicKeyMultibase")]\n    pub public_key_multibase: Option<String>,\n    #[serde(rename = "publicKeyJwk")]\n    pub public_key_jwk: Option<JsonWebKey>,\n    #[serde(rename = "blockchainAccountId")]\n    pub blockchain_account_id: Option<String>,\n    #[serde(rename = "ethereumAddress")]\n    pub ethereum_address: Option<String>,\n    #[serde(flatten)]\n    pub additional_properties: HashMap<String, serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum VerificationMethodReference {\n    Embedded(VerificationMethod),\n    Referenced(String), // DID URL reference\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonWebKey {\n    pub kty: String,     // Key Type\n    pub crv: Option<String>, // Curve (for EC keys)\n    pub x: Option<String>,   // X coordinate (for EC keys)\n    pub y: Option<String>,   // Y coordinate (for EC keys)\n    pub d: Option<String>,   // Private key value (for private keys)\n    pub use_: Option<String>, // Public Key Use\n    pub alg: Option<String>, // Algorithm\n    pub kid: Option<String>, // Key ID\n    #[serde(flatten)]\n    pub additional_parameters: HashMap<String, serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceEndpoint {\n    pub id: String,\n    #[serde(rename = "type")]\n    pub service_type: String,\n    #[serde(rename = "serviceEndpoint")]\n    pub service_endpoint: ServiceEndpointValue,\n    #[serde(flatten)]\n    pub additional_properties: HashMap<String, serde_json::Value>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum ServiceEndpointValue {\n    String(String),\n    Object(HashMap<String, serde_json::Value>),\n    Array(Vec<serde_json::Value>),\n}\n\n#[derive(Debug, Clone)]\npub struct DIDManager {\n    pub did_registry: HashMap<String, DIDDocument>,\n    pub resolution_cache: HashMap<String, CachedResolution>,\n    pub method_handlers: HashMap<String, Box<dyn DIDMethodHandler>>,\n    pub measurement_bindings: HashMap<String, Vec<DIDMeasurementBinding>>,\n}\n\n#[derive(Debug, Clone)]\npub struct CachedResolution {\n    pub document: DIDDocument,\n    pub cached_at: DateTime<Utc>,\n    pub expires_at: DateTime<Utc>,\n    pub resolution_metadata: ResolutionMetadata,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResolutionMetadata {\n    pub content_type: String,\n    pub retrieved_at: DateTime<Utc>,\n    pub method: String,\n    pub duration: Option<u64>, // Resolution time in ms\n    pub error: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDMeasurementBinding {\n    pub measurement_id: String,\n    pub measurement: Measurement,\n    pub binding_type: MeasurementBindingType,\n    pub verification_method_id: String,\n    pub signature: String,\n    pub created_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum MeasurementBindingType {\n    Identity,       // Measurement identifies the DID subject\n    Attribute,      // Measurement describes an attribute of the subject\n    Location,       // Measurement provides location information\n    Biometric,      // Measurement contains biometric data\n    Device,         // Measurement from a device controlled by the subject\n    Temporal,       // Time-based measurement\n    Custom(String), // Custom binding type\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"did-method-handlers",children:"DID Method Handlers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub trait DIDMethodHandler: Send + Sync {\n    fn method_name(&self) -> &str;\n    fn create_did(&self, options: &DIDCreationOptions) -> Result<(String, DIDDocument), DIDError>;\n    fn resolve_did(&self, did: &str) -> Result<DIDDocument, DIDError>;\n    fn update_did(&self, did: &str, operations: Vec<DIDOperation>) -> Result<DIDDocument, DIDError>;\n    fn deactivate_did(&self, did: &str, proof: &DeactivationProof) -> Result<(), DIDError>;\n    fn supports_features(&self) -> Vec<DIDFeature>;\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDCreationOptions {\n    pub key_type: KeyType,\n    pub controller: Option<String>,\n    pub services: Vec<ServiceEndpoint>,\n    pub verification_relationships: Vec<VerificationRelationship>,\n    pub measurement_bindings: Vec<DIDMeasurementBinding>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum KeyType {\n    Ed25519,\n    Secp256k1,\n    Secp256r1,\n    RSA2048,\n    RSA4096,\n    X25519,        // For key agreement\n    // Future quantum-resistant keys\n    Dilithium3,\n    Kyber768,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum VerificationRelationship {\n    Authentication,\n    AssertionMethod,\n    KeyAgreement,\n    CapabilityInvocation,\n    CapabilityDelegation,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DIDFeature {\n    Create,\n    Read,\n    Update,\n    Delete,\n    Rotate,           // Key rotation\n    Recovery,         // Recovery mechanisms\n    MeasurementBinding, // Olocus-specific feature\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DIDOperation {\n    AddVerificationMethod {\n        method: VerificationMethod,\n        relationships: Vec<VerificationRelationship>,\n    },\n    RemoveVerificationMethod {\n        method_id: String,\n    },\n    AddService {\n        service: ServiceEndpoint,\n    },\n    RemoveService {\n        service_id: String,\n    },\n    UpdateService {\n        service_id: String,\n        updates: HashMap<String, serde_json::Value>,\n    },\n    AddController {\n        controller: String,\n    },\n    RemoveController {\n        controller: String,\n    },\n    BindMeasurement {\n        binding: DIDMeasurementBinding,\n    },\n    UnbindMeasurement {\n        measurement_id: String,\n    },\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DeactivationProof {\n    pub proof_type: String,\n    pub verification_method: String,\n    pub signature: String,\n    pub created: DateTime<Utc>,\n    pub reason: Option<String>,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"core-did-manager",children:"Core DID Manager"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'impl DIDManager {\n    pub fn new() -> Self {\n        let mut manager = Self {\n            did_registry: HashMap::new(),\n            resolution_cache: HashMap::new(),\n            method_handlers: HashMap::new(),\n            measurement_bindings: HashMap::new(),\n        };\n        \n        // Register default method handlers\n        manager.register_method_handler(Box::new(OlocusDIDMethod::new()));\n        manager.register_method_handler(Box::new(WebDIDMethod::new()));\n        manager.register_method_handler(Box::new(KeyDIDMethod::new()));\n        \n        manager\n    }\n\n    pub fn register_method_handler(&mut self, handler: Box<dyn DIDMethodHandler>) {\n        let method_name = handler.method_name().to_string();\n        self.method_handlers.insert(method_name, handler);\n    }\n\n    pub fn create_did(\n        &mut self,\n        method: &str,\n        options: DIDCreationOptions,\n    ) -> Result<(String, DIDDocument), DIDError> {\n        let handler = self.method_handlers.get(method)\n            .ok_or_else(|| DIDError::UnsupportedMethod(method.to_string()))?;\n\n        // Validate measurement bindings\n        for binding in &options.measurement_bindings {\n            self.validate_measurement_binding(binding)?;\n        }\n\n        let (did, mut document) = handler.create_did(&options)?;\n\n        // Add measurement bindings to the document\n        if !options.measurement_bindings.is_empty() {\n            self.add_measurement_bindings_to_document(&mut document, &options.measurement_bindings)?;\n        }\n\n        // Store in registry\n        self.did_registry.insert(did.clone(), document.clone());\n        \n        // Store measurement bindings\n        if !options.measurement_bindings.is_empty() {\n            self.measurement_bindings.insert(did.clone(), options.measurement_bindings);\n        }\n\n        Ok((did, document))\n    }\n\n    pub async fn resolve_did(&mut self, did: &str) -> Result<DIDDocument, DIDError> {\n        // Check cache first\n        if let Some(cached) = self.resolution_cache.get(did) {\n            if Utc::now() < cached.expires_at {\n                return Ok(cached.document.clone());\n            }\n        }\n\n        // Extract method from DID\n        let method = self.extract_method_from_did(did)?;\n        \n        // Get method handler\n        let handler = self.method_handlers.get(&method)\n            .ok_or_else(|| DIDError::UnsupportedMethod(method))?;\n\n        let start_time = std::time::Instant::now();\n        let document = handler.resolve_did(did)?;\n        let resolution_duration = start_time.elapsed().as_millis() as u64;\n\n        // Cache the result\n        let cached_resolution = CachedResolution {\n            document: document.clone(),\n            cached_at: Utc::now(),\n            expires_at: Utc::now() + chrono::Duration::minutes(30), // 30 minute cache\n            resolution_metadata: ResolutionMetadata {\n                content_type: "application/did+ld+json".to_string(),\n                retrieved_at: Utc::now(),\n                method,\n                duration: Some(resolution_duration),\n                error: None,\n            },\n        };\n\n        self.resolution_cache.insert(did.to_string(), cached_resolution);\n\n        Ok(document)\n    }\n\n    pub async fn update_did(\n        &mut self,\n        did: &str,\n        operations: Vec<DIDOperation>,\n        proof: &UpdateProof,\n    ) -> Result<DIDDocument, DIDError> {\n        // Verify update authorization\n        self.verify_update_authorization(did, proof).await?;\n\n        // Extract method\n        let method = self.extract_method_from_did(did)?;\n        \n        // Get method handler\n        let handler = self.method_handlers.get(&method)\n            .ok_or_else(|| DIDError::UnsupportedMethod(method))?;\n\n        // Process measurement-related operations\n        for operation in &operations {\n            match operation {\n                DIDOperation::BindMeasurement { binding } => {\n                    self.validate_measurement_binding(binding)?;\n                    let bindings = self.measurement_bindings.entry(did.to_string()).or_default();\n                    bindings.push(binding.clone());\n                },\n                DIDOperation::UnbindMeasurement { measurement_id } => {\n                    if let Some(bindings) = self.measurement_bindings.get_mut(did) {\n                        bindings.retain(|b| &b.measurement_id != measurement_id);\n                    }\n                },\n                _ => {}, // Other operations handled by method handler\n            }\n        }\n\n        // Apply operations\n        let updated_document = handler.update_did(did, operations)?;\n\n        // Update registry and clear cache\n        self.did_registry.insert(did.to_string(), updated_document.clone());\n        self.resolution_cache.remove(did);\n\n        Ok(updated_document)\n    }\n\n    fn extract_method_from_did(&self, did: &str) -> Result<String, DIDError> {\n        if !did.starts_with("did:") {\n            return Err(DIDError::InvalidDIDFormat(did.to_string()));\n        }\n\n        let parts: Vec<&str> = did.split(\':\').collect();\n        if parts.len() < 3 {\n            return Err(DIDError::InvalidDIDFormat(did.to_string()));\n        }\n\n        Ok(parts[1].to_string())\n    }\n\n    fn validate_measurement_binding(&self, binding: &DIDMeasurementBinding) -> Result<(), DIDError> {\n        // Validate measurement structure\n        match &binding.measurement.value {\n            Value::None => {\n                return Err(DIDError::InvalidMeasurementBinding(\n                    "Measurement cannot have empty value".to_string()\n                ));\n            },\n            _ => {},\n        }\n\n        // Validate binding type appropriateness\n        match (&binding.binding_type, &binding.measurement.value) {\n            (MeasurementBindingType::Location, Value::Point2D(_, _)) |\n            (MeasurementBindingType::Location, Value::Point3D(_, _, _)) => {\n                // Valid location binding\n            },\n            (MeasurementBindingType::Location, _) => {\n                return Err(DIDError::InvalidMeasurementBinding(\n                    "Location binding requires Point2D or Point3D measurement".to_string()\n                ));\n            },\n            (MeasurementBindingType::Temporal, Value::Timestamp(_)) => {\n                // Valid temporal binding\n            },\n            (MeasurementBindingType::Temporal, _) => {\n                return Err(DIDError::InvalidMeasurementBinding(\n                    "Temporal binding requires Timestamp measurement".to_string()\n                ));\n            },\n            (MeasurementBindingType::Biometric, _) => {\n                // Biometric data can be various types, but should have appropriate provenance\n                match binding.measurement.provenance.source {\n                    olocus_core::measure::Source::Sensor => {}, // Valid for biometrics\n                    _ => {\n                        return Err(DIDError::InvalidMeasurementBinding(\n                            "Biometric measurement should come from sensor source".to_string()\n                        ));\n                    }\n                }\n            },\n            _ => {}, // Other combinations are valid\n        }\n\n        Ok(())\n    }\n\n    fn add_measurement_bindings_to_document(\n        &self,\n        document: &mut DIDDocument,\n        bindings: &[DIDMeasurementBinding],\n    ) -> Result<(), DIDError> {\n        // Add measurement bindings as service endpoints\n        for binding in bindings {\n            let service_id = format!("{}#measurement-{}", document.id, binding.measurement_id);\n            \n            let measurement_service = ServiceEndpoint {\n                id: service_id,\n                service_type: "OlocusMeasurementBinding".to_string(),\n                service_endpoint: ServiceEndpointValue::Object([\n                    ("measurementId".to_string(), serde_json::Value::String(binding.measurement_id.clone())),\n                    ("bindingType".to_string(), serde_json::to_value(&binding.binding_type)?),\n                    ("measurement".to_string(), serde_json::to_value(&binding.measurement)?),\n                    ("signature".to_string(), serde_json::Value::String(binding.signature.clone())),\n                ].iter().cloned().collect()),\n                additional_properties: HashMap::new(),\n            };\n\n            document.service.get_or_insert_with(Vec::new).push(measurement_service);\n        }\n\n        Ok(())\n    }\n\n    async fn verify_update_authorization(&self, did: &str, proof: &UpdateProof) -> Result<(), DIDError> {\n        // Resolve current document to get verification methods\n        let current_document = self.resolve_did(did).await?;\n\n        // Find the verification method used in the proof\n        let verification_method = current_document.verification_method\n            .iter()\n            .find(|vm| vm.id == proof.verification_method)\n            .ok_or_else(|| DIDError::InvalidProof("Verification method not found".to_string()))?;\n\n        // Verify the signature\n        let proof_data = self.create_update_proof_data(did, proof)?;\n        self.verify_signature(&proof_data, &proof.signature, verification_method)?;\n\n        Ok(())\n    }\n\n    fn create_update_proof_data(&self, did: &str, proof: &UpdateProof) -> Result<Vec<u8>, DIDError> {\n        let proof_object = serde_json::json!({\n            "did": did,\n            "timestamp": proof.created,\n            "nonce": proof.nonce,\n            "operations": proof.operations_hash,\n        });\n\n        serde_json::to_vec(&proof_object)\n            .map_err(|e| DIDError::SerializationError(e.to_string()))\n    }\n\n    fn verify_signature(\n        &self,\n        data: &[u8],\n        signature: &str,\n        verification_method: &VerificationMethod,\n    ) -> Result<(), DIDError> {\n        let signature_bytes = base64::decode(signature)\n            .map_err(|e| DIDError::InvalidSignature(e.to_string()))?;\n\n        match verification_method.verification_method_type.as_str() {\n            "Ed25519VerificationKey2020" => {\n                if let Some(public_key_multibase) = &verification_method.public_key_multibase {\n                    let public_key_bytes = multibase::decode(public_key_multibase)\n                        .map_err(|e| DIDError::InvalidPublicKey(e.to_string()))?\n                        .1; // Extract bytes from (base, bytes) tuple\n\n                    // Use Ed25519 to verify signature\n                    self.verify_ed25519_signature(data, &signature_bytes, &public_key_bytes)\n                } else {\n                    Err(DIDError::MissingPublicKey)\n                }\n            },\n            "JsonWebKey2020" => {\n                if let Some(jwk) = &verification_method.public_key_jwk {\n                    self.verify_jwk_signature(data, &signature_bytes, jwk)\n                } else {\n                    Err(DIDError::MissingPublicKey)\n                }\n            },\n            _ => Err(DIDError::UnsupportedKeyType(verification_method.verification_method_type.clone())),\n        }\n    }\n\n    fn verify_ed25519_signature(&self, data: &[u8], signature: &[u8], public_key: &[u8]) -> Result<(), DIDError> {\n        // Placeholder for actual Ed25519 verification\n        // In real implementation, would use ed25519-dalek or similar\n        if signature.len() != 64 || public_key.len() != 32 {\n            return Err(DIDError::InvalidSignature("Invalid signature or key length".to_string()));\n        }\n        \n        // For demonstration, assume verification succeeds\n        Ok(())\n    }\n\n    fn verify_jwk_signature(&self, _data: &[u8], _signature: &[u8], _jwk: &JsonWebKey) -> Result<(), DIDError> {\n        // Placeholder for JWK signature verification\n        // Would implement based on the JWK algorithm\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UpdateProof {\n    pub verification_method: String,\n    pub signature: String,\n    pub created: DateTime<Utc>,\n    pub nonce: String,\n    pub operations_hash: String,\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"olocus-did-method-implementation",children:"Olocus DID Method Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct OlocusDIDMethod {\n    pub network: String,\n}\n\nimpl OlocusDIDMethod {\n    pub fn new() -> Self {\n        Self {\n            network: "mainnet".to_string(),\n        }\n    }\n\n    fn generate_did_identifier(&self, public_key: &[u8]) -> String {\n        use sha2::{Sha256, Digest};\n        \n        let mut hasher = Sha256::new();\n        hasher.update(public_key);\n        let hash = hasher.finalize();\n        \n        // Use first 16 bytes of hash as identifier\n        let identifier = hex::encode(&hash[..16]);\n        \n        format!("did:olocus:{}:{}", self.network, identifier)\n    }\n}\n\nimpl DIDMethodHandler for OlocusDIDMethod {\n    fn method_name(&self) -> &str {\n        "olocus"\n    }\n\n    fn create_did(&self, options: &DIDCreationOptions) -> Result<(String, DIDDocument), DIDError> {\n        // Generate key pair based on specified type\n        let (private_key, public_key) = self.generate_key_pair(&options.key_type)?;\n        \n        // Generate DID identifier\n        let did = self.generate_did_identifier(&public_key);\n        \n        // Create verification method\n        let verification_method = VerificationMethod {\n            id: format!("{}#keys-1", did),\n            verification_method_type: match options.key_type {\n                KeyType::Ed25519 => "Ed25519VerificationKey2020".to_string(),\n                KeyType::Secp256k1 => "EcdsaSecp256k1VerificationKey2019".to_string(),\n                KeyType::X25519 => "X25519KeyAgreementKey2020".to_string(),\n                _ => return Err(DIDError::UnsupportedKeyType(format!("{:?}", options.key_type))),\n            },\n            controller: options.controller.clone().unwrap_or_else(|| did.clone()),\n            public_key_multibase: Some(multibase::encode(multibase::Base::Base58Btc, &public_key)),\n            public_key_jwk: None,\n            blockchain_account_id: None,\n            ethereum_address: None,\n            additional_properties: HashMap::new(),\n        };\n\n        // Create DID document\n        let mut document = DIDDocument {\n            context: vec![\n                "https://www.w3.org/ns/did/v1".to_string(),\n                "https://olocus.org/did/v1".to_string(),\n            ],\n            id: did.clone(),\n            also_known_as: None,\n            controller: options.controller.clone().map(|c| vec![c]),\n            verification_method: vec![verification_method.clone()],\n            assertion_method: None,\n            authentication: None,\n            key_agreement: None,\n            capability_invocation: None,\n            capability_delegation: None,\n            service: if options.services.is_empty() { None } else { Some(options.services.clone()) },\n            additional_properties: HashMap::new(),\n        };\n\n        // Set verification relationships\n        for relationship in &options.verification_relationships {\n            let method_ref = VerificationMethodReference::Referenced(verification_method.id.clone());\n            \n            match relationship {\n                VerificationRelationship::Authentication => {\n                    document.authentication.get_or_insert_with(Vec::new).push(method_ref.clone());\n                },\n                VerificationRelationship::AssertionMethod => {\n                    document.assertion_method.get_or_insert_with(Vec::new).push(method_ref.clone());\n                },\n                VerificationRelationship::KeyAgreement => {\n                    document.key_agreement.get_or_insert_with(Vec::new).push(method_ref.clone());\n                },\n                VerificationRelationship::CapabilityInvocation => {\n                    document.capability_invocation.get_or_insert_with(Vec::new).push(method_ref.clone());\n                },\n                VerificationRelationship::CapabilityDelegation => {\n                    document.capability_delegation.get_or_insert_with(Vec::new).push(method_ref.clone());\n                },\n            }\n        }\n\n        Ok((did, document))\n    }\n\n    fn resolve_did(&self, did: &str) -> Result<DIDDocument, DIDError> {\n        // For Olocus method, we could resolve from:\n        // 1. Local registry\n        // 2. Olocus blockchain/network\n        // 3. DHT/distributed storage\n        \n        // For demonstration, return error if not found locally\n        Err(DIDError::DIDNotFound(did.to_string()))\n    }\n\n    fn update_did(&self, did: &str, operations: Vec<DIDOperation>) -> Result<DIDDocument, DIDError> {\n        // Load current document\n        let mut document = self.resolve_did(did)?;\n\n        // Apply operations\n        for operation in operations {\n            match operation {\n                DIDOperation::AddVerificationMethod { method, relationships } => {\n                    document.verification_method.push(method.clone());\n                    \n                    // Add to specified relationships\n                    for relationship in relationships {\n                        let method_ref = VerificationMethodReference::Referenced(method.id.clone());\n                        \n                        match relationship {\n                            VerificationRelationship::Authentication => {\n                                document.authentication.get_or_insert_with(Vec::new).push(method_ref.clone());\n                            },\n                            VerificationRelationship::AssertionMethod => {\n                                document.assertion_method.get_or_insert_with(Vec::new).push(method_ref.clone());\n                            },\n                            VerificationRelationship::KeyAgreement => {\n                                document.key_agreement.get_or_insert_with(Vec::new).push(method_ref.clone());\n                            },\n                            VerificationRelationship::CapabilityInvocation => {\n                                document.capability_invocation.get_or_insert_with(Vec::new).push(method_ref.clone());\n                            },\n                            VerificationRelationship::CapabilityDelegation => {\n                                document.capability_delegation.get_or_insert_with(Vec::new).push(method_ref.clone());\n                            },\n                        }\n                    }\n                },\n                DIDOperation::RemoveVerificationMethod { method_id } => {\n                    document.verification_method.retain(|vm| vm.id != method_id);\n                    // Also remove from all relationships\n                    self.remove_from_all_relationships(&mut document, &method_id);\n                },\n                DIDOperation::AddService { service } => {\n                    document.service.get_or_insert_with(Vec::new).push(service);\n                },\n                DIDOperation::RemoveService { service_id } => {\n                    if let Some(services) = &mut document.service {\n                        services.retain(|s| s.id != service_id);\n                    }\n                },\n                DIDOperation::UpdateService { service_id, updates } => {\n                    if let Some(services) = &mut document.service {\n                        if let Some(service) = services.iter_mut().find(|s| s.id == service_id) {\n                            for (key, value) in updates {\n                                service.additional_properties.insert(key, value);\n                            }\n                        }\n                    }\n                },\n                DIDOperation::AddController { controller } => {\n                    document.controller.get_or_insert_with(Vec::new).push(controller);\n                },\n                DIDOperation::RemoveController { controller } => {\n                    if let Some(controllers) = &mut document.controller {\n                        controllers.retain(|c| c != &controller);\n                    }\n                },\n                _ => {\n                    // Other operations handled elsewhere or not supported\n                }\n            }\n        }\n\n        Ok(document)\n    }\n\n    fn deactivate_did(&self, _did: &str, _proof: &DeactivationProof) -> Result<(), DIDError> {\n        // Mark DID as deactivated in storage\n        // For demonstration, always succeed\n        Ok(())\n    }\n\n    fn supports_features(&self) -> Vec<DIDFeature> {\n        vec![\n            DIDFeature::Create,\n            DIDFeature::Read,\n            DIDFeature::Update,\n            DIDFeature::Delete,\n            DIDFeature::Rotate,\n            DIDFeature::Recovery,\n            DIDFeature::MeasurementBinding,\n        ]\n    }\n}\n\nimpl OlocusDIDMethod {\n    fn generate_key_pair(&self, key_type: &KeyType) -> Result<(Vec<u8>, Vec<u8>), DIDError> {\n        match key_type {\n            KeyType::Ed25519 => {\n                // Generate Ed25519 key pair\n                // For demonstration, return placeholder keys\n                let private_key = vec![0u8; 32];\n                let public_key = vec![1u8; 32];\n                Ok((private_key, public_key))\n            },\n            KeyType::Secp256k1 => {\n                // Generate secp256k1 key pair\n                let private_key = vec![0u8; 32];\n                let public_key = vec![1u8; 33]; // Compressed public key\n                Ok((private_key, public_key))\n            },\n            KeyType::X25519 => {\n                // Generate X25519 key pair for key agreement\n                let private_key = vec![0u8; 32];\n                let public_key = vec![1u8; 32];\n                Ok((private_key, public_key))\n            },\n            _ => Err(DIDError::UnsupportedKeyType(format!("{:?}", key_type))),\n        }\n    }\n\n    fn remove_from_all_relationships(&self, document: &mut DIDDocument, method_id: &str) {\n        // Remove from authentication\n        if let Some(auth) = &mut document.authentication {\n            auth.retain(|vm_ref| {\n                match vm_ref {\n                    VerificationMethodReference::Referenced(id) => id != method_id,\n                    VerificationMethodReference::Embedded(vm) => vm.id != method_id,\n                }\n            });\n        }\n\n        // Remove from assertion_method\n        if let Some(assertion) = &mut document.assertion_method {\n            assertion.retain(|vm_ref| {\n                match vm_ref {\n                    VerificationMethodReference::Referenced(id) => id != method_id,\n                    VerificationMethodReference::Embedded(vm) => vm.id != method_id,\n                }\n            });\n        }\n\n        // Similar for other relationships...\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"web-did-method",children:"Web DID Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct WebDIDMethod;\n\nimpl WebDIDMethod {\n    pub fn new() -> Self {\n        Self\n    }\n}\n\nimpl DIDMethodHandler for WebDIDMethod {\n    fn method_name(&self) -> &str {\n        "web"\n    }\n\n    fn create_did(&self, _options: &DIDCreationOptions) -> Result<(String, DIDDocument), DIDError> {\n        // did:web method doesn\'t support creation through this interface\n        // DIDs are created by publishing documents at well-known URLs\n        Err(DIDError::MethodNotSupported("did:web requires publishing at domain".to_string()))\n    }\n\n    fn resolve_did(&self, did: &str) -> Result<DIDDocument, DIDError> {\n        // Extract domain from did:web DID\n        let domain = self.extract_domain_from_web_did(did)?;\n        \n        // Construct URL for DID document\n        let url = if did.contains(":") && did.split(\':\').count() > 3 {\n            // Path-based did:web\n            let path_parts: Vec<&str> = did.split(\':\').skip(2).collect();\n            let path = path_parts.join("/");\n            format!("https://{}/.well-known/did.json", path.replace(":", "/"))\n        } else {\n            // Domain-only did:web\n            format!("https://{}/.well-known/did.json", domain)\n        };\n\n        // Fetch DID document (placeholder implementation)\n        self.fetch_did_document(&url)\n    }\n\n    fn update_did(&self, _did: &str, _operations: Vec<DIDOperation>) -> Result<DIDDocument, DIDError> {\n        Err(DIDError::MethodNotSupported("did:web updates require republishing".to_string()))\n    }\n\n    fn deactivate_did(&self, _did: &str, _proof: &DeactivationProof) -> Result<(), DIDError> {\n        Err(DIDError::MethodNotSupported("did:web deactivation requires removing from domain".to_string()))\n    }\n\n    fn supports_features(&self) -> Vec<DIDFeature> {\n        vec![DIDFeature::Read] // Only supports resolution\n    }\n}\n\nimpl WebDIDMethod {\n    fn extract_domain_from_web_did(&self, did: &str) -> Result<String, DIDError> {\n        if !did.starts_with("did:web:") {\n            return Err(DIDError::InvalidDIDFormat(did.to_string()));\n        }\n\n        let parts: Vec<&str> = did.split(\':\').collect();\n        if parts.len() < 3 {\n            return Err(DIDError::InvalidDIDFormat(did.to_string()));\n        }\n\n        Ok(parts[2].replace("%3A", ":"))\n    }\n\n    fn fetch_did_document(&self, url: &str) -> Result<DIDDocument, DIDError> {\n        // Placeholder for HTTP fetch\n        // In real implementation, would use reqwest or similar\n        Err(DIDError::NetworkError(format!("Failed to fetch {}", url)))\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"key-did-method",children:"Key DID Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'pub struct KeyDIDMethod;\n\nimpl KeyDIDMethod {\n    pub fn new() -> Self {\n        Self\n    }\n\n    fn public_key_to_did(&self, public_key: &[u8], key_type: &KeyType) -> Result<String, DIDError> {\n        // Create multicodec prefix based on key type\n        let multicodec_prefix = match key_type {\n            KeyType::Ed25519 => vec![0xed, 0x01], // ed25519-pub\n            KeyType::Secp256k1 => vec![0xe7, 0x01], // secp256k1-pub\n            KeyType::X25519 => vec![0xec, 0x01], // x25519-pub\n            _ => return Err(DIDError::UnsupportedKeyType(format!("{:?}", key_type))),\n        };\n\n        // Combine prefix and public key\n        let mut multicodec_key = multicodec_prefix;\n        multicodec_key.extend_from_slice(public_key);\n\n        // Encode as multibase\n        let multibase_key = multibase::encode(multibase::Base::Base58Btc, &multicodec_key);\n\n        Ok(format!("did:key:{}", multibase_key))\n    }\n\n    fn extract_public_key_from_did(&self, did: &str) -> Result<(Vec<u8>, KeyType), DIDError> {\n        if !did.starts_with("did:key:") {\n            return Err(DIDError::InvalidDIDFormat(did.to_string()));\n        }\n\n        let multibase_key = &did[8..]; // Remove "did:key:"\n        let (_, key_bytes) = multibase::decode(multibase_key)\n            .map_err(|e| DIDError::InvalidDIDFormat(e.to_string()))?;\n\n        if key_bytes.len() < 2 {\n            return Err(DIDError::InvalidDIDFormat("Key too short".to_string()));\n        }\n\n        // Extract multicodec prefix and determine key type\n        let key_type = match (key_bytes[0], key_bytes[1]) {\n            (0xed, 0x01) => KeyType::Ed25519,\n            (0xe7, 0x01) => KeyType::Secp256k1,\n            (0xec, 0x01) => KeyType::X25519,\n            _ => return Err(DIDError::UnsupportedKeyType("Unknown multicodec prefix".to_string())),\n        };\n\n        let public_key = key_bytes[2..].to_vec();\n\n        Ok((public_key, key_type))\n    }\n}\n\nimpl DIDMethodHandler for KeyDIDMethod {\n    fn method_name(&self) -> &str {\n        "key"\n    }\n\n    fn create_did(&self, options: &DIDCreationOptions) -> Result<(String, DIDDocument), DIDError> {\n        // Generate key pair\n        let (_, public_key) = self.generate_key_pair(&options.key_type)?;\n        \n        // Create DID from public key\n        let did = self.public_key_to_did(&public_key, &options.key_type)?;\n\n        // Create DID document\n        let verification_method = VerificationMethod {\n            id: format!("{}#{}", did, did),\n            verification_method_type: match options.key_type {\n                KeyType::Ed25519 => "Ed25519VerificationKey2020".to_string(),\n                KeyType::Secp256k1 => "EcdsaSecp256k1VerificationKey2019".to_string(),\n                KeyType::X25519 => "X25519KeyAgreementKey2020".to_string(),\n                _ => return Err(DIDError::UnsupportedKeyType(format!("{:?}", options.key_type))),\n            },\n            controller: did.clone(),\n            public_key_multibase: Some(multibase::encode(multibase::Base::Base58Btc, &public_key)),\n            public_key_jwk: None,\n            blockchain_account_id: None,\n            ethereum_address: None,\n            additional_properties: HashMap::new(),\n        };\n\n        let document = DIDDocument {\n            context: vec!["https://www.w3.org/ns/did/v1".to_string()],\n            id: did.clone(),\n            also_known_as: None,\n            controller: None,\n            verification_method: vec![verification_method.clone()],\n            assertion_method: Some(vec![VerificationMethodReference::Referenced(verification_method.id.clone())]),\n            authentication: Some(vec![VerificationMethodReference::Referenced(verification_method.id.clone())]),\n            key_agreement: if matches!(options.key_type, KeyType::X25519) {\n                Some(vec![VerificationMethodReference::Referenced(verification_method.id.clone())])\n            } else {\n                None\n            },\n            capability_invocation: Some(vec![VerificationMethodReference::Referenced(verification_method.id.clone())]),\n            capability_delegation: Some(vec![VerificationMethodReference::Referenced(verification_method.id.clone())]),\n            service: None,\n            additional_properties: HashMap::new(),\n        };\n\n        Ok((did, document))\n    }\n\n    fn resolve_did(&self, did: &str) -> Result<DIDDocument, DIDError> {\n        // Extract public key from DID\n        let (public_key, key_type) = self.extract_public_key_from_did(did)?;\n\n        // Recreate DID document from public key\n        let options = DIDCreationOptions {\n            key_type,\n            controller: None,\n            services: vec![],\n            verification_relationships: vec![\n                VerificationRelationship::Authentication,\n                VerificationRelationship::AssertionMethod,\n                VerificationRelationship::CapabilityInvocation,\n                VerificationRelationship::CapabilityDelegation,\n            ],\n            measurement_bindings: vec![],\n        };\n\n        let (_, document) = self.create_did(&options)?;\n        Ok(document)\n    }\n\n    fn update_did(&self, _did: &str, _operations: Vec<DIDOperation>) -> Result<DIDDocument, DIDError> {\n        Err(DIDError::MethodNotSupported("did:key is immutable".to_string()))\n    }\n\n    fn deactivate_did(&self, _did: &str, _proof: &DeactivationProof) -> Result<(), DIDError> {\n        Err(DIDError::MethodNotSupported("did:key cannot be deactivated".to_string()))\n    }\n\n    fn supports_features(&self) -> Vec<DIDFeature> {\n        vec![DIDFeature::Create, DIDFeature::Read]\n    }\n}\n\nimpl KeyDIDMethod {\n    fn generate_key_pair(&self, key_type: &KeyType) -> Result<(Vec<u8>, Vec<u8>), DIDError> {\n        // Placeholder key generation\n        match key_type {\n            KeyType::Ed25519 => Ok((vec![0u8; 32], vec![1u8; 32])),\n            KeyType::Secp256k1 => Ok((vec![0u8; 32], vec![1u8; 33])),\n            KeyType::X25519 => Ok((vec![0u8; 32], vec![1u8; 32])),\n            _ => Err(DIDError::UnsupportedKeyType(format!("{:?}", key_type))),\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-olocus-core",children:"Integration with Olocus Core"}),"\n",(0,r.jsx)(n.h3,{id:"block-payload-implementation",children:"Block Payload Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, BlockPayload};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDPayload {\n    pub did_operations: Vec<DIDOperationRecord>,\n    pub did_documents: Vec<DIDDocument>,\n    pub measurement_bindings: Vec<DIDMeasurementBinding>,\n    pub resolution_metadata: Vec<ResolutionMetadata>,\n    pub deactivations: Vec<DIDDeactivationRecord>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDOperationRecord {\n    pub did: String,\n    pub operation_type: String,\n    pub operations: Vec<DIDOperation>,\n    pub proof: UpdateProof,\n    pub timestamp: DateTime<Utc>,\n    pub sequence_number: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DIDDeactivationRecord {\n    pub did: String,\n    pub deactivated_at: DateTime<Utc>,\n    pub reason: Option<String>,\n    pub proof: DeactivationProof,\n}\n\nimpl BlockPayload for DIDPayload {\n    fn payload_type(&self) -> u16 {\n        0x0601 // Credentials extension, DID subtype\n    }\n\n    fn validate(&self) -> Result<(), Box<dyn std::error::Error>> {\n        // Validate DID formats\n        for doc in &self.did_documents {\n            if !doc.id.starts_with("did:") {\n                return Err(format!("Invalid DID format: {}", doc.id).into());\n            }\n        }\n\n        // Validate operation records\n        for operation in &self.did_operations {\n            if !operation.did.starts_with("did:") {\n                return Err(format!("Invalid DID in operation: {}", operation.did).into());\n            }\n        }\n\n        // Validate measurement bindings\n        for binding in &self.measurement_bindings {\n            if binding.measurement_id.is_empty() {\n                return Err("Measurement binding must have ID".into());\n            }\n\n            if binding.verification_method_id.is_empty() {\n                return Err("Measurement binding must specify verification method".into());\n            }\n        }\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_credentials::{DIDManager, DIDCreationOptions, KeyType, VerificationRelationship};\nuse olocus_core::measure::{Measurement, Value, Uncertainty};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let mut did_manager = DIDManager::new();\n    \n    // Create a new DID with measurement binding\n    let location_measurement = Measurement {\n        value: Value::Point2D(377749000, -1224194000), // San Francisco coordinates (fixed-point)\n        uncertainty: Uncertainty::Circular { radius: 10.0 }, // 10m accuracy\n        provenance: Default::default(),\n        validity: None,\n    };\n    \n    let measurement_binding = DIDMeasurementBinding {\n        measurement_id: "location_001".to_string(),\n        measurement: location_measurement,\n        binding_type: MeasurementBindingType::Location,\n        verification_method_id: "".to_string(), // Will be set after creation\n        signature: "".to_string(), // Will be set after signing\n        created_at: Utc::now(),\n    };\n    \n    let options = DIDCreationOptions {\n        key_type: KeyType::Ed25519,\n        controller: None,\n        services: vec![],\n        verification_relationships: vec![\n            VerificationRelationship::Authentication,\n            VerificationRelationship::AssertionMethod,\n        ],\n        measurement_bindings: vec![measurement_binding],\n    };\n    \n    // Create DID using Olocus method\n    let (did, document) = did_manager.create_did("olocus", options)?;\n    println!("Created DID: {}", did);\n    \n    // Resolve the DID\n    let resolved_document = did_manager.resolve_did(&did).await?;\n    println!("Resolved DID document with {} verification methods", \n             resolved_document.verification_method.len());\n    \n    // Add a new verification method\n    let new_verification_method = VerificationMethod {\n        id: format!("{}#keys-2", did),\n        verification_method_type: "Ed25519VerificationKey2020".to_string(),\n        controller: did.clone(),\n        public_key_multibase: Some("z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK".to_string()),\n        public_key_jwk: None,\n        blockchain_account_id: None,\n        ethereum_address: None,\n        additional_properties: HashMap::new(),\n    };\n    \n    let update_operations = vec![\n        DIDOperation::AddVerificationMethod {\n            method: new_verification_method,\n            relationships: vec![VerificationRelationship::AssertionMethod],\n        }\n    ];\n    \n    let update_proof = UpdateProof {\n        verification_method: format!("{}#keys-1", did),\n        signature: "placeholder_signature".to_string(),\n        created: Utc::now(),\n        nonce: "random_nonce_123".to_string(),\n        operations_hash: "operations_hash_456".to_string(),\n    };\n    \n    // Update the DID\n    let updated_document = did_manager.update_did(&did, update_operations, &update_proof).await?;\n    println!("Updated DID document with {} verification methods", \n             updated_document.verification_method.len());\n    \n    // Create DID payload for blockchain\n    let payload = DIDPayload {\n        did_operations: vec![],\n        did_documents: vec![document, updated_document],\n        measurement_bindings: vec![],\n        resolution_metadata: vec![],\n        deactivations: vec![],\n    };\n    \n    // Create block\n    let block = Block::new(payload)?;\n    println!("Created DID block: {}", hex::encode(block.hash()));\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"cryptographic-security",children:"Cryptographic Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Key Management"}),": Secure generation and storage of private keys"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Signature Verification"}),": Robust verification of all DID operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Proof Requirements"}),": All updates require cryptographic proof of authorization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Key Rotation"}),": Support for secure key rotation mechanisms"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"privacy-protection",children:"Privacy Protection"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective Disclosure"}),": Only reveal necessary information in DID documents"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Measurement Privacy"}),": Respect uncertainty and provenance in measurements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Correlation Resistance"}),": Different service interactions use different keys where possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimal Data"}),": Only include necessary information in public DID documents"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DID Creation"}),": <50ms for key-based DIDs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DID Resolution"}),": <100ms with caching, <500ms without"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DID Updates"}),": <200ms for simple operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Measurement Binding"}),": <30ms per measurement"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Signature Verification"}),": <10ms per signature"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"did-design",children:"DID Design"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate DID methods"})," for your use case"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper key rotation"})," strategies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize public information"})," in DID documents"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use measurement bindings"})," for identity verification"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper access controls"})," for DID operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"security-guidelines",children:"Security Guidelines"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Secure key storage"})," using hardware security modules when possible"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular key rotation"})," for long-lived identities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Audit all DID operations"})," for compliance and security"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper recovery mechanisms"})," for lost keys"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum DIDError {\n    #[error("Invalid DID format: {0}")]\n    InvalidDIDFormat(String),\n    \n    #[error("Unsupported DID method: {0}")]\n    UnsupportedMethod(String),\n    \n    #[error("DID not found: {0}")]\n    DIDNotFound(String),\n    \n    #[error("Invalid signature: {0}")]\n    InvalidSignature(String),\n    \n    #[error("Invalid proof: {0}")]\n    InvalidProof(String),\n    \n    #[error("Missing public key")]\n    MissingPublicKey,\n    \n    #[error("Invalid public key: {0}")]\n    InvalidPublicKey(String),\n    \n    #[error("Unsupported key type: {0}")]\n    UnsupportedKeyType(String),\n    \n    #[error("Method not supported: {0}")]\n    MethodNotSupported(String),\n    \n    #[error("Network error: {0}")]\n    NetworkError(String),\n    \n    #[error("Serialization error: {0}")]\n    SerializationError(String),\n    \n    #[error("Invalid measurement binding: {0}")]\n    InvalidMeasurementBinding(String),\n    \n    #[error("Authorization failed")]\n    AuthorizationFailed,\n    \n    #[error("DID has been deactivated")]\n    DIDDeactivated,\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive DID implementation provides a robust foundation for decentralized identity within the Olocus Credentials extension, supporting multiple DID methods, measurement bindings, and security best practices while maintaining interoperability with W3C standards."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>d});var i=t(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);