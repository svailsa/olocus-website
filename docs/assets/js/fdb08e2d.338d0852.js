"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[1280],{1951:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"extensions/privacy/consent-management","title":"Consent Management","description":"Overview","source":"@site/docs/extensions/privacy/consent-management.md","sourceDirName":"extensions/privacy","slug":"/extensions/privacy/consent-management","permalink":"/docs/extensions/privacy/consent-management","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/privacy/consent-management.md","tags":[],"version":"current","lastUpdatedAt":null,"frontMatter":{}}');var r=t(4848),i=t(8453);const o={},a="Consent Management",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Consent Events and History",id:"consent-events-and-history",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Core Consent Manager",id:"core-consent-manager",level:3},{value:"Compliance Frameworks",id:"compliance-frameworks",level:3},{value:"Data Subject Rights",id:"data-subject-rights",level:3},{value:"Integration with Olocus Core",id:"integration-with-olocus-core",level:2},{value:"Block Payload Implementation",id:"block-payload-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Privacy by Design",id:"privacy-by-design",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Configuration Guidelines",id:"configuration-guidelines",level:3},{value:"Error Handling",id:"error-handling",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"consent-management",children:"Consent Management"})}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Olocus Privacy extension provides comprehensive consent management capabilities to ensure compliance with privacy regulations like GDPR and CCPA. The system manages user consent, tracks consent changes over time, and provides fine-grained control over data processing activities."}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::{Measurement, Value, Uncertainty, Provenance, Source};\nuse chrono::{DateTime, Utc};\nuse uuid::Uuid;\nuse std::collections::{HashMap, HashSet};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentManager {\n    pub user_consents: HashMap<UserId, UserConsentProfile>,\n    pub consent_history: Vec<ConsentEvent>,\n    pub compliance_framework: ComplianceFramework,\n    pub consent_policies: Vec<ConsentPolicy>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct UserId(pub String);\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserConsentProfile {\n    pub user_id: UserId,\n    pub consents: HashMap<ConsentType, ConsentStatus>,\n    pub preferences: HashMap<String, Value>,\n    pub last_updated: DateTime<Utc>,\n    pub consent_version: u32,\n    pub metadata: ConsentMetadata,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentStatus {\n    pub granted: bool,\n    pub timestamp: DateTime<Utc>,\n    pub expires_at: Option<DateTime<Utc>>,\n    pub source: ConsentSource,\n    pub legal_basis: LegalBasis,\n    pub granularity: ConsentGranularity,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub enum ConsentType {\n    DataCollection,\n    DataProcessing,\n    DataSharing,\n    Marketing,\n    Analytics,\n    PersonalizedContent,\n    LocationTracking,\n    BiometricData,\n    HealthData,\n    FinancialData,\n    Custom(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ConsentSource {\n    ExplicitConsent,        // User actively opted in\n    ImpliedConsent,         // Implied from user action\n    LegitimateInterest,     // Processing based on legitimate interest\n    LegalObligation,        // Required by law\n    VitalInterests,         // Protection of vital interests\n    PublicTask,            // Performance of public task\n    ContractualNecessity,   // Necessary for contract performance\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum LegalBasis {\n    GDPR(GDPRBasis),\n    CCPA(CCPABasis),\n    PIPEDA(PIPEDABasis),\n    Custom(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum GDPRBasis {\n    Article6A, // Consent\n    Article6B, // Contract\n    Article6C, // Legal obligation\n    Article6D, // Vital interests\n    Article6E, // Public task\n    Article6F, // Legitimate interests\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum CCPABasis {\n    SaleOptOut,\n    ServiceProvider,\n    BusinessPurpose,\n    CommercialPurpose,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum PIPEDABasis {\n    Consent,\n    ContractualRequirement,\n    LegalRequirement,\n    EmergencyMedical,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ConsentGranularity {\n    Global,                    // All-or-nothing consent\n    CategoryBased,             // Consent per data category\n    PurposeBased,              // Consent per processing purpose\n    ProcessorBased,            // Consent per data processor\n    FiniteGrained(HashMap<String, bool>), // Custom granular permissions\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"consent-events-and-history",children:"Consent Events and History"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentEvent {\n    pub event_id: Uuid,\n    pub user_id: UserId,\n    pub event_type: ConsentEventType,\n    pub timestamp: DateTime<Utc>,\n    pub consent_types: HashSet<ConsentType>,\n    pub previous_state: Option<ConsentStatus>,\n    pub new_state: ConsentStatus,\n    pub context: ConsentContext,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ConsentEventType {\n    ConsentGranted,\n    ConsentRevoked,\n    ConsentExpired,\n    ConsentRenewed,\n    ConsentModified,\n    ConsentWithdrawn,\n    DataPortabilityRequest,\n    DataDeletionRequest,\n    AccessRequest,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentContext {\n    pub application: String,\n    pub version: String,\n    pub user_agent: Option<String>,\n    pub ip_address: Option<String>,\n    pub session_id: Option<String>,\n    pub consent_mechanism: ConsentMechanism,\n    pub language: Option<String>,\n    pub jurisdiction: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ConsentMechanism {\n    WebForm,\n    MobileApp,\n    API,\n    ImportedConsent,\n    ParentalConsent,\n    GuardianConsent,\n    CookieBanner,\n    PrivacyCenter,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentMetadata {\n    pub consent_string: Option<String>,  // IAB consent string\n    pub privacy_policy_version: String,\n    pub terms_of_service_version: String,\n    pub age_verification: Option<AgeVerification>,\n    pub jurisdiction: String,\n    pub data_controller: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AgeVerification {\n    pub verified_age: Option<u8>,\n    pub verification_method: AgeVerificationMethod,\n    pub parental_consent_required: bool,\n    pub parental_consent_obtained: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AgeVerificationMethod {\n    SelfReported,\n    CreditCardCheck,\n    GovernmentID,\n    ParentalVerification,\n    ThirdPartyService,\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"core-consent-manager",children:"Core Consent Manager"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'impl ConsentManager {\n    pub fn new(framework: ComplianceFramework) -> Self {\n        Self {\n            user_consents: HashMap::new(),\n            consent_history: Vec::new(),\n            compliance_framework: framework,\n            consent_policies: Vec::new(),\n        }\n    }\n\n    pub fn grant_consent(\n        &mut self,\n        user_id: UserId,\n        consent_types: HashSet<ConsentType>,\n        source: ConsentSource,\n        context: ConsentContext,\n    ) -> Result<(), ConsentError> {\n        let legal_basis = self.determine_legal_basis(&source)?;\n        let timestamp = Utc::now();\n\n        // Get or create user profile\n        let profile = self.user_consents.entry(user_id.clone())\n            .or_insert_with(|| UserConsentProfile {\n                user_id: user_id.clone(),\n                consents: HashMap::new(),\n                preferences: HashMap::new(),\n                last_updated: timestamp,\n                consent_version: 1,\n                metadata: ConsentMetadata {\n                    consent_string: None,\n                    privacy_policy_version: "1.0".to_string(),\n                    terms_of_service_version: "1.0".to_string(),\n                    age_verification: None,\n                    jurisdiction: "EU".to_string(),\n                    data_controller: "Olocus Organization".to_string(),\n                },\n            });\n\n        // Update consents\n        for consent_type in &consent_types {\n            let previous_state = profile.consents.get(consent_type).cloned();\n            \n            let new_consent = ConsentStatus {\n                granted: true,\n                timestamp,\n                expires_at: self.calculate_expiry_date(&legal_basis),\n                source: source.clone(),\n                legal_basis: legal_basis.clone(),\n                granularity: ConsentGranularity::CategoryBased,\n            };\n\n            profile.consents.insert(consent_type.clone(), new_consent.clone());\n\n            // Record consent event\n            let event = ConsentEvent {\n                event_id: Uuid::new_v4(),\n                user_id: user_id.clone(),\n                event_type: ConsentEventType::ConsentGranted,\n                timestamp,\n                consent_types: [consent_type.clone()].into_iter().collect(),\n                previous_state,\n                new_state: new_consent,\n                context: context.clone(),\n            };\n\n            self.consent_history.push(event);\n        }\n\n        profile.last_updated = timestamp;\n        profile.consent_version += 1;\n\n        Ok(())\n    }\n\n    pub fn revoke_consent(\n        &mut self,\n        user_id: &UserId,\n        consent_types: HashSet<ConsentType>,\n        context: ConsentContext,\n    ) -> Result<(), ConsentError> {\n        let profile = self.user_consents.get_mut(user_id)\n            .ok_or(ConsentError::UserNotFound(user_id.clone()))?;\n\n        let timestamp = Utc::now();\n\n        for consent_type in &consent_types {\n            if let Some(previous_state) = profile.consents.get(consent_type) {\n                if previous_state.granted {\n                    let new_consent = ConsentStatus {\n                        granted: false,\n                        timestamp,\n                        expires_at: None,\n                        source: ConsentSource::ExplicitConsent,\n                        legal_basis: previous_state.legal_basis.clone(),\n                        granularity: previous_state.granularity.clone(),\n                    };\n\n                    profile.consents.insert(consent_type.clone(), new_consent.clone());\n\n                    // Record revocation event\n                    let event = ConsentEvent {\n                        event_id: Uuid::new_v4(),\n                        user_id: user_id.clone(),\n                        event_type: ConsentEventType::ConsentRevoked,\n                        timestamp,\n                        consent_types: [consent_type.clone()].into_iter().collect(),\n                        previous_state: Some(previous_state.clone()),\n                        new_state: new_consent,\n                        context: context.clone(),\n                    };\n\n                    self.consent_history.push(event);\n                }\n            }\n        }\n\n        profile.last_updated = timestamp;\n        profile.consent_version += 1;\n\n        Ok(())\n    }\n\n    pub fn check_consent(\n        &self,\n        user_id: &UserId,\n        consent_type: &ConsentType,\n    ) -> Result<bool, ConsentError> {\n        let profile = self.user_consents.get(user_id)\n            .ok_or(ConsentError::UserNotFound(user_id.clone()))?;\n\n        if let Some(consent) = profile.consents.get(consent_type) {\n            // Check if consent is still valid\n            if let Some(expires_at) = consent.expires_at {\n                if Utc::now() > expires_at {\n                    return Ok(false); // Consent has expired\n                }\n            }\n\n            Ok(consent.granted)\n        } else {\n            // No explicit consent found - check for implied consent\n            self.check_implied_consent(user_id, consent_type)\n        }\n    }\n\n    fn check_implied_consent(\n        &self,\n        user_id: &UserId,\n        consent_type: &ConsentType,\n    ) -> Result<bool, ConsentError> {\n        // Check if processing can proceed under legitimate interest or other basis\n        match self.compliance_framework {\n            ComplianceFramework::GDPR => {\n                // Under GDPR, some processing may be lawful without explicit consent\n                match consent_type {\n                    ConsentType::DataProcessing => {\n                        // Check if we have legitimate interest\n                        self.check_legitimate_interest(user_id, consent_type)\n                    },\n                    ConsentType::Analytics => {\n                        // Analytics might be allowed under legitimate interest\n                        self.check_legitimate_interest(user_id, consent_type)\n                    },\n                    _ => Ok(false), // Default to requiring explicit consent\n                }\n            },\n            ComplianceFramework::CCPA => {\n                // Under CCPA, opt-out model - consent assumed unless explicitly revoked\n                Ok(true)\n            },\n            _ => Ok(false),\n        }\n    }\n\n    fn check_legitimate_interest(\n        &self,\n        _user_id: &UserId,\n        consent_type: &ConsentType,\n    ) -> Result<bool, ConsentError> {\n        // Implement legitimate interest assessment\n        for policy in &self.consent_policies {\n            if policy.applies_to_consent_type(consent_type) {\n                return Ok(policy.legitimate_interest_applies);\n            }\n        }\n        Ok(false)\n    }\n\n    pub fn handle_data_subject_request(\n        &mut self,\n        user_id: &UserId,\n        request_type: DataSubjectRequestType,\n        context: ConsentContext,\n    ) -> Result<DataSubjectResponse, ConsentError> {\n        match request_type {\n            DataSubjectRequestType::Access => {\n                self.handle_access_request(user_id, context)\n            },\n            DataSubjectRequestType::Portability => {\n                self.handle_portability_request(user_id, context)\n            },\n            DataSubjectRequestType::Deletion => {\n                self.handle_deletion_request(user_id, context)\n            },\n            DataSubjectRequestType::Rectification => {\n                self.handle_rectification_request(user_id, context)\n            },\n        }\n    }\n\n    fn handle_access_request(\n        &self,\n        user_id: &UserId,\n        context: ConsentContext,\n    ) -> Result<DataSubjectResponse, ConsentError> {\n        let profile = self.user_consents.get(user_id)\n            .ok_or(ConsentError::UserNotFound(user_id.clone()))?;\n\n        // Collect all data for this user\n        let user_data = self.collect_user_data(user_id)?;\n        let consent_history = self.get_user_consent_history(user_id);\n\n        // Record the access request\n        let event = ConsentEvent {\n            event_id: Uuid::new_v4(),\n            user_id: user_id.clone(),\n            event_type: ConsentEventType::AccessRequest,\n            timestamp: Utc::now(),\n            consent_types: HashSet::new(),\n            previous_state: None,\n            new_state: ConsentStatus {\n                granted: true,\n                timestamp: Utc::now(),\n                expires_at: None,\n                source: ConsentSource::LegalObligation,\n                legal_basis: LegalBasis::GDPR(GDPRBasis::Article6C),\n                granularity: ConsentGranularity::Global,\n            },\n            context,\n        };\n\n        Ok(DataSubjectResponse::Access {\n            user_data,\n            consent_profile: profile.clone(),\n            consent_history,\n            request_processed_at: Utc::now(),\n        })\n    }\n\n    fn handle_deletion_request(\n        &mut self,\n        user_id: &UserId,\n        context: ConsentContext,\n    ) -> Result<DataSubjectResponse, ConsentError> {\n        // Check if deletion is possible (considering legal obligations)\n        if !self.can_delete_user_data(user_id)? {\n            return Err(ConsentError::DeletionNotAllowed("Legal retention requirements".to_string()));\n        }\n\n        // Mark all consents as revoked\n        let all_consent_types: HashSet<ConsentType> = ConsentType::all_types();\n        self.revoke_consent(user_id, all_consent_types, context.clone())?;\n\n        // Record deletion request\n        let event = ConsentEvent {\n            event_id: Uuid::new_v4(),\n            user_id: user_id.clone(),\n            event_type: ConsentEventType::DataDeletionRequest,\n            timestamp: Utc::now(),\n            consent_types: HashSet::new(),\n            previous_state: None,\n            new_state: ConsentStatus {\n                granted: false,\n                timestamp: Utc::now(),\n                expires_at: None,\n                source: ConsentSource::ExplicitConsent,\n                legal_basis: LegalBasis::GDPR(GDPRBasis::Article6A),\n                granularity: ConsentGranularity::Global,\n            },\n            context,\n        };\n\n        self.consent_history.push(event);\n\n        Ok(DataSubjectResponse::Deletion {\n            deleted_at: Utc::now(),\n            retention_notice: Some("Some data may be retained for legal compliance purposes".to_string()),\n        })\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"compliance-frameworks",children:"Compliance Frameworks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ComplianceFramework {\n    GDPR,\n    CCPA,\n    PIPEDA,\n    LGPD,\n    Custom(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentPolicy {\n    pub name: String,\n    pub description: String,\n    pub applicable_consent_types: HashSet<ConsentType>,\n    pub legal_basis: LegalBasis,\n    pub legitimate_interest_applies: bool,\n    pub retention_period: Option<chrono::Duration>,\n    pub geographic_scope: HashSet<String>,\n    pub age_restrictions: Option<AgeRestrictions>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AgeRestrictions {\n    pub minimum_age: u8,\n    pub parental_consent_required_under: u8,\n    pub age_verification_required: bool,\n}\n\nimpl ConsentPolicy {\n    pub fn gdpr_marketing_policy() -> Self {\n        Self {\n            name: "GDPR Marketing Communications".to_string(),\n            description: "Policy for marketing communications under GDPR".to_string(),\n            applicable_consent_types: [ConsentType::Marketing].into_iter().collect(),\n            legal_basis: LegalBasis::GDPR(GDPRBasis::Article6A),\n            legitimate_interest_applies: false,\n            retention_period: Some(chrono::Duration::days(1095)), // 3 years\n            geographic_scope: ["EU", "UK", "EEA"].iter().map(|s| s.to_string()).collect(),\n            age_restrictions: Some(AgeRestrictions {\n                minimum_age: 16,\n                parental_consent_required_under: 16,\n                age_verification_required: true,\n            }),\n        }\n    }\n\n    pub fn ccpa_data_sale_policy() -> Self {\n        Self {\n            name: "CCPA Data Sale Opt-Out".to_string(),\n            description: "Policy for data sale opt-out under CCPA".to_string(),\n            applicable_consent_types: [ConsentType::DataSharing].into_iter().collect(),\n            legal_basis: LegalBasis::CCPA(CCPABasis::SaleOptOut),\n            legitimate_interest_applies: false,\n            retention_period: None,\n            geographic_scope: ["CA", "US"].iter().map(|s| s.to_string()).collect(),\n            age_restrictions: Some(AgeRestrictions {\n                minimum_age: 13,\n                parental_consent_required_under: 13,\n                age_verification_required: false,\n            }),\n        }\n    }\n\n    pub fn applies_to_consent_type(&self, consent_type: &ConsentType) -> bool {\n        self.applicable_consent_types.contains(consent_type)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"data-subject-rights",children:"Data Subject Rights"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DataSubjectRequestType {\n    Access,         // Right to access (GDPR Art. 15)\n    Portability,    // Right to data portability (GDPR Art. 20)\n    Deletion,       // Right to erasure/"Right to be forgotten" (GDPR Art. 17)\n    Rectification,  // Right to rectification (GDPR Art. 16)\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum DataSubjectResponse {\n    Access {\n        user_data: Vec<Measurement>,\n        consent_profile: UserConsentProfile,\n        consent_history: Vec<ConsentEvent>,\n        request_processed_at: DateTime<Utc>,\n    },\n    Portability {\n        exported_data: Vec<u8>,\n        format: String,\n        request_processed_at: DateTime<Utc>,\n    },\n    Deletion {\n        deleted_at: DateTime<Utc>,\n        retention_notice: Option<String>,\n    },\n    Rectification {\n        updated_fields: HashMap<String, Value>,\n        updated_at: DateTime<Utc>,\n    },\n}\n\nimpl ConsentManager {\n    fn collect_user_data(&self, user_id: &UserId) -> Result<Vec<Measurement>, ConsentError> {\n        // This would typically query all systems that store user data\n        // For demonstration, we\'ll create a placeholder\n        let user_data_measurement = Measurement {\n            value: Value::Object([\n                ("user_id".to_string(), Value::String(user_id.0.clone())),\n                ("data_collection_summary".to_string(), Value::String("User interaction data".to_string())),\n                ("total_records".to_string(), Value::Int(42)),\n            ].iter().cloned().collect()),\n            uncertainty: Uncertainty::Exact,\n            provenance: Provenance {\n                source: Source::SelfReported,\n                transformations: Vec::new(),\n                attestations: Vec::new(),\n            },\n            validity: None,\n        };\n\n        Ok(vec![user_data_measurement])\n    }\n\n    fn get_user_consent_history(&self, user_id: &UserId) -> Vec<ConsentEvent> {\n        self.consent_history.iter()\n            .filter(|event| &event.user_id == user_id)\n            .cloned()\n            .collect()\n    }\n\n    fn can_delete_user_data(&self, _user_id: &UserId) -> Result<bool, ConsentError> {\n        // Check legal retention requirements\n        // For demonstration, always allow deletion\n        Ok(true)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-olocus-core",children:"Integration with Olocus Core"}),"\n",(0,r.jsx)(n.h3,{id:"block-payload-implementation",children:"Block Payload Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, BlockPayload};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentPayload {\n    pub user_id: UserId,\n    pub consent_events: Vec<ConsentEvent>,\n    pub compliance_framework: ComplianceFramework,\n    pub consent_snapshot: UserConsentProfile,\n    pub audit_trail: ConsentAuditTrail,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConsentAuditTrail {\n    pub policy_version: String,\n    pub consent_mechanisms_used: HashSet<ConsentMechanism>,\n    pub legal_bases_applied: HashSet<LegalBasis>,\n    pub jurisdiction: String,\n    pub data_controller: String,\n    pub data_protection_officer_contact: Option<String>,\n}\n\nimpl BlockPayload for ConsentPayload {\n    fn payload_type(&self) -> u16 {\n        0x0523 // Privacy extension, consent management subtype\n    }\n\n    fn validate(&self) -> Result<(), Box<dyn std::error::Error>> {\n        // Validate user ID\n        if self.user_id.0.is_empty() {\n            return Err("User ID cannot be empty".into());\n        }\n\n        // Validate consent events\n        for event in &self.consent_events {\n            if event.user_id != self.user_id {\n                return Err("All consent events must be for the same user".into());\n            }\n\n            // Validate timestamps are chronological\n            if event.timestamp > Utc::now() {\n                return Err("Consent event timestamp cannot be in the future".into());\n            }\n        }\n\n        // Validate consent profile consistency\n        if self.consent_snapshot.user_id != self.user_id {\n            return Err("Consent snapshot must match user ID".into());\n        }\n\n        // Validate compliance framework requirements\n        match self.compliance_framework {\n            ComplianceFramework::GDPR => {\n                self.validate_gdpr_compliance()?;\n            },\n            ComplianceFramework::CCPA => {\n                self.validate_ccpa_compliance()?;\n            },\n            _ => {}, // Other frameworks\n        }\n\n        Ok(())\n    }\n}\n\nimpl ConsentPayload {\n    fn validate_gdpr_compliance(&self) -> Result<(), Box<dyn std::error::Error>> {\n        // Check for required GDPR elements\n        for event in &self.consent_events {\n            if let ConsentEventType::ConsentGranted = event.event_type {\n                // Ensure legal basis is specified\n                match &event.new_state.legal_basis {\n                    LegalBasis::GDPR(_) => {}, // Valid\n                    _ => return Err("GDPR compliance requires GDPR legal basis".into()),\n                }\n\n                // Ensure explicit consent for sensitive categories\n                if event.consent_types.contains(&ConsentType::HealthData) ||\n                   event.consent_types.contains(&ConsentType::BiometricData) {\n                    match event.new_state.source {\n                        ConsentSource::ExplicitConsent => {}, // Valid\n                        _ => return Err("Sensitive data requires explicit consent under GDPR".into()),\n                    }\n                }\n            }\n        }\n\n        // Check for age verification if required\n        if let Some(age_verification) = &self.consent_snapshot.metadata.age_verification {\n            if age_verification.verified_age.unwrap_or(0) < 16 &&\n               !age_verification.parental_consent_obtained {\n                return Err("GDPR requires parental consent for users under 16".into());\n            }\n        }\n\n        Ok(())\n    }\n\n    fn validate_ccpa_compliance(&self) -> Result<(), Box<dyn std::error::Error>> {\n        // Check for required CCPA elements\n        for event in &self.consent_events {\n            if let ConsentEventType::ConsentRevoked = event.event_type {\n                if event.consent_types.contains(&ConsentType::DataSharing) {\n                    // Ensure proper opt-out mechanism\n                    match event.context.consent_mechanism {\n                        ConsentMechanism::WebForm |\n                        ConsentMechanism::PrivacyCenter => {}, // Valid\n                        _ => return Err("CCPA requires accessible opt-out mechanism".into()),\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use olocus_privacy::{ConsentManager, ComplianceFramework, UserId, ConsentType};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Initialize consent manager for GDPR compliance\n    let mut consent_manager = ConsentManager::new(ComplianceFramework::GDPR);\n    \n    // Add GDPR policies\n    consent_manager.consent_policies.push(ConsentPolicy::gdpr_marketing_policy());\n    \n    let user_id = UserId("user_123@example.com".to_string());\n    let consent_types = [\n        ConsentType::DataCollection,\n        ConsentType::DataProcessing,\n        ConsentType::Analytics,\n    ].into_iter().collect();\n    \n    let context = ConsentContext {\n        application: "olocus-app".to_string(),\n        version: "1.0.0".to_string(),\n        user_agent: Some("Mozilla/5.0 (compatible)".to_string()),\n        ip_address: Some("192.168.1.1".to_string()),\n        session_id: Some("session_abc123".to_string()),\n        consent_mechanism: ConsentMechanism::WebForm,\n        language: Some("en".to_string()),\n        jurisdiction: Some("EU".to_string()),\n    };\n    \n    // Grant consent\n    consent_manager.grant_consent(\n        user_id.clone(),\n        consent_types.clone(),\n        ConsentSource::ExplicitConsent,\n        context.clone(),\n    )?;\n    \n    // Check consent status\n    for consent_type in &consent_types {\n        let has_consent = consent_manager.check_consent(&user_id, consent_type)?;\n        println!("Consent for {:?}: {}", consent_type, has_consent);\n    }\n    \n    // Handle data subject access request\n    let access_response = consent_manager.handle_data_subject_request(\n        &user_id,\n        DataSubjectRequestType::Access,\n        context.clone(),\n    )?;\n    \n    // Create consent block payload\n    let user_profile = consent_manager.user_consents.get(&user_id).unwrap().clone();\n    let user_events: Vec<_> = consent_manager.consent_history.iter()\n        .filter(|event| event.user_id == user_id)\n        .cloned()\n        .collect();\n    \n    let payload = ConsentPayload {\n        user_id: user_id.clone(),\n        consent_events: user_events,\n        compliance_framework: ComplianceFramework::GDPR,\n        consent_snapshot: user_profile,\n        audit_trail: ConsentAuditTrail {\n            policy_version: "1.0".to_string(),\n            consent_mechanisms_used: [ConsentMechanism::WebForm].into_iter().collect(),\n            legal_bases_applied: [LegalBasis::GDPR(GDPRBasis::Article6A)].into_iter().collect(),\n            jurisdiction: "EU".to_string(),\n            data_controller: "Olocus Organization".to_string(),\n            data_protection_officer_contact: Some("dpo@olocus.org".to_string()),\n        },\n    };\n    \n    // Create block\n    let block = Block::new(payload)?;\n    println!("Created consent management block: {}", hex::encode(block.hash()));\n    \n    // Later, revoke marketing consent\n    consent_manager.revoke_consent(\n        &user_id,\n        [ConsentType::Marketing].into_iter().collect(),\n        context.clone(),\n    )?;\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"privacy-by-design",children:"Privacy by Design"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub struct PrivacyByDesignPrinciples;\n\nimpl PrivacyByDesignPrinciples {\n    /// Validate implementation against Privacy by Design principles\n    pub fn validate_implementation(consent_manager: &ConsentManager) -> PrivacyAssessment {\n        let mut assessment = PrivacyAssessment::new();\n        \n        // 1. Proactive not Reactive\n        assessment.proactive_score = Self::assess_proactive_measures(consent_manager);\n        \n        // 2. Privacy as the Default\n        assessment.privacy_default_score = Self::assess_default_privacy(consent_manager);\n        \n        // 3. Privacy Embedded into Design\n        assessment.embedded_score = Self::assess_embedded_privacy(consent_manager);\n        \n        // 4. Full Functionality\n        assessment.functionality_score = Self::assess_functionality_preservation(consent_manager);\n        \n        // 5. End-to-End Security\n        assessment.security_score = Self::assess_security_measures(consent_manager);\n        \n        // 6. Visibility and Transparency\n        assessment.transparency_score = Self::assess_transparency(consent_manager);\n        \n        // 7. Respect for User Privacy\n        assessment.user_privacy_score = Self::assess_user_control(consent_manager);\n        \n        assessment\n    }\n\n    fn assess_proactive_measures(consent_manager: &ConsentManager) -> f64 {\n        let mut score = 0.0;\n        let max_score = 100.0;\n        \n        // Check for automated consent expiry\n        if consent_manager.user_consents.values().any(|profile| {\n            profile.consents.values().any(|consent| consent.expires_at.is_some())\n        }) {\n            score += 25.0;\n        }\n        \n        // Check for regular consent refresh\n        if !consent_manager.consent_policies.is_empty() {\n            score += 25.0;\n        }\n        \n        // Check for granular consent options\n        if consent_manager.user_consents.values().any(|profile| {\n            profile.consents.values().any(|consent| {\n                matches!(consent.granularity, ConsentGranularity::PurposeBased | ConsentGranularity::FiniteGrained(_))\n            })\n        }) {\n            score += 25.0;\n        }\n        \n        // Check for consent analytics\n        if consent_manager.consent_history.len() > 0 {\n            score += 25.0;\n        }\n        \n        score / max_score\n    }\n\n    fn assess_default_privacy(_consent_manager: &ConsentManager) -> f64 {\n        // Assess whether privacy-friendly settings are default\n        // This would examine default consent states, opt-in vs opt-out patterns, etc.\n        0.85 // Placeholder score\n    }\n    \n    // ... other assessment methods\n}\n\n#[derive(Debug, Clone)]\npub struct PrivacyAssessment {\n    pub proactive_score: f64,\n    pub privacy_default_score: f64,\n    pub embedded_score: f64,\n    pub functionality_score: f64,\n    pub security_score: f64,\n    pub transparency_score: f64,\n    pub user_privacy_score: f64,\n    pub overall_score: f64,\n}\n\nimpl PrivacyAssessment {\n    pub fn new() -> Self {\n        Self {\n            proactive_score: 0.0,\n            privacy_default_score: 0.0,\n            embedded_score: 0.0,\n            functionality_score: 0.0,\n            security_score: 0.0,\n            transparency_score: 0.0,\n            user_privacy_score: 0.0,\n            overall_score: 0.0,\n        }\n    }\n\n    pub fn calculate_overall_score(&mut self) {\n        self.overall_score = (\n            self.proactive_score +\n            self.privacy_default_score +\n            self.embedded_score +\n            self.functionality_score +\n            self.security_score +\n            self.transparency_score +\n            self.user_privacy_score\n        ) / 7.0;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.p,{children:"Performance targets for consent management operations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consent check"}),": <5ms per consent type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consent grant/revoke"}),": <20ms per operation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data subject request processing"}),": <500ms for access requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consent history query"}),": <100ms for user's complete history"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compliance validation"}),": <50ms per payload"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"configuration-guidelines",children:"Configuration Guidelines"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Granularity Selection"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use purpose-based consent for complex data processing"}),"\n",(0,r.jsx)(n.li,{children:"Implement fine-grained consent for sensitive data categories"}),"\n",(0,r.jsx)(n.li,{children:"Consider user experience vs. privacy trade-offs"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Retention Management"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Set appropriate consent expiry dates"}),"\n",(0,r.jsx)(n.li,{children:"Implement automated consent refresh workflows"}),"\n",(0,r.jsx)(n.li,{children:"Maintain historical consent records for audit purposes"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Compliance Strategy"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Design for the strictest applicable regulation"}),"\n",(0,r.jsx)(n.li,{children:"Implement jurisdiction-aware consent collection"}),"\n",(0,r.jsx)(n.li,{children:"Regular compliance audits and assessments"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum ConsentError {\n    #[error("User not found: {0:?}")]\n    UserNotFound(UserId),\n    \n    #[error("Invalid consent type: {0}")]\n    InvalidConsentType(String),\n    \n    #[error("Consent already exists for user {user_id:?}, type {consent_type:?}")]\n    ConsentAlreadyExists { user_id: UserId, consent_type: ConsentType },\n    \n    #[error("Legal basis determination failed: {0}")]\n    LegalBasisError(String),\n    \n    #[error("Age verification required but not provided")]\n    AgeVerificationRequired,\n    \n    #[error("Parental consent required for user under minimum age")]\n    ParentalConsentRequired,\n    \n    #[error("Data deletion not allowed: {0}")]\n    DeletionNotAllowed(String),\n    \n    #[error("Compliance framework validation failed: {0}")]\n    ComplianceValidationFailed(String),\n    \n    #[error("Invalid consent context: {0}")]\n    InvalidContext(String),\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive consent management implementation provides enterprise-grade privacy compliance capabilities within the Olocus Privacy extension, ensuring adherence to major privacy regulations while maintaining usability and performance."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);