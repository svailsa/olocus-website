"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[3067],{948:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"extensions/privacy/k-anonymity","title":"K-Anonymity Implementation","description":"Overview","source":"@site/docs/extensions/privacy/k-anonymity.md","sourceDirName":"extensions/privacy","slug":"/extensions/privacy/k-anonymity","permalink":"/docs/extensions/privacy/k-anonymity","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/extensions/privacy/k-anonymity.md","tags":[],"version":"current","lastUpdatedAt":1764951516000,"frontMatter":{}}');var a=i(4848),r=i(8453);const s={},o="K-Anonymity Implementation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Privacy Technique Implementation",id:"privacy-technique-implementation",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Generalization Hierarchies",id:"generalization-hierarchies",level:3},{value:"Generalization Utilities",id:"generalization-utilities",level:3},{value:"Integration with Olocus Core",id:"integration-with-olocus-core",level:2},{value:"Block Payload Implementation",id:"block-payload-implementation",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Limitations of K-Anonymity",id:"limitations-of-k-anonymity",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Benchmarking",id:"benchmarking",level:3},{value:"Performance Targets",id:"performance-targets",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Configuration Guidelines",id:"configuration-guidelines",level:3},{value:"Integration Patterns",id:"integration-patterns",level:3},{value:"Error Handling",id:"error-handling",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"k-anonymity-implementation",children:"K-Anonymity Implementation"})}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"K-anonymity is a privacy-preserving technique that ensures each record in a dataset is indistinguishable from at least k-1 other records with respect to certain identifying attributes (quasi-identifiers). The Olocus Privacy extension implements k-anonymity as part of its comprehensive privacy protection toolkit."}),"\n",(0,a.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use olocus_core::measure::{Measurement, Value, Uncertainty};\nuse std::collections::HashMap;\n\npub struct KAnonymityConfig {\n    pub k: usize,\n    pub quasi_identifiers: Vec<String>,\n    pub sensitive_attributes: Vec<String>,\n    pub suppression_threshold: f64,\n}\n\npub struct KAnonymityProcessor {\n    config: KAnonymityConfig,\n    generalization_hierarchies: HashMap<String, GeneralizationHierarchy>,\n}\n\n#[derive(Debug, Clone)]\npub struct GeneralizationHierarchy {\n    pub levels: Vec<GeneralizationLevel>,\n    pub current_level: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct GeneralizationLevel {\n    pub name: String,\n    pub mapping: HashMap<String, String>,\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"privacy-technique-implementation",children:"Privacy Technique Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"impl PrivacyTechnique for KAnonymityProcessor {\n    type Input = Vec<Measurement>;\n    type Output = Vec<Measurement>;\n    type Error = KAnonymityError;\n\n    fn apply(&self, data: Self::Input) -> Result<Self::Output, Self::Error> {\n        let mut anonymized_data = data.clone();\n        let mut current_k = self.calculate_k_value(&anonymized_data)?;\n        \n        while current_k < self.config.k {\n            if !self.generalize_step(&mut anonymized_data)? {\n                // If generalization fails, apply suppression\n                self.suppress_outliers(&mut anonymized_data)?;\n                break;\n            }\n            current_k = self.calculate_k_value(&anonymized_data)?;\n        }\n        \n        Ok(anonymized_data)\n    }\n\n    fn privacy_loss(&self) -> f64 {\n        // K-anonymity provides syntactic privacy, not semantic\n        // Privacy loss is inversely related to k value\n        1.0 / self.config.k as f64\n    }\n\n    fn utility_metric(&self, original: &Self::Input, anonymized: &Self::Output) -> f64 {\n        self.calculate_information_loss(original, anonymized)\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,a.jsx)(n.h3,{id:"generalization-hierarchies",children:"Generalization Hierarchies"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'impl KAnonymityProcessor {\n    pub fn new(config: KAnonymityConfig) -> Self {\n        let mut hierarchies = HashMap::new();\n        \n        // Example: Age generalization hierarchy\n        let age_hierarchy = GeneralizationHierarchy {\n            levels: vec![\n                GeneralizationLevel {\n                    name: "exact".to_string(),\n                    mapping: HashMap::new(), // Identity mapping\n                },\n                GeneralizationLevel {\n                    name: "5-year-groups".to_string(),\n                    mapping: create_age_groups(5),\n                },\n                GeneralizationLevel {\n                    name: "10-year-groups".to_string(),\n                    mapping: create_age_groups(10),\n                },\n                GeneralizationLevel {\n                    name: "generation".to_string(),\n                    mapping: create_generation_mapping(),\n                },\n            ],\n            current_level: 0,\n        };\n        \n        hierarchies.insert("age".to_string(), age_hierarchy);\n        \n        Self {\n            config,\n            generalization_hierarchies: hierarchies,\n        }\n    }\n\n    fn generalize_step(&mut self, data: &mut Vec<Measurement>) -> Result<bool, KAnonymityError> {\n        // Find the quasi-identifier with the lowest information loss for next generalization\n        let best_qi = self.select_best_generalization_candidate(data)?;\n        \n        if let Some(qi_name) = best_qi {\n            if let Some(hierarchy) = self.generalization_hierarchies.get_mut(&qi_name) {\n                if hierarchy.current_level + 1 < hierarchy.levels.len() {\n                    hierarchy.current_level += 1;\n                    self.apply_generalization(data, &qi_name)?;\n                    return Ok(true);\n                }\n            }\n        }\n        \n        Ok(false)\n    }\n\n    fn apply_generalization(&self, data: &mut Vec<Measurement>, qi_name: &str) -> Result<(), KAnonymityError> {\n        let hierarchy = self.generalization_hierarchies.get(qi_name)\n            .ok_or(KAnonymityError::MissingHierarchy(qi_name.to_string()))?;\n        \n        let level = &hierarchy.levels[hierarchy.current_level];\n        \n        for measurement in data.iter_mut() {\n            if let Value::Object(ref mut obj) = &mut measurement.value {\n                if let Some(Value::Int(age_val)) = obj.get(qi_name).cloned() {\n                    let generalized = level.mapping.get(&age_val.to_string())\n                        .cloned()\n                        .unwrap_or_else(|| format!("{}*", age_val));\n                    \n                    obj.insert(qi_name.to_string(), Value::String(generalized));\n                }\n            }\n        }\n        \n        Ok(())\n    }\n\n    fn calculate_k_value(&self, data: &[Measurement]) -> Result<usize, KAnonymityError> {\n        let mut equivalence_classes = HashMap::new();\n        \n        for measurement in data {\n            let qi_signature = self.extract_quasi_identifier_signature(measurement)?;\n            *equivalence_classes.entry(qi_signature).or_insert(0) += 1;\n        }\n        \n        equivalence_classes.values().min().copied().unwrap_or(0)\n    }\n\n    fn extract_quasi_identifier_signature(&self, measurement: &Measurement) -> Result<String, KAnonymityError> {\n        let mut signature_parts = Vec::new();\n        \n        if let Value::Object(obj) = &measurement.value {\n            for qi in &self.config.quasi_identifiers {\n                if let Some(value) = obj.get(qi) {\n                    signature_parts.push(format!("{}={}", qi, self.value_to_string(value)));\n                }\n            }\n        }\n        \n        Ok(signature_parts.join("|"))\n    }\n\n    fn suppress_outliers(&self, data: &mut Vec<Measurement>) -> Result<(), KAnonymityError> {\n        let mut equivalence_classes = HashMap::new();\n        \n        // Group by quasi-identifier signature\n        for (idx, measurement) in data.iter().enumerate() {\n            let signature = self.extract_quasi_identifier_signature(measurement)?;\n            equivalence_classes.entry(signature).or_insert_with(Vec::new).push(idx);\n        }\n        \n        // Mark small equivalence classes for suppression\n        let mut indices_to_suppress = Vec::new();\n        for (_, indices) in equivalence_classes {\n            if indices.len() < self.config.k {\n                indices_to_suppress.extend(indices);\n            }\n        }\n        \n        // Remove suppressed records\n        indices_to_suppress.sort_unstable();\n        for idx in indices_to_suppress.into_iter().rev() {\n            data.remove(idx);\n        }\n        \n        Ok(())\n    }\n\n    fn calculate_information_loss(&self, original: &[Measurement], anonymized: &[Measurement]) -> f64 {\n        if original.len() != anonymized.len() {\n            return 1.0; // Maximum loss if records were suppressed\n        }\n        \n        let mut total_loss = 0.0;\n        let mut comparisons = 0;\n        \n        for (orig, anon) in original.iter().zip(anonymized.iter()) {\n            if let (Value::Object(orig_obj), Value::Object(anon_obj)) = (&orig.value, &anon.value) {\n                for qi in &self.config.quasi_identifiers {\n                    if let (Some(orig_val), Some(anon_val)) = (orig_obj.get(qi), anon_obj.get(qi)) {\n                        total_loss += self.calculate_field_loss(orig_val, anon_val);\n                        comparisons += 1;\n                    }\n                }\n            }\n        }\n        \n        if comparisons > 0 {\n            total_loss / comparisons as f64\n        } else {\n            0.0\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"generalization-utilities",children:"Generalization Utilities"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'fn create_age_groups(group_size: u32) -> HashMap<String, String> {\n    let mut mapping = HashMap::new();\n    \n    for age in 0..=120 {\n        let group_start = (age / group_size) * group_size;\n        let group_end = group_start + group_size - 1;\n        mapping.insert(age.to_string(), format!("{}-{}", group_start, group_end));\n    }\n    \n    mapping\n}\n\nfn create_generation_mapping() -> HashMap<String, String> {\n    let mut mapping = HashMap::new();\n    \n    // Generation mappings based on birth year\n    for year in 1900..=2020 {\n        let generation = match year {\n            1928..=1945 => "Silent Generation",\n            1946..=1964 => "Baby Boomer",\n            1965..=1980 => "Generation X",\n            1981..=1996 => "Millennial",\n            1997..=2012 => "Generation Z",\n            _ => "Other",\n        };\n        \n        mapping.insert(year.to_string(), generation.to_string());\n    }\n    \n    mapping\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-olocus-core",children:"Integration with Olocus Core"}),"\n",(0,a.jsx)(n.h3,{id:"block-payload-implementation",children:"Block Payload Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_core::{Block, BlockPayload};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct KAnonymizedPayload {\n    pub original_count: usize,\n    pub anonymized_count: usize,\n    pub k_value: usize,\n    pub generalization_levels: HashMap<String, usize>,\n    pub data: Vec<Measurement>,\n    pub privacy_metadata: PrivacyMetadata,\n}\n\nimpl BlockPayload for KAnonymizedPayload {\n    fn payload_type(&self) -> u16 {\n        0x0521 // Privacy extension, K-anonymity subtype\n    }\n\n    fn validate(&self) -> Result<(), Box<dyn std::error::Error>> {\n        if self.k_value < 2 {\n            return Err("K-anonymity requires k >= 2".into());\n        }\n        \n        if self.anonymized_count > self.original_count {\n            return Err("Anonymized count cannot exceed original count".into());\n        }\n        \n        // Validate that data actually satisfies k-anonymity\n        let processor = KAnonymityProcessor::new(KAnonymityConfig {\n            k: self.k_value,\n            quasi_identifiers: self.privacy_metadata.quasi_identifiers.clone(),\n            sensitive_attributes: self.privacy_metadata.sensitive_attributes.clone(),\n            suppression_threshold: 0.1,\n        });\n        \n        let calculated_k = processor.calculate_k_value(&self.data)?;\n        if calculated_k < self.k_value {\n            return Err(format!("Data does not satisfy {}-anonymity", self.k_value).into());\n        }\n        \n        Ok(())\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use olocus_privacy::{KAnonymityProcessor, KAnonymityConfig};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Configure k-anonymity processor\n    let config = KAnonymityConfig {\n        k: 5,\n        quasi_identifiers: vec![\n            "age".to_string(),\n            "zipcode".to_string(),\n            "gender".to_string(),\n        ],\n        sensitive_attributes: vec![\n            "medical_condition".to_string(),\n            "salary".to_string(),\n        ],\n        suppression_threshold: 0.05,\n    };\n    \n    let processor = KAnonymityProcessor::new(config);\n    \n    // Create sample medical data\n    let medical_data = vec![\n        create_patient_measurement(25, "12345", "M", "Diabetes"),\n        create_patient_measurement(27, "12345", "F", "Hypertension"),\n        create_patient_measurement(23, "12346", "M", "Diabetes"),\n        // ... more records\n    ];\n    \n    // Apply k-anonymity\n    let anonymized_data = processor.apply(medical_data.clone())?;\n    \n    // Create anonymized payload\n    let payload = KAnonymizedPayload {\n        original_count: medical_data.len(),\n        anonymized_count: anonymized_data.len(),\n        k_value: 5,\n        generalization_levels: HashMap::from([\n            ("age".to_string(), 1), // 5-year groups\n            ("zipcode".to_string(), 2), // 3-digit prefix\n        ]),\n        data: anonymized_data,\n        privacy_metadata: PrivacyMetadata {\n            technique: "k-anonymity".to_string(),\n            parameters: serde_json::json!({ "k": 5 }),\n            quasi_identifiers: config.quasi_identifiers,\n            sensitive_attributes: config.sensitive_attributes,\n            privacy_loss: processor.privacy_loss(),\n        },\n    };\n    \n    // Create block\n    let block = Block::new(payload)?;\n    println!("Created k-anonymous block: {}", hex::encode(block.hash()));\n    \n    Ok(())\n}\n\nfn create_patient_measurement(age: u32, zipcode: &str, gender: &str, condition: &str) -> Measurement {\n    let mut patient_data = std::collections::HashMap::new();\n    patient_data.insert("age".to_string(), Value::Int(age as i64));\n    patient_data.insert("zipcode".to_string(), Value::String(zipcode.to_string()));\n    patient_data.insert("gender".to_string(), Value::String(gender.to_string()));\n    patient_data.insert("medical_condition".to_string(), Value::String(condition.to_string()));\n    \n    Measurement {\n        value: Value::Object(patient_data),\n        uncertainty: Uncertainty::Exact,\n        provenance: Default::default(),\n        validity: None,\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(n.h3,{id:"limitations-of-k-anonymity",children:"Limitations of K-Anonymity"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'/// K-anonymity vulnerabilities and mitigations\npub struct KAnonymitySecurityAnalysis {\n    pub homogeneity_attack_risk: f64,\n    pub background_knowledge_risk: f64,\n    pub skewness_vulnerability: f64,\n    pub recommended_mitigations: Vec<String>,\n}\n\nimpl KAnonymityProcessor {\n    pub fn analyze_security(&self, data: &[Measurement]) -> KAnonymitySecurityAnalysis {\n        let homogeneity_risk = self.assess_homogeneity_attack(data);\n        let background_risk = self.assess_background_knowledge_attack(data);\n        let skewness_risk = self.assess_skewness_vulnerability(data);\n        \n        let mut mitigations = Vec::new();\n        \n        if homogeneity_risk > 0.5 {\n            mitigations.push("Consider l-diversity to address homogeneity attacks".to_string());\n        }\n        \n        if background_risk > 0.3 {\n            mitigations.push("Apply t-closeness for background knowledge protection".to_string());\n        }\n        \n        if skewness_risk > 0.4 {\n            mitigations.push("Use differential privacy for stronger privacy guarantees".to_string());\n        }\n        \n        KAnonymitySecurityAnalysis {\n            homogeneity_attack_risk: homogeneity_risk,\n            background_knowledge_risk: background_risk,\n            skewness_vulnerability: skewness_risk,\n            recommended_mitigations: mitigations,\n        }\n    }\n\n    fn assess_homogeneity_attack(&self, data: &[Measurement]) -> f64 {\n        // Analyze distribution of sensitive attributes within equivalence classes\n        let mut total_classes = 0;\n        let mut homogeneous_classes = 0;\n        \n        let equivalence_classes = self.group_by_quasi_identifiers(data);\n        \n        for class in equivalence_classes {\n            total_classes += 1;\n            let sensitive_diversity = self.calculate_sensitive_diversity(&class);\n            if sensitive_diversity < 0.3 { // Low diversity threshold\n                homogeneous_classes += 1;\n            }\n        }\n        \n        if total_classes > 0 {\n            homogeneous_classes as f64 / total_classes as f64\n        } else {\n            0.0\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,a.jsx)(n.h3,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod benchmarks {\n    use super::*;\n    use criterion::{black_box, Criterion};\n\n    pub fn benchmark_k_anonymity(c: &mut Criterion) {\n        let config = KAnonymityConfig {\n            k: 10,\n            quasi_identifiers: vec!["age".to_string(), "zipcode".to_string()],\n            sensitive_attributes: vec!["salary".to_string()],\n            suppression_threshold: 0.05,\n        };\n        \n        let processor = KAnonymityProcessor::new(config);\n        \n        // Test with different dataset sizes\n        for size in [100, 1000, 10000].iter() {\n            let data = generate_test_dataset(*size);\n            \n            c.bench_function(&format!("k_anonymity_{}", size), |b| {\n                b.iter(|| {\n                    processor.apply(black_box(data.clone())).unwrap()\n                })\n            });\n        }\n    }\n\n    pub fn benchmark_k_calculation(c: &mut Criterion) {\n        let processor = KAnonymityProcessor::new(KAnonymityConfig {\n            k: 5,\n            quasi_identifiers: vec!["age".to_string()],\n            sensitive_attributes: vec!["salary".to_string()],\n            suppression_threshold: 0.1,\n        });\n        \n        for size in [1000, 5000, 10000].iter() {\n            let data = generate_test_dataset(*size);\n            \n            c.bench_function(&format!("k_calculation_{}", size), |b| {\n                b.iter(|| {\n                    processor.calculate_k_value(black_box(&data)).unwrap()\n                })\n            });\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"performance-targets",children:"Performance Targets"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"K-value calculation"}),": O(n) where n is dataset size"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Generalization"}),": O(n \xd7 m) where m is number of quasi-identifiers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Memory usage"}),": O(n) for equivalence class tracking"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Target latency"}),": <100ms for 10,000 records"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"configuration-guidelines",children:"Configuration Guidelines"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"K-value Selection"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Minimum k=5 for basic privacy"}),"\n",(0,a.jsx)(n.li,{children:"k=10-20 for sensitive healthcare data"}),"\n",(0,a.jsx)(n.li,{children:"k\u226550 for highly sensitive financial data"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Quasi-identifier Selection"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Include all potentially identifying attributes"}),"\n",(0,a.jsx)(n.li,{children:"Consider correlation between attributes"}),"\n",(0,a.jsx)(n.li,{children:"Account for external knowledge availability"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Generalization Hierarchies"}),":"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Design meaningful semantic generalizations"}),"\n",(0,a.jsx)(n.li,{children:"Balance privacy and utility"}),"\n",(0,a.jsx)(n.li,{children:"Consider domain-specific knowledge"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"// Combine with other privacy techniques\npub struct LayeredPrivacyProcessor {\n    k_anonymity: KAnonymityProcessor,\n    differential_privacy: Option<DifferentialPrivacyProcessor>,\n}\n\nimpl LayeredPrivacyProcessor {\n    pub fn apply_layered_privacy(&self, data: Vec<Measurement>) -> Result<Vec<Measurement>, PrivacyError> {\n        // First apply k-anonymity\n        let k_anonymous_data = self.k_anonymity.apply(data)?;\n        \n        // Then apply differential privacy if configured\n        if let Some(dp) = &self.differential_privacy {\n            dp.apply(k_anonymous_data)\n        } else {\n            Ok(k_anonymous_data)\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, thiserror::Error)]\npub enum KAnonymityError {\n    #[error("Missing generalization hierarchy for quasi-identifier: {0}")]\n    MissingHierarchy(String),\n    \n    #[error("Invalid k-value: {0} (must be >= 2)")]\n    InvalidKValue(usize),\n    \n    #[error("Insufficient data for k-anonymity: need at least {needed}, got {actual}")]\n    InsufficientData { needed: usize, actual: usize },\n    \n    #[error("Generalization failed: no valid generalization path found")]\n    GeneralizationFailed,\n    \n    #[error("Suppression threshold exceeded: {suppressed}/{total} records")]\n    SuppressionThresholdExceeded { suppressed: usize, total: usize },\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"This implementation provides a comprehensive k-anonymity solution within the Olocus Privacy extension, ensuring data privacy while maintaining compatibility with the protocol's core measurement and block structures."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);