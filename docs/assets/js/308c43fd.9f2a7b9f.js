"use strict";(globalThis.webpackChunkolocus_docs=globalThis.webpackChunkolocus_docs||[]).push([[8896],{8453:(r,e,n)=>{n.d(e,{R:()=>s,x:()=>a});var o=n(6540);const t={},i=o.createContext(t);function s(r){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function a(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:s(r.components),o.createElement(i.Provider,{value:e},r.children)}},8848:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"api/error-handling","title":"Error Handling","description":"The Olocus Protocol uses a comprehensive error handling system with standardized error codes, structured error types, and recovery patterns. This document covers all error types, handling strategies, and best practices.","source":"@site/docs/api/error-handling.md","sourceDirName":"api","slug":"/api/error-handling","permalink":"/docs/api/error-handling","draft":false,"unlisted":false,"editUrl":"https://codeberg.org/olocus/protocol/edit/main/docs/api/error-handling.md","tags":[],"version":"current","lastUpdatedAt":1764947319000,"sidebarPosition":4,"frontMatter":{"id":"error-handling","title":"Error Handling","sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Wire Format API","permalink":"/docs/api/wire-format-api"},"next":{"title":"Extensions Overview","permalink":"/docs/extensions/overview"}}');var t=n(4848),i=n(8453);const s={id:"error-handling",title:"Error Handling",sidebar_position:4},a="Error Handling",l={},c=[{value:"Error Architecture",id:"error-architecture",level:2},{value:"Core Protocol Errors",id:"core-protocol-errors",level:2},{value:"Basic Protocol Errors (0-12)",id:"basic-protocol-errors-0-12",level:3},{value:"Extended Core Errors (8-49)",id:"extended-core-errors-8-49",level:3},{value:"Plugin System Errors",id:"plugin-system-errors",level:3},{value:"Algorithm Negotiation Errors",id:"algorithm-negotiation-errors",level:2},{value:"Measurement System Errors (50-99)",id:"measurement-system-errors-50-99",level:2},{value:"Provenance Errors",id:"provenance-errors",level:3},{value:"Extension Error Ranges",id:"extension-error-ranges",level:2},{value:"Location Extension (100-199)",id:"location-extension-100-199",level:3},{value:"Trust Extension (200-299)",id:"trust-extension-200-299",level:3},{value:"HSM Extension (1000-1099)",id:"hsm-extension-1000-1099",level:3},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Basic Error Handling",id:"basic-error-handling",level:3},{value:"Error Recovery",id:"error-recovery",level:3},{value:"Error Context and Logging",id:"error-context-and-logging",level:3},{value:"Error Aggregation",id:"error-aggregation",level:3},{value:"Error Conversion and Interop",id:"error-conversion-and-interop",level:2},{value:"Converting Between Error Types",id:"converting-between-error-types",level:3},{value:"Error Serialization",id:"error-serialization",level:3},{value:"Testing Error Conditions",id:"testing-error-conditions",level:2},{value:"Unit Tests for Error Handling",id:"unit-tests-for-error-handling",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Error Monitoring and Metrics",id:"error-monitoring-and-metrics",level:2},{value:"Error Rate Monitoring",id:"error-rate-monitoring",level:3},{value:"Health Checks",id:"health-checks",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling Guidelines",id:"error-handling-guidelines",level:3},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:3},{value:"See Also",id:"see-also",level:2}];function d(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,t.jsx)(e.p,{children:"The Olocus Protocol uses a comprehensive error handling system with standardized error codes, structured error types, and recovery patterns. This document covers all error types, handling strategies, and best practices."}),"\n",(0,t.jsx)(e.h2,{id:"error-architecture",children:"Error Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The protocol uses a hierarchical error code system:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Core Protocol (0-49)"}),": Fundamental protocol errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Measurement System (50-99)"}),": Universal Measurement Foundation errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Extensions (100+)"}),": Extension-specific error ranges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reserved Ranges"}),": Standardized allocation for consistency"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"core-protocol-errors",children:"Core Protocol Errors"}),"\n",(0,t.jsx)(e.h3,{id:"basic-protocol-errors-0-12",children:"Basic Protocol Errors (0-12)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::{Error, Result};\n\n// Core verification errors\nmatch verify_block(&block, Some(&previous)) {\n    Err(Error::BrokenChain) => {\n        println!("Previous hash mismatch - chain integrity violated");\n    }\n    Err(Error::InvalidSignature) => {\n        println!("Cryptographic signature verification failed");\n    }\n    Err(Error::PayloadMismatch) => {\n        println!("Payload hash doesn\'t match computed hash");\n    }\n    Err(Error::InvalidIndex) => {\n        println!("Block index is not sequential");\n    }\n    Err(Error::TimestampRegression) => {\n        println!("Block timestamp is earlier than previous block");\n    }\n    Err(Error::MalformedBlock) => {\n        println!("Block data is corrupted or unparseable");\n    }\n    Ok(()) => println!("Block verification successful"),\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"extended-core-errors-8-49",children:"Extended Core Errors (8-49)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Payload validation errors\nmatch Block::genesis(large_payload, &key, timestamp) {\n    Err(Error::PayloadTooLarge) => {\n        println!("Payload exceeds maximum size limit");\n    }\n    Err(Error::UnknownPayloadType(type_id)) => {\n        println!("Payload type {} is not registered", type_id);\n    }\n    Ok(block) => println!("Block created successfully"),\n}\n\n// Timestamp validation errors\nmatch validate_block_timestamp(timestamp) {\n    Err(Error::TimestampTooFuture) => {\n        println!("Block timestamp is too far in the future");\n    }\n    Err(Error::TimestampTooOld) => {\n        println!("Block timestamp is too old to accept");\n    }\n    Ok(()) => println!("Timestamp valid"),\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"plugin-system-errors",children:"Plugin System Errors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::plugin::PluginRegistry;\n\nlet mut registry = PluginRegistry::new();\n\nmatch registry.register_payload_type(0x1001, "my-extension") {\n    Err(Error::PayloadTypeConflict(type_id)) => {\n        println!("Payload type {} already registered", type_id);\n    }\n    Err(Error::PluginConflict(name)) => {\n        println!("Plugin \'{}\' is already registered", name);\n    }\n    Ok(()) => println!("Plugin registered successfully"),\n}\n\n// Plugin lookup errors\nmatch registry.get_plugin("nonexistent") {\n    Err(Error::PluginNotFound(name)) => {\n        println!("Plugin \'{}\' not found", name);\n    }\n    Ok(plugin) => println!("Plugin found"),\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"algorithm-negotiation-errors",children:"Algorithm Negotiation Errors"}),"\n",(0,t.jsx)(e.p,{children:"Security-focused errors for the algorithm negotiation system:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::algorithm_negotiation::*;\n\n// Negotiation security errors\nmatch negotiate_algorithms(&preferences, &peer_preferences) {\n    Err(Error::DowngradeAttemptDetected) => {\n        println!("SECURITY ALERT: Peer attempting downgrade attack");\n        // Should disconnect and blacklist peer\n    }\n    Err(Error::NoCommonAlgorithm) => {\n        println!("No mutually supported algorithms found");\n    }\n    Err(Error::PeerSecurityTooLow) => {\n        println!("Peer security level below minimum requirements");\n    }\n    Err(Error::PostQuantumRequired) => {\n        println!("Post-quantum algorithms required but not supported by peer");\n    }\n    Ok(negotiated) => {\n        println!("Algorithm negotiation successful");\n    }\n}\n\n// Preference validation errors\nmatch validate_algorithm_preferences(&signed_prefs) {\n    Err(Error::PreferencesTooOld(age)) => {\n        println!("Algorithm preferences are {} seconds old", age);\n    }\n    Err(Error::PreferencesFromFuture) => {\n        println!("Algorithm preferences have future timestamp");\n    }\n    Err(Error::InvalidSignature) => {\n        println!("Preference signature verification failed");\n    }\n    Ok(()) => println!("Preferences valid"),\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"measurement-system-errors-50-99",children:"Measurement System Errors (50-99)"}),"\n",(0,t.jsx)(e.p,{children:"Errors from the Universal Measurement Foundation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::measure::{MeasurementError, Value, Coordinate, Uncertainty};\n\n// Value validation errors\nmatch Value::point2d(91.0, 181.0) { // Invalid coordinates\n    Err(MeasurementError::ValueOutOfRange { min, max, actual }) => {\n        println!("Coordinate {} out of range [{}, {}]", actual, min, max);\n    }\n    Ok(value) => println!("Valid coordinate"),\n}\n\n// Coordinate validation\nmatch Coordinate::validate(1000000000, 0) { // > 90 degrees\n    Err(MeasurementError::ValueOutOfRange { .. }) => {\n        println!("Latitude exceeds valid range");\n    }\n    Ok(()) => println!("Coordinates valid"),\n}\n\n// Uncertainty validation\nlet invalid_confidence = 1.5; // > 1.0\nmatch Uncertainty::confidence(invalid_confidence) {\n    // This creates a valid Uncertainty but clips to 1.0\n    uncertainty => {\n        if uncertainty.to_confidence() != invalid_confidence {\n            println!("Confidence value was clamped to valid range");\n        }\n    }\n}\n\n// Measurement expiry\nmatch measurement.validity.is_valid_at(future_time) {\n    false => {\n        return Err(MeasurementError::Expired {\n            valid_until: measurement.validity.valid_until.unwrap(),\n            now: future_time,\n        });\n    }\n    true => println!("Measurement still valid"),\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"provenance-errors",children:"Provenance Errors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use olocus_core::measure::{Provenance, AttestationClaim};\n\n// Circular provenance detection\nmatch validate_provenance_chain(&measurement) {\n    Err(MeasurementError::CircularProvenance) => {\n        println!("Circular dependency in provenance chain detected");\n    }\n    Err(MeasurementError::InvalidTransformationChain) => {\n        println!("Transformation chain is invalid or broken");\n    }\n    Ok(()) => println!("Provenance chain valid"),\n}\n\n// Attestation verification\nmatch verify_attestation(&attestation, &measurement_hash) {\n    Err(MeasurementError::AttestationVerificationFailed { attestor }) => {\n        println!("Attestation from {:?} failed verification", attestor);\n    }\n    Ok(()) => println!("Attestation verified"),\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"extension-error-ranges",children:"Extension Error Ranges"}),"\n",(0,t.jsx)(e.p,{children:"Extensions use standardized error code ranges:"}),"\n",(0,t.jsx)(e.h3,{id:"location-extension-100-199",children:"Location Extension (100-199)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Example location errors (would be in olocus-location crate)\n#[derive(Error, Debug)]\npub enum LocationError {\n    #[error("GPS signal lost")]\n    GpsSignalLost,\n    \n    #[error("Location spoofing detected")]\n    SpoofingDetected,\n    \n    #[error("Insufficient satellites: {count} (need 4+)")]\n    InsufficientSatellites { count: u8 },\n    \n    #[error("Clustering failed: {reason}")]\n    ClusteringFailed { reason: String },\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"trust-extension-200-299",children:"Trust Extension (200-299)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Example trust errors (would be in olocus-trust crate)\n#[derive(Error, Debug)]\npub enum TrustError {\n    #[error("Trust score too low: {score} < {threshold}")]\n    TrustTooLow { score: f64, threshold: f64 },\n    \n    #[error("Reputation not found for peer: {peer_id:?}")]\n    ReputationNotFound { peer_id: [u8; 32] },\n    \n    #[error("DID verification failed")]\n    DidVerificationFailed,\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"hsm-extension-1000-1099",children:"HSM Extension (1000-1099)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// Example HSM errors (would be in olocus-hsm crate)  \n#[derive(Error, Debug)]\npub enum HsmError {\n    #[error("HSM not available")]\n    HsmNotAvailable,\n    \n    #[error("Key not found in HSM: {key_id}")]\n    KeyNotFound { key_id: String },\n    \n    #[error("HSM session pool exhausted")]\n    SessionPoolExhausted,\n    \n    #[error("PKCS#11 error: {code}")]\n    Pkcs11Error { code: u32 },\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,t.jsx)(e.h3,{id:"basic-error-handling",children:"Basic Error Handling"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use olocus_core::{Error, Result};\n\nfn process_block<P: BlockPayload>(block: &Block<P>) -> Result<()> {\n    // Validate block\n    verify_block(block, None)?;\n    \n    // Process payload\n    match block.payload.payload_type() {\n        0x0100 => process_location_payload(&block.payload)?,\n        0x0200 => process_sensor_payload(&block.payload)?,\n        unknown => return Err(Error::UnknownPayloadType(unknown)),\n    }\n    \n    Ok(())\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-recovery",children:"Error Recovery"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn robust_block_verification<P: BlockPayload>(\n    block: &Block<P>,\n    previous: Option<&Block<P>>\n) -> Result<()> {\n    match verify_block(block, previous) {\n        // Recoverable errors - could retry or use fallback\n        Err(Error::TimestampTooFuture) => {\n            println!("Block from future - queuing for later processing");\n            queue_for_later_processing(block.clone());\n            Ok(())\n        }\n        \n        // Security errors - reject immediately\n        Err(Error::InvalidSignature) => {\n            println!("Invalid signature - rejecting block permanently");\n            Err(Error::InvalidSignature)\n        }\n        \n        Err(Error::BrokenChain) => {\n            println!("Chain broken - may need chain reorganization");\n            attempt_chain_reorg(block)\n        }\n        \n        // Success\n        Ok(()) => Ok(()),\n        \n        // Other errors - propagate\n        Err(e) => Err(e),\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"error-context-and-logging",children:"Error Context and Logging"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use log::{error, warn, info, debug};\n\nfn detailed_error_handling<P: BlockPayload>(result: Result<Block<P>>) {\n    match result {\n        Ok(block) => {\n            info!("Block {} processed successfully", block.header.index);\n        }\n        Err(Error::InvalidSignature) => {\n            error!("SECURITY: Invalid signature detected - possible attack");\n            // Could trigger security alerts\n        }\n        Err(Error::BrokenChain) => {\n            warn!("Chain integrity issue - investigating");\n            // Could trigger chain analysis\n        }\n        Err(Error::TimestampTooOld) => {\n            debug!("Block too old - likely stale data");\n            // Could update sync status\n        }\n        Err(e) => {\n            error!("Unexpected error processing block: {}", e);\n            // Could trigger system health check\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"error-aggregation",children:"Error Aggregation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::collections::HashMap;\n\n#[derive(Debug)]\npub struct ErrorSummary {\n    pub total_errors: usize,\n    pub error_counts: HashMap<String, usize>,\n    pub last_error: Option<Error>,\n}\n\nimpl ErrorSummary {\n    pub fn new() -> Self {\n        Self {\n            total_errors: 0,\n            error_counts: HashMap::new(),\n            last_error: None,\n        }\n    }\n    \n    pub fn record_error(&mut self, error: Error) {\n        let error_type = format!("{:?}", error);\n        *self.error_counts.entry(error_type).or_insert(0) += 1;\n        self.total_errors += 1;\n        self.last_error = Some(error);\n    }\n    \n    pub fn most_common_error(&self) -> Option<&String> {\n        self.error_counts\n            .iter()\n            .max_by_key(|(_, count)| *count)\n            .map(|(error_type, _)| error_type)\n    }\n}\n\n// Usage\nfn process_blocks<P: BlockPayload>(blocks: &[Block<P>]) -> ErrorSummary {\n    let mut errors = ErrorSummary::new();\n    \n    for block in blocks {\n        if let Err(e) = verify_block(block, None) {\n            errors.record_error(e);\n        }\n    }\n    \n    errors\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"error-conversion-and-interop",children:"Error Conversion and Interop"}),"\n",(0,t.jsx)(e.h3,{id:"converting-between-error-types",children:"Converting Between Error Types"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use thiserror::Error;\n\n// Custom error type that can contain protocol errors\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error("Protocol error: {0}")]\n    Protocol(#[from] Error),\n    \n    #[error("Measurement error: {0}")]\n    Measurement(#[from] MeasurementError),\n    \n    #[error("IO error: {0}")]\n    Io(#[from] std::io::Error),\n    \n    #[error("Database error: {message}")]\n    Database { message: String },\n}\n\n// Conversion functions\nimpl From<serde_json::Error> for AppError {\n    fn from(e: serde_json::Error) -> Self {\n        AppError::Protocol(Error::MalformedBlock)\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"error-serialization",children:"Error Serialization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct SerializableError {\n    pub error_type: String,\n    pub message: String,\n    pub code: Option<u32>,\n    pub context: Option<String>,\n}\n\nimpl From<Error> for SerializableError {\n    fn from(error: Error) -> Self {\n        let (error_type, code) = match &error {\n            Error::InvalidSignature => ("InvalidSignature", Some(6)),\n            Error::BrokenChain => ("BrokenChain", Some(2)),\n            Error::MalformedBlock => ("MalformedBlock", Some(7)),\n            Error::UnknownPayloadType(t) => ("UnknownPayloadType", Some(*t)),\n            _ => ("Other", None),\n        };\n        \n        Self {\n            error_type: error_type.to_string(),\n            message: error.to_string(),\n            code,\n            context: None,\n        }\n    }\n}\n\n// For HTTP APIs\nfn error_to_http_status(error: &Error) -> (u16, SerializableError) {\n    let serializable = error.clone().into();\n    \n    let status_code = match error {\n        Error::InvalidSignature => 400, // Bad Request\n        Error::BrokenChain => 409,      // Conflict\n        Error::MalformedBlock => 400,   // Bad Request\n        Error::PayloadTooLarge => 413,  // Payload Too Large\n        Error::UnknownPayloadType(_) => 422, // Unprocessable Entity\n        _ => 500, // Internal Server Error\n    };\n    \n    (status_code, serializable)\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"testing-error-conditions",children:"Testing Error Conditions"}),"\n",(0,t.jsx)(e.h3,{id:"unit-tests-for-error-handling",children:"Unit Tests for Error Handling"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[cfg(test)]\nmod error_tests {\n    use super::*;\n    \n    #[test]\n    fn test_invalid_signature_error() {\n        let (key1, _) = generate_key();\n        let (key2, _) = generate_key(); \n        \n        // Create block with key1, try to verify with key2\n        let block = Block::genesis(EmptyPayload, &key1, current_timestamp());\n        \n        // This should fail with InvalidSignature\n        match verify_block(&block, None) {\n            Err(Error::InvalidSignature) => {\n                // Expected\n            }\n            other => panic!("Expected InvalidSignature, got {:?}", other),\n        }\n    }\n    \n    #[test]\n    fn test_broken_chain_error() {\n        let key = generate_key();\n        let block1 = Block::genesis(EmptyPayload, &key, current_timestamp());\n        let mut block2 = Block::next(&block1, EmptyPayload, &key, current_timestamp()).unwrap();\n        \n        // Corrupt the previous hash\n        block2.header.previous = [0u8; 32];\n        \n        match verify_block(&block2, Some(&block1)) {\n            Err(Error::BrokenChain) => {\n                // Expected\n            }\n            other => panic!("Expected BrokenChain, got {:?}", other),\n        }\n    }\n    \n    #[test]\n    fn test_error_serialization() {\n        let error = Error::UnknownPayloadType(0x1234);\n        let serializable: SerializableError = error.into();\n        \n        assert_eq!(serializable.error_type, "UnknownPayloadType");\n        assert_eq!(serializable.code, Some(0x1234));\n        \n        let json = serde_json::to_string(&serializable).unwrap();\n        let deserialized: SerializableError = serde_json::from_str(&json).unwrap();\n        assert_eq!(serializable.error_type, deserialized.error_type);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'#[tokio::test]\nasync fn test_error_recovery_in_chain_processing() {\n    let blocks = create_test_chain_with_errors(); // Some valid, some invalid\n    let mut processed = 0;\n    let mut errors = ErrorSummary::new();\n    \n    for block in blocks {\n        match process_block(&block).await {\n            Ok(()) => processed += 1,\n            Err(e) => errors.record_error(e),\n        }\n    }\n    \n    // Should have processed some blocks despite errors\n    assert!(processed > 0);\n    assert!(errors.total_errors > 0);\n    \n    // Most common error should be predictable\n    if let Some(common_error) = errors.most_common_error() {\n        println!("Most common error: {}", common_error);\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"error-monitoring-and-metrics",children:"Error Monitoring and Metrics"}),"\n",(0,t.jsx)(e.h3,{id:"error-rate-monitoring",children:"Error Rate Monitoring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct ErrorMetrics {\n    total_operations: Arc<AtomicU64>,\n    total_errors: Arc<AtomicU64>,\n    signature_errors: Arc<AtomicU64>,\n    chain_errors: Arc<AtomicU64>,\n    malformed_errors: Arc<AtomicU64>,\n}\n\nimpl ErrorMetrics {\n    pub fn new() -> Self {\n        Self {\n            total_operations: Arc::new(AtomicU64::new(0)),\n            total_errors: Arc::new(AtomicU64::new(0)),\n            signature_errors: Arc::new(AtomicU64::new(0)),\n            chain_errors: Arc::new(AtomicU64::new(0)),\n            malformed_errors: Arc::new(AtomicU64::new(0)),\n        }\n    }\n    \n    pub fn record_operation(&self, result: &Result<()>) {\n        self.total_operations.fetch_add(1, Ordering::Relaxed);\n        \n        if let Err(error) = result {\n            self.total_errors.fetch_add(1, Ordering::Relaxed);\n            \n            match error {\n                Error::InvalidSignature => {\n                    self.signature_errors.fetch_add(1, Ordering::Relaxed);\n                }\n                Error::BrokenChain => {\n                    self.chain_errors.fetch_add(1, Ordering::Relaxed);\n                }\n                Error::MalformedBlock => {\n                    self.malformed_errors.fetch_add(1, Ordering::Relaxed);\n                }\n                _ => {}\n            }\n        }\n    }\n    \n    pub fn error_rate(&self) -> f64 {\n        let total = self.total_operations.load(Ordering::Relaxed) as f64;\n        let errors = self.total_errors.load(Ordering::Relaxed) as f64;\n        \n        if total == 0.0 { 0.0 } else { errors / total }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"health-checks",children:"Health Checks"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"#[derive(Debug)]\npub struct SystemHealth {\n    pub error_rate: f64,\n    pub recent_errors: Vec<Error>,\n    pub status: HealthStatus,\n}\n\n#[derive(Debug, PartialEq)]\npub enum HealthStatus {\n    Healthy,\n    Degraded,\n    Unhealthy,\n}\n\nimpl SystemHealth {\n    pub fn assess(metrics: &ErrorMetrics) -> Self {\n        let error_rate = metrics.error_rate();\n        \n        let status = if error_rate < 0.01 {\n            HealthStatus::Healthy\n        } else if error_rate < 0.05 {\n            HealthStatus::Degraded\n        } else {\n            HealthStatus::Unhealthy\n        };\n        \n        Self {\n            error_rate,\n            recent_errors: vec![], // Would be populated with recent errors\n            status,\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(e.h3,{id:"error-handling-guidelines",children:"Error Handling Guidelines"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Always Handle Errors"}),": Never ignore ",(0,t.jsx)(e.code,{children:"Result"})," types"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fail Fast"}),": Detect and report errors early"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Provide Context"}),": Include relevant information in error messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Log Appropriately"}),": Use appropriate log levels for different error types"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Monitor Metrics"}),": Track error rates and patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test Error Paths"}),": Ensure error handling code is tested"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'// DON\'T: Log sensitive information\nfn bad_error_handling(key: &[u8; 32], error: Error) {\n    log::error!("Failed to sign with key {:?}: {}", key, error);\n}\n\n// DO: Log safely without exposing secrets\nfn good_error_handling(error: Error) {\n    log::error!("Signing operation failed: {}", error);\n}\n\n// DON\'T: Expose internal details in public errors\nfn bad_public_error() -> Result<(), String> {\n    Err("Database connection failed: postgresql://user:pass@internal-db:5432/prod".to_string())\n}\n\n// DO: Provide safe error information\nfn good_public_error() -> Result<(), Error> {\n    Err(Error::MalformedBlock)\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::time::Duration;\nuse tokio::time::{sleep, timeout};\n\nasync fn retry_with_backoff<T, F, Fut>(\n    mut operation: F,\n    max_retries: usize,\n    base_delay: Duration,\n) -> Result<T>\nwhere\n    F: FnMut() -> Fut,\n    Fut: std::future::Future<Output = Result<T>>,\n{\n    let mut delay = base_delay;\n    \n    for attempt in 0..max_retries {\n        match timeout(Duration::from_secs(30), operation()).await {\n            Ok(Ok(result)) => return Ok(result),\n            Ok(Err(Error::InvalidSignature)) => {\n                // Security error - don't retry\n                return Err(Error::InvalidSignature);\n            }\n            Ok(Err(Error::PayloadTooLarge)) => {\n                // Permanent error - don't retry\n                return Err(Error::PayloadTooLarge);\n            }\n            Ok(Err(_)) | Err(_) => {\n                // Potentially transient error - retry with backoff\n                if attempt < max_retries - 1 {\n                    log::warn!(\"Operation failed, retrying in {:?} (attempt {})\", delay, attempt + 1);\n                    sleep(delay).await;\n                    delay *= 2; // Exponential backoff\n                }\n            }\n        }\n    }\n    \n    Err(Error::MalformedBlock) // Generic failure after retries\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"./core",children:"Core API Overview"})," - Protocol fundamentals"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"./block-operations",children:"Block Operations API"})," - Block handling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"./measurement-api",children:"Measurement API"})," - Measurement system errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"./wire-format-api",children:"Wire Format API"})," - Encoding/decoding errors"]}),"\n"]})]})}function u(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}}}]);